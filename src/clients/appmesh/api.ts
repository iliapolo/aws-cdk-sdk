import * as cdk from '@aws-cdk/core';
import * as cr from '@aws-cdk/custom-resources';
import * as shapes from './shapes';

export class AppMeshClient extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[]) {
    super(scope, id);
  }

  public createGatewayRoute(input: shapes.AppMeshCreateGatewayRouteInput): AppMeshCreateGatewayRoute {
    return new AppMeshCreateGatewayRoute(this, 'CreateGatewayRoute', this.__resources, input);
  }

  public createMesh(input: shapes.AppMeshCreateMeshInput): AppMeshCreateMesh {
    return new AppMeshCreateMesh(this, 'CreateMesh', this.__resources, input);
  }

  public createRoute(input: shapes.AppMeshCreateRouteInput): AppMeshCreateRoute {
    return new AppMeshCreateRoute(this, 'CreateRoute', this.__resources, input);
  }

  public createVirtualGateway(input: shapes.AppMeshCreateVirtualGatewayInput): AppMeshCreateVirtualGateway {
    return new AppMeshCreateVirtualGateway(this, 'CreateVirtualGateway', this.__resources, input);
  }

  public createVirtualNode(input: shapes.AppMeshCreateVirtualNodeInput): AppMeshCreateVirtualNode {
    return new AppMeshCreateVirtualNode(this, 'CreateVirtualNode', this.__resources, input);
  }

  public createVirtualRouter(input: shapes.AppMeshCreateVirtualRouterInput): AppMeshCreateVirtualRouter {
    return new AppMeshCreateVirtualRouter(this, 'CreateVirtualRouter', this.__resources, input);
  }

  public createVirtualService(input: shapes.AppMeshCreateVirtualServiceInput): AppMeshCreateVirtualService {
    return new AppMeshCreateVirtualService(this, 'CreateVirtualService', this.__resources, input);
  }

  public deleteGatewayRoute(input: shapes.AppMeshDeleteGatewayRouteInput): AppMeshDeleteGatewayRoute {
    return new AppMeshDeleteGatewayRoute(this, 'DeleteGatewayRoute', this.__resources, input);
  }

  public deleteMesh(input: shapes.AppMeshDeleteMeshInput): AppMeshDeleteMesh {
    return new AppMeshDeleteMesh(this, 'DeleteMesh', this.__resources, input);
  }

  public deleteRoute(input: shapes.AppMeshDeleteRouteInput): AppMeshDeleteRoute {
    return new AppMeshDeleteRoute(this, 'DeleteRoute', this.__resources, input);
  }

  public deleteVirtualGateway(input: shapes.AppMeshDeleteVirtualGatewayInput): AppMeshDeleteVirtualGateway {
    return new AppMeshDeleteVirtualGateway(this, 'DeleteVirtualGateway', this.__resources, input);
  }

  public deleteVirtualNode(input: shapes.AppMeshDeleteVirtualNodeInput): AppMeshDeleteVirtualNode {
    return new AppMeshDeleteVirtualNode(this, 'DeleteVirtualNode', this.__resources, input);
  }

  public deleteVirtualRouter(input: shapes.AppMeshDeleteVirtualRouterInput): AppMeshDeleteVirtualRouter {
    return new AppMeshDeleteVirtualRouter(this, 'DeleteVirtualRouter', this.__resources, input);
  }

  public deleteVirtualService(input: shapes.AppMeshDeleteVirtualServiceInput): AppMeshDeleteVirtualService {
    return new AppMeshDeleteVirtualService(this, 'DeleteVirtualService', this.__resources, input);
  }

  public describeGatewayRoute(input: shapes.AppMeshDescribeGatewayRouteInput): AppMeshDescribeGatewayRoute {
    return new AppMeshDescribeGatewayRoute(this, 'DescribeGatewayRoute', this.__resources, input);
  }

  public describeMesh(input: shapes.AppMeshDescribeMeshInput): AppMeshDescribeMesh {
    return new AppMeshDescribeMesh(this, 'DescribeMesh', this.__resources, input);
  }

  public describeRoute(input: shapes.AppMeshDescribeRouteInput): AppMeshDescribeRoute {
    return new AppMeshDescribeRoute(this, 'DescribeRoute', this.__resources, input);
  }

  public describeVirtualGateway(input: shapes.AppMeshDescribeVirtualGatewayInput): AppMeshDescribeVirtualGateway {
    return new AppMeshDescribeVirtualGateway(this, 'DescribeVirtualGateway', this.__resources, input);
  }

  public describeVirtualNode(input: shapes.AppMeshDescribeVirtualNodeInput): AppMeshDescribeVirtualNode {
    return new AppMeshDescribeVirtualNode(this, 'DescribeVirtualNode', this.__resources, input);
  }

  public describeVirtualRouter(input: shapes.AppMeshDescribeVirtualRouterInput): AppMeshDescribeVirtualRouter {
    return new AppMeshDescribeVirtualRouter(this, 'DescribeVirtualRouter', this.__resources, input);
  }

  public describeVirtualService(input: shapes.AppMeshDescribeVirtualServiceInput): AppMeshDescribeVirtualService {
    return new AppMeshDescribeVirtualService(this, 'DescribeVirtualService', this.__resources, input);
  }

  public listGatewayRoutes(input: shapes.AppMeshListGatewayRoutesInput): AppMeshListGatewayRoutes {
    return new AppMeshListGatewayRoutes(this, 'ListGatewayRoutes', this.__resources, input);
  }

  public listMeshes(input: shapes.AppMeshListMeshesInput): AppMeshListMeshes {
    return new AppMeshListMeshes(this, 'ListMeshes', this.__resources, input);
  }

  public listRoutes(input: shapes.AppMeshListRoutesInput): AppMeshListRoutes {
    return new AppMeshListRoutes(this, 'ListRoutes', this.__resources, input);
  }

  public listTagsForResource(input: shapes.AppMeshListTagsForResourceInput): AppMeshListTagsForResource {
    return new AppMeshListTagsForResource(this, 'ListTagsForResource', this.__resources, input);
  }

  public listVirtualGateways(input: shapes.AppMeshListVirtualGatewaysInput): AppMeshListVirtualGateways {
    return new AppMeshListVirtualGateways(this, 'ListVirtualGateways', this.__resources, input);
  }

  public listVirtualNodes(input: shapes.AppMeshListVirtualNodesInput): AppMeshListVirtualNodes {
    return new AppMeshListVirtualNodes(this, 'ListVirtualNodes', this.__resources, input);
  }

  public listVirtualRouters(input: shapes.AppMeshListVirtualRoutersInput): AppMeshListVirtualRouters {
    return new AppMeshListVirtualRouters(this, 'ListVirtualRouters', this.__resources, input);
  }

  public listVirtualServices(input: shapes.AppMeshListVirtualServicesInput): AppMeshListVirtualServices {
    return new AppMeshListVirtualServices(this, 'ListVirtualServices', this.__resources, input);
  }

  public tagResource(input: shapes.AppMeshTagResourceInput): void {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'tagResource',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.TagResource'),
        parameters: {
          resourceArn: input.resourceArn,
          tags: input.tags,
        },
      },
    };
    new cr.AwsCustomResource(this, 'TagResource', props);
  }

  public untagResource(input: shapes.AppMeshUntagResourceInput): void {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'untagResource',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UntagResource'),
        parameters: {
          resourceArn: input.resourceArn,
          tagKeys: input.tagKeys,
        },
      },
    };
    new cr.AwsCustomResource(this, 'UntagResource', props);
  }

  public updateGatewayRoute(input: shapes.AppMeshUpdateGatewayRouteInput): AppMeshUpdateGatewayRoute {
    return new AppMeshUpdateGatewayRoute(this, 'UpdateGatewayRoute', this.__resources, input);
  }

  public updateMesh(input: shapes.AppMeshUpdateMeshInput): AppMeshUpdateMesh {
    return new AppMeshUpdateMesh(this, 'UpdateMesh', this.__resources, input);
  }

  public updateRoute(input: shapes.AppMeshUpdateRouteInput): AppMeshUpdateRoute {
    return new AppMeshUpdateRoute(this, 'UpdateRoute', this.__resources, input);
  }

  public updateVirtualGateway(input: shapes.AppMeshUpdateVirtualGatewayInput): AppMeshUpdateVirtualGateway {
    return new AppMeshUpdateVirtualGateway(this, 'UpdateVirtualGateway', this.__resources, input);
  }

  public updateVirtualNode(input: shapes.AppMeshUpdateVirtualNodeInput): AppMeshUpdateVirtualNode {
    return new AppMeshUpdateVirtualNode(this, 'UpdateVirtualNode', this.__resources, input);
  }

  public updateVirtualRouter(input: shapes.AppMeshUpdateVirtualRouterInput): AppMeshUpdateVirtualRouter {
    return new AppMeshUpdateVirtualRouter(this, 'UpdateVirtualRouter', this.__resources, input);
  }

  public updateVirtualService(input: shapes.AppMeshUpdateVirtualServiceInput): AppMeshUpdateVirtualService {
    return new AppMeshUpdateVirtualService(this, 'UpdateVirtualService', this.__resources, input);
  }

}

export class AppMeshCreateGatewayRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateGatewayRouteInput) {
    super(scope, id);
  }

  public get gatewayRoute(): AppMeshCreateGatewayRouteGatewayRoute {
    return new AppMeshCreateGatewayRouteGatewayRoute(this, 'GatewayRoute', this.__resources, this.input);
  }

}

export class AppMeshCreateGatewayRouteGatewayRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateGatewayRouteInput) {
    super(scope, id);
  }

  public get gatewayRouteName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.gatewayRouteName'),
        outputPath: 'gatewayRoute.gatewayRouteName',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateGatewayRoute.gatewayRoute.gatewayRouteName', props);
    return resource.getResponseField('gatewayRoute.gatewayRouteName') as unknown as string;
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.meshName'),
        outputPath: 'gatewayRoute.meshName',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateGatewayRoute.gatewayRoute.meshName', props);
    return resource.getResponseField('gatewayRoute.meshName') as unknown as string;
  }

  public get metadata(): AppMeshCreateGatewayRouteGatewayRouteMetadata {
    return new AppMeshCreateGatewayRouteGatewayRouteMetadata(this, 'Metadata', this.__resources, this.input);
  }

  public get spec(): AppMeshCreateGatewayRouteGatewayRouteSpec {
    return new AppMeshCreateGatewayRouteGatewayRouteSpec(this, 'Spec', this.__resources, this.input);
  }

  public get status(): AppMeshCreateGatewayRouteGatewayRouteStatus {
    return new AppMeshCreateGatewayRouteGatewayRouteStatus(this, 'Status', this.__resources, this.input);
  }

  public get virtualGatewayName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.virtualGatewayName'),
        outputPath: 'gatewayRoute.virtualGatewayName',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateGatewayRoute.gatewayRoute.virtualGatewayName', props);
    return resource.getResponseField('gatewayRoute.virtualGatewayName') as unknown as string;
  }

}

export class AppMeshCreateGatewayRouteGatewayRouteMetadata extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateGatewayRouteInput) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.metadata.arn'),
        outputPath: 'gatewayRoute.metadata.arn',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateGatewayRoute.gatewayRoute.metadata.arn', props);
    return resource.getResponseField('gatewayRoute.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.metadata.createdAt'),
        outputPath: 'gatewayRoute.metadata.createdAt',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateGatewayRoute.gatewayRoute.metadata.createdAt', props);
    return resource.getResponseField('gatewayRoute.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.metadata.lastUpdatedAt'),
        outputPath: 'gatewayRoute.metadata.lastUpdatedAt',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateGatewayRoute.gatewayRoute.metadata.lastUpdatedAt', props);
    return resource.getResponseField('gatewayRoute.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.metadata.meshOwner'),
        outputPath: 'gatewayRoute.metadata.meshOwner',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateGatewayRoute.gatewayRoute.metadata.meshOwner', props);
    return resource.getResponseField('gatewayRoute.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.metadata.resourceOwner'),
        outputPath: 'gatewayRoute.metadata.resourceOwner',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateGatewayRoute.gatewayRoute.metadata.resourceOwner', props);
    return resource.getResponseField('gatewayRoute.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.metadata.uid'),
        outputPath: 'gatewayRoute.metadata.uid',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateGatewayRoute.gatewayRoute.metadata.uid', props);
    return resource.getResponseField('gatewayRoute.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.metadata.version'),
        outputPath: 'gatewayRoute.metadata.version',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateGatewayRoute.gatewayRoute.metadata.version', props);
    return resource.getResponseField('gatewayRoute.metadata.version') as unknown as number;
  }

}

export class AppMeshCreateGatewayRouteGatewayRouteSpec extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateGatewayRouteInput) {
    super(scope, id);
  }

  public get grpcRoute(): AppMeshCreateGatewayRouteGatewayRouteSpecGrpcRoute {
    return new AppMeshCreateGatewayRouteGatewayRouteSpecGrpcRoute(this, 'GrpcRoute', this.__resources, this.input);
  }

  public get http2Route(): AppMeshCreateGatewayRouteGatewayRouteSpecHttp2Route {
    return new AppMeshCreateGatewayRouteGatewayRouteSpecHttp2Route(this, 'Http2Route', this.__resources, this.input);
  }

  public get httpRoute(): AppMeshCreateGatewayRouteGatewayRouteSpecHttpRoute {
    return new AppMeshCreateGatewayRouteGatewayRouteSpecHttpRoute(this, 'HttpRoute', this.__resources, this.input);
  }

}

export class AppMeshCreateGatewayRouteGatewayRouteSpecGrpcRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateGatewayRouteInput) {
    super(scope, id);
  }

  public get action(): AppMeshCreateGatewayRouteGatewayRouteSpecGrpcRouteAction {
    return new AppMeshCreateGatewayRouteGatewayRouteSpecGrpcRouteAction(this, 'Action', this.__resources, this.input);
  }

  public get match(): AppMeshCreateGatewayRouteGatewayRouteSpecGrpcRouteMatch {
    return new AppMeshCreateGatewayRouteGatewayRouteSpecGrpcRouteMatch(this, 'Match', this.__resources, this.input);
  }

}

export class AppMeshCreateGatewayRouteGatewayRouteSpecGrpcRouteAction extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateGatewayRouteInput) {
    super(scope, id);
  }

  public get target(): AppMeshCreateGatewayRouteGatewayRouteSpecGrpcRouteActionTarget {
    return new AppMeshCreateGatewayRouteGatewayRouteSpecGrpcRouteActionTarget(this, 'Target', this.__resources, this.input);
  }

}

export class AppMeshCreateGatewayRouteGatewayRouteSpecGrpcRouteActionTarget extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateGatewayRouteInput) {
    super(scope, id);
  }

  public get virtualService(): AppMeshCreateGatewayRouteGatewayRouteSpecGrpcRouteActionTargetVirtualService {
    return new AppMeshCreateGatewayRouteGatewayRouteSpecGrpcRouteActionTargetVirtualService(this, 'VirtualService', this.__resources, this.input);
  }

}

export class AppMeshCreateGatewayRouteGatewayRouteSpecGrpcRouteActionTargetVirtualService extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateGatewayRouteInput) {
    super(scope, id);
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName'),
        outputPath: 'gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateGatewayRoute.gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName', props);
    return resource.getResponseField('gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshCreateGatewayRouteGatewayRouteSpecGrpcRouteMatch extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateGatewayRouteInput) {
    super(scope, id);
  }

  public get serviceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.spec.grpcRoute.match.serviceName'),
        outputPath: 'gatewayRoute.spec.grpcRoute.match.serviceName',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateGatewayRoute.gatewayRoute.spec.grpcRoute.match.serviceName', props);
    return resource.getResponseField('gatewayRoute.spec.grpcRoute.match.serviceName') as unknown as string;
  }

}

export class AppMeshCreateGatewayRouteGatewayRouteSpecHttp2Route extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateGatewayRouteInput) {
    super(scope, id);
  }

  public get action(): AppMeshCreateGatewayRouteGatewayRouteSpecHttp2RouteAction {
    return new AppMeshCreateGatewayRouteGatewayRouteSpecHttp2RouteAction(this, 'Action', this.__resources, this.input);
  }

  public get match(): AppMeshCreateGatewayRouteGatewayRouteSpecHttp2RouteMatch {
    return new AppMeshCreateGatewayRouteGatewayRouteSpecHttp2RouteMatch(this, 'Match', this.__resources, this.input);
  }

}

export class AppMeshCreateGatewayRouteGatewayRouteSpecHttp2RouteAction extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateGatewayRouteInput) {
    super(scope, id);
  }

  public get target(): AppMeshCreateGatewayRouteGatewayRouteSpecHttp2RouteActionTarget {
    return new AppMeshCreateGatewayRouteGatewayRouteSpecHttp2RouteActionTarget(this, 'Target', this.__resources, this.input);
  }

}

export class AppMeshCreateGatewayRouteGatewayRouteSpecHttp2RouteActionTarget extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateGatewayRouteInput) {
    super(scope, id);
  }

  public get virtualService(): AppMeshCreateGatewayRouteGatewayRouteSpecHttp2RouteActionTargetVirtualService {
    return new AppMeshCreateGatewayRouteGatewayRouteSpecHttp2RouteActionTargetVirtualService(this, 'VirtualService', this.__resources, this.input);
  }

}

export class AppMeshCreateGatewayRouteGatewayRouteSpecHttp2RouteActionTargetVirtualService extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateGatewayRouteInput) {
    super(scope, id);
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName'),
        outputPath: 'gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateGatewayRoute.gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName', props);
    return resource.getResponseField('gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshCreateGatewayRouteGatewayRouteSpecHttp2RouteMatch extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateGatewayRouteInput) {
    super(scope, id);
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.spec.http2Route.match.prefix'),
        outputPath: 'gatewayRoute.spec.http2Route.match.prefix',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateGatewayRoute.gatewayRoute.spec.http2Route.match.prefix', props);
    return resource.getResponseField('gatewayRoute.spec.http2Route.match.prefix') as unknown as string;
  }

}

export class AppMeshCreateGatewayRouteGatewayRouteSpecHttpRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateGatewayRouteInput) {
    super(scope, id);
  }

  public get action(): AppMeshCreateGatewayRouteGatewayRouteSpecHttpRouteAction {
    return new AppMeshCreateGatewayRouteGatewayRouteSpecHttpRouteAction(this, 'Action', this.__resources, this.input);
  }

  public get match(): AppMeshCreateGatewayRouteGatewayRouteSpecHttpRouteMatch {
    return new AppMeshCreateGatewayRouteGatewayRouteSpecHttpRouteMatch(this, 'Match', this.__resources, this.input);
  }

}

export class AppMeshCreateGatewayRouteGatewayRouteSpecHttpRouteAction extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateGatewayRouteInput) {
    super(scope, id);
  }

  public get target(): AppMeshCreateGatewayRouteGatewayRouteSpecHttpRouteActionTarget {
    return new AppMeshCreateGatewayRouteGatewayRouteSpecHttpRouteActionTarget(this, 'Target', this.__resources, this.input);
  }

}

export class AppMeshCreateGatewayRouteGatewayRouteSpecHttpRouteActionTarget extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateGatewayRouteInput) {
    super(scope, id);
  }

  public get virtualService(): AppMeshCreateGatewayRouteGatewayRouteSpecHttpRouteActionTargetVirtualService {
    return new AppMeshCreateGatewayRouteGatewayRouteSpecHttpRouteActionTargetVirtualService(this, 'VirtualService', this.__resources, this.input);
  }

}

export class AppMeshCreateGatewayRouteGatewayRouteSpecHttpRouteActionTargetVirtualService extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateGatewayRouteInput) {
    super(scope, id);
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName'),
        outputPath: 'gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateGatewayRoute.gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName', props);
    return resource.getResponseField('gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshCreateGatewayRouteGatewayRouteSpecHttpRouteMatch extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateGatewayRouteInput) {
    super(scope, id);
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.spec.httpRoute.match.prefix'),
        outputPath: 'gatewayRoute.spec.httpRoute.match.prefix',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateGatewayRoute.gatewayRoute.spec.httpRoute.match.prefix', props);
    return resource.getResponseField('gatewayRoute.spec.httpRoute.match.prefix') as unknown as string;
  }

}

export class AppMeshCreateGatewayRouteGatewayRouteStatus extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateGatewayRouteInput) {
    super(scope, id);
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.status.status'),
        outputPath: 'gatewayRoute.status.status',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateGatewayRoute.gatewayRoute.status.status', props);
    return resource.getResponseField('gatewayRoute.status.status') as unknown as string;
  }

}

export class AppMeshCreateMesh extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateMeshInput) {
    super(scope, id);
  }

  public get mesh(): AppMeshCreateMeshMesh {
    return new AppMeshCreateMeshMesh(this, 'Mesh', this.__resources, this.input);
  }

}

export class AppMeshCreateMeshMesh extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateMeshInput) {
    super(scope, id);
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateMesh.mesh.meshName'),
        outputPath: 'mesh.meshName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          spec: {
            egressFilter: {
              type: this.input.spec?.egressFilter?.type,
            },
          },
          tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMesh.mesh.meshName', props);
    return resource.getResponseField('mesh.meshName') as unknown as string;
  }

  public get metadata(): AppMeshCreateMeshMeshMetadata {
    return new AppMeshCreateMeshMeshMetadata(this, 'Metadata', this.__resources, this.input);
  }

  public get spec(): AppMeshCreateMeshMeshSpec {
    return new AppMeshCreateMeshMeshSpec(this, 'Spec', this.__resources, this.input);
  }

  public get status(): AppMeshCreateMeshMeshStatus {
    return new AppMeshCreateMeshMeshStatus(this, 'Status', this.__resources, this.input);
  }

}

export class AppMeshCreateMeshMeshMetadata extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateMeshInput) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateMesh.mesh.metadata.arn'),
        outputPath: 'mesh.metadata.arn',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          spec: {
            egressFilter: {
              type: this.input.spec?.egressFilter?.type,
            },
          },
          tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMesh.mesh.metadata.arn', props);
    return resource.getResponseField('mesh.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateMesh.mesh.metadata.createdAt'),
        outputPath: 'mesh.metadata.createdAt',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          spec: {
            egressFilter: {
              type: this.input.spec?.egressFilter?.type,
            },
          },
          tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMesh.mesh.metadata.createdAt', props);
    return resource.getResponseField('mesh.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateMesh.mesh.metadata.lastUpdatedAt'),
        outputPath: 'mesh.metadata.lastUpdatedAt',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          spec: {
            egressFilter: {
              type: this.input.spec?.egressFilter?.type,
            },
          },
          tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMesh.mesh.metadata.lastUpdatedAt', props);
    return resource.getResponseField('mesh.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateMesh.mesh.metadata.meshOwner'),
        outputPath: 'mesh.metadata.meshOwner',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          spec: {
            egressFilter: {
              type: this.input.spec?.egressFilter?.type,
            },
          },
          tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMesh.mesh.metadata.meshOwner', props);
    return resource.getResponseField('mesh.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateMesh.mesh.metadata.resourceOwner'),
        outputPath: 'mesh.metadata.resourceOwner',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          spec: {
            egressFilter: {
              type: this.input.spec?.egressFilter?.type,
            },
          },
          tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMesh.mesh.metadata.resourceOwner', props);
    return resource.getResponseField('mesh.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateMesh.mesh.metadata.uid'),
        outputPath: 'mesh.metadata.uid',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          spec: {
            egressFilter: {
              type: this.input.spec?.egressFilter?.type,
            },
          },
          tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMesh.mesh.metadata.uid', props);
    return resource.getResponseField('mesh.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateMesh.mesh.metadata.version'),
        outputPath: 'mesh.metadata.version',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          spec: {
            egressFilter: {
              type: this.input.spec?.egressFilter?.type,
            },
          },
          tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMesh.mesh.metadata.version', props);
    return resource.getResponseField('mesh.metadata.version') as unknown as number;
  }

}

export class AppMeshCreateMeshMeshSpec extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateMeshInput) {
    super(scope, id);
  }

  public get egressFilter(): AppMeshCreateMeshMeshSpecEgressFilter {
    return new AppMeshCreateMeshMeshSpecEgressFilter(this, 'EgressFilter', this.__resources, this.input);
  }

}

export class AppMeshCreateMeshMeshSpecEgressFilter extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateMeshInput) {
    super(scope, id);
  }

  public get type(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateMesh.mesh.spec.egressFilter.type'),
        outputPath: 'mesh.spec.egressFilter.type',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          spec: {
            egressFilter: {
              type: this.input.spec?.egressFilter?.type,
            },
          },
          tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMesh.mesh.spec.egressFilter.type', props);
    return resource.getResponseField('mesh.spec.egressFilter.type') as unknown as string;
  }

}

export class AppMeshCreateMeshMeshStatus extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateMeshInput) {
    super(scope, id);
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateMesh.mesh.status.status'),
        outputPath: 'mesh.status.status',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          spec: {
            egressFilter: {
              type: this.input.spec?.egressFilter?.type,
            },
          },
          tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMesh.mesh.status.status', props);
    return resource.getResponseField('mesh.status.status') as unknown as string;
  }

}

export class AppMeshCreateRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get route(): AppMeshCreateRouteRoute {
    return new AppMeshCreateRouteRoute(this, 'Route', this.__resources, this.input);
  }

}

export class AppMeshCreateRouteRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.meshName'),
        outputPath: 'route.meshName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.meshName', props);
    return resource.getResponseField('route.meshName') as unknown as string;
  }

  public get metadata(): AppMeshCreateRouteRouteMetadata {
    return new AppMeshCreateRouteRouteMetadata(this, 'Metadata', this.__resources, this.input);
  }

  public get routeName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.routeName'),
        outputPath: 'route.routeName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.routeName', props);
    return resource.getResponseField('route.routeName') as unknown as string;
  }

  public get spec(): AppMeshCreateRouteRouteSpec {
    return new AppMeshCreateRouteRouteSpec(this, 'Spec', this.__resources, this.input);
  }

  public get status(): AppMeshCreateRouteRouteStatus {
    return new AppMeshCreateRouteRouteStatus(this, 'Status', this.__resources, this.input);
  }

  public get virtualRouterName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.virtualRouterName'),
        outputPath: 'route.virtualRouterName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.virtualRouterName', props);
    return resource.getResponseField('route.virtualRouterName') as unknown as string;
  }

}

export class AppMeshCreateRouteRouteMetadata extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.metadata.arn'),
        outputPath: 'route.metadata.arn',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.metadata.arn', props);
    return resource.getResponseField('route.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.metadata.createdAt'),
        outputPath: 'route.metadata.createdAt',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.metadata.createdAt', props);
    return resource.getResponseField('route.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.metadata.lastUpdatedAt'),
        outputPath: 'route.metadata.lastUpdatedAt',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.metadata.lastUpdatedAt', props);
    return resource.getResponseField('route.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.metadata.meshOwner'),
        outputPath: 'route.metadata.meshOwner',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.metadata.meshOwner', props);
    return resource.getResponseField('route.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.metadata.resourceOwner'),
        outputPath: 'route.metadata.resourceOwner',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.metadata.resourceOwner', props);
    return resource.getResponseField('route.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.metadata.uid'),
        outputPath: 'route.metadata.uid',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.metadata.uid', props);
    return resource.getResponseField('route.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.metadata.version'),
        outputPath: 'route.metadata.version',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.metadata.version', props);
    return resource.getResponseField('route.metadata.version') as unknown as number;
  }

}

export class AppMeshCreateRouteRouteSpec extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get grpcRoute(): AppMeshCreateRouteRouteSpecGrpcRoute {
    return new AppMeshCreateRouteRouteSpecGrpcRoute(this, 'GrpcRoute', this.__resources, this.input);
  }

  public get http2Route(): AppMeshCreateRouteRouteSpecHttp2Route {
    return new AppMeshCreateRouteRouteSpecHttp2Route(this, 'Http2Route', this.__resources, this.input);
  }

  public get httpRoute(): AppMeshCreateRouteRouteSpecHttpRoute {
    return new AppMeshCreateRouteRouteSpecHttpRoute(this, 'HttpRoute', this.__resources, this.input);
  }

  public get priority(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.priority'),
        outputPath: 'route.spec.priority',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.priority', props);
    return resource.getResponseField('route.spec.priority') as unknown as number;
  }

  public get tcpRoute(): AppMeshCreateRouteRouteSpecTcpRoute {
    return new AppMeshCreateRouteRouteSpecTcpRoute(this, 'TcpRoute', this.__resources, this.input);
  }

}

export class AppMeshCreateRouteRouteSpecGrpcRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get action(): AppMeshCreateRouteRouteSpecGrpcRouteAction {
    return new AppMeshCreateRouteRouteSpecGrpcRouteAction(this, 'Action', this.__resources, this.input);
  }

  public get match(): AppMeshCreateRouteRouteSpecGrpcRouteMatch {
    return new AppMeshCreateRouteRouteSpecGrpcRouteMatch(this, 'Match', this.__resources, this.input);
  }

  public get retryPolicy(): AppMeshCreateRouteRouteSpecGrpcRouteRetryPolicy {
    return new AppMeshCreateRouteRouteSpecGrpcRouteRetryPolicy(this, 'RetryPolicy', this.__resources, this.input);
  }

  public get timeout(): AppMeshCreateRouteRouteSpecGrpcRouteTimeout {
    return new AppMeshCreateRouteRouteSpecGrpcRouteTimeout(this, 'Timeout', this.__resources, this.input);
  }

}

export class AppMeshCreateRouteRouteSpecGrpcRouteAction extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.grpcRoute.action.weightedTargets'),
        outputPath: 'route.spec.grpcRoute.action.weightedTargets',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.grpcRoute.action.weightedTargets', props);
    return resource.getResponseField('route.spec.grpcRoute.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshCreateRouteRouteSpecGrpcRouteMatch extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get metadata(): shapes.AppMeshGrpcRouteMetadata[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.grpcRoute.match.metadata'),
        outputPath: 'route.spec.grpcRoute.match.metadata',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.grpcRoute.match.metadata', props);
    return resource.getResponseField('route.spec.grpcRoute.match.metadata') as unknown as shapes.AppMeshGrpcRouteMetadata[];
  }

  public get methodName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.grpcRoute.match.methodName'),
        outputPath: 'route.spec.grpcRoute.match.methodName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.grpcRoute.match.methodName', props);
    return resource.getResponseField('route.spec.grpcRoute.match.methodName') as unknown as string;
  }

  public get serviceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.grpcRoute.match.serviceName'),
        outputPath: 'route.spec.grpcRoute.match.serviceName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.grpcRoute.match.serviceName', props);
    return resource.getResponseField('route.spec.grpcRoute.match.serviceName') as unknown as string;
  }

}

export class AppMeshCreateRouteRouteSpecGrpcRouteRetryPolicy extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get grpcRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.grpcRoute.retryPolicy.grpcRetryEvents'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.grpcRetryEvents',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.grpcRoute.retryPolicy.grpcRetryEvents', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.grpcRetryEvents') as unknown as string[];
  }

  public get httpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.grpcRoute.retryPolicy.httpRetryEvents'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.httpRetryEvents',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.grpcRoute.retryPolicy.httpRetryEvents', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.httpRetryEvents') as unknown as string[];
  }

  public get maxRetries(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.grpcRoute.retryPolicy.maxRetries'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.maxRetries',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.grpcRoute.retryPolicy.maxRetries', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.maxRetries') as unknown as number;
  }

  public get perRetryTimeout(): AppMeshCreateRouteRouteSpecGrpcRouteRetryPolicyPerRetryTimeout {
    return new AppMeshCreateRouteRouteSpecGrpcRouteRetryPolicyPerRetryTimeout(this, 'PerRetryTimeout', this.__resources, this.input);
  }

  public get tcpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.grpcRoute.retryPolicy.tcpRetryEvents'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.tcpRetryEvents',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.grpcRoute.retryPolicy.tcpRetryEvents', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.tcpRetryEvents') as unknown as string[];
  }

}

export class AppMeshCreateRouteRouteSpecGrpcRouteRetryPolicyPerRetryTimeout extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.value'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.perRetryTimeout.value',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.value', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.perRetryTimeout.value') as unknown as number;
  }

}

export class AppMeshCreateRouteRouteSpecGrpcRouteTimeout extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get idle(): AppMeshCreateRouteRouteSpecGrpcRouteTimeoutIdle {
    return new AppMeshCreateRouteRouteSpecGrpcRouteTimeoutIdle(this, 'Idle', this.__resources, this.input);
  }

  public get perRequest(): AppMeshCreateRouteRouteSpecGrpcRouteTimeoutPerRequest {
    return new AppMeshCreateRouteRouteSpecGrpcRouteTimeoutPerRequest(this, 'PerRequest', this.__resources, this.input);
  }

}

export class AppMeshCreateRouteRouteSpecGrpcRouteTimeoutIdle extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.grpcRoute.timeout.idle.unit'),
        outputPath: 'route.spec.grpcRoute.timeout.idle.unit',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.grpcRoute.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.grpcRoute.timeout.idle.value'),
        outputPath: 'route.spec.grpcRoute.timeout.idle.value',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.grpcRoute.timeout.idle.value', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshCreateRouteRouteSpecGrpcRouteTimeoutPerRequest extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.grpcRoute.timeout.perRequest.unit'),
        outputPath: 'route.spec.grpcRoute.timeout.perRequest.unit',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.grpcRoute.timeout.perRequest.unit', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.perRequest.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.grpcRoute.timeout.perRequest.value'),
        outputPath: 'route.spec.grpcRoute.timeout.perRequest.value',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.grpcRoute.timeout.perRequest.value', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.perRequest.value') as unknown as number;
  }

}

export class AppMeshCreateRouteRouteSpecHttp2Route extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get action(): AppMeshCreateRouteRouteSpecHttp2RouteAction {
    return new AppMeshCreateRouteRouteSpecHttp2RouteAction(this, 'Action', this.__resources, this.input);
  }

  public get match(): AppMeshCreateRouteRouteSpecHttp2RouteMatch {
    return new AppMeshCreateRouteRouteSpecHttp2RouteMatch(this, 'Match', this.__resources, this.input);
  }

  public get retryPolicy(): AppMeshCreateRouteRouteSpecHttp2RouteRetryPolicy {
    return new AppMeshCreateRouteRouteSpecHttp2RouteRetryPolicy(this, 'RetryPolicy', this.__resources, this.input);
  }

  public get timeout(): AppMeshCreateRouteRouteSpecHttp2RouteTimeout {
    return new AppMeshCreateRouteRouteSpecHttp2RouteTimeout(this, 'Timeout', this.__resources, this.input);
  }

}

export class AppMeshCreateRouteRouteSpecHttp2RouteAction extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.http2Route.action.weightedTargets'),
        outputPath: 'route.spec.http2Route.action.weightedTargets',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.http2Route.action.weightedTargets', props);
    return resource.getResponseField('route.spec.http2Route.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshCreateRouteRouteSpecHttp2RouteMatch extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get headers(): shapes.AppMeshHttpRouteHeader[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.http2Route.match.headers'),
        outputPath: 'route.spec.http2Route.match.headers',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.http2Route.match.headers', props);
    return resource.getResponseField('route.spec.http2Route.match.headers') as unknown as shapes.AppMeshHttpRouteHeader[];
  }

  public get method(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.http2Route.match.method'),
        outputPath: 'route.spec.http2Route.match.method',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.http2Route.match.method', props);
    return resource.getResponseField('route.spec.http2Route.match.method') as unknown as string;
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.http2Route.match.prefix'),
        outputPath: 'route.spec.http2Route.match.prefix',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.http2Route.match.prefix', props);
    return resource.getResponseField('route.spec.http2Route.match.prefix') as unknown as string;
  }

  public get scheme(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.http2Route.match.scheme'),
        outputPath: 'route.spec.http2Route.match.scheme',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.http2Route.match.scheme', props);
    return resource.getResponseField('route.spec.http2Route.match.scheme') as unknown as string;
  }

}

export class AppMeshCreateRouteRouteSpecHttp2RouteRetryPolicy extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get httpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.http2Route.retryPolicy.httpRetryEvents'),
        outputPath: 'route.spec.http2Route.retryPolicy.httpRetryEvents',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.http2Route.retryPolicy.httpRetryEvents', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.httpRetryEvents') as unknown as string[];
  }

  public get maxRetries(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.http2Route.retryPolicy.maxRetries'),
        outputPath: 'route.spec.http2Route.retryPolicy.maxRetries',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.http2Route.retryPolicy.maxRetries', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.maxRetries') as unknown as number;
  }

  public get perRetryTimeout(): AppMeshCreateRouteRouteSpecHttp2RouteRetryPolicyPerRetryTimeout {
    return new AppMeshCreateRouteRouteSpecHttp2RouteRetryPolicyPerRetryTimeout(this, 'PerRetryTimeout', this.__resources, this.input);
  }

  public get tcpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.http2Route.retryPolicy.tcpRetryEvents'),
        outputPath: 'route.spec.http2Route.retryPolicy.tcpRetryEvents',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.http2Route.retryPolicy.tcpRetryEvents', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.tcpRetryEvents') as unknown as string[];
  }

}

export class AppMeshCreateRouteRouteSpecHttp2RouteRetryPolicyPerRetryTimeout extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.unit'),
        outputPath: 'route.spec.http2Route.retryPolicy.perRetryTimeout.unit',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.unit', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.perRetryTimeout.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.value'),
        outputPath: 'route.spec.http2Route.retryPolicy.perRetryTimeout.value',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.value', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.perRetryTimeout.value') as unknown as number;
  }

}

export class AppMeshCreateRouteRouteSpecHttp2RouteTimeout extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get idle(): AppMeshCreateRouteRouteSpecHttp2RouteTimeoutIdle {
    return new AppMeshCreateRouteRouteSpecHttp2RouteTimeoutIdle(this, 'Idle', this.__resources, this.input);
  }

  public get perRequest(): AppMeshCreateRouteRouteSpecHttp2RouteTimeoutPerRequest {
    return new AppMeshCreateRouteRouteSpecHttp2RouteTimeoutPerRequest(this, 'PerRequest', this.__resources, this.input);
  }

}

export class AppMeshCreateRouteRouteSpecHttp2RouteTimeoutIdle extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.http2Route.timeout.idle.unit'),
        outputPath: 'route.spec.http2Route.timeout.idle.unit',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.http2Route.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.http2Route.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.http2Route.timeout.idle.value'),
        outputPath: 'route.spec.http2Route.timeout.idle.value',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.http2Route.timeout.idle.value', props);
    return resource.getResponseField('route.spec.http2Route.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshCreateRouteRouteSpecHttp2RouteTimeoutPerRequest extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.http2Route.timeout.perRequest.unit'),
        outputPath: 'route.spec.http2Route.timeout.perRequest.unit',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.http2Route.timeout.perRequest.unit', props);
    return resource.getResponseField('route.spec.http2Route.timeout.perRequest.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.http2Route.timeout.perRequest.value'),
        outputPath: 'route.spec.http2Route.timeout.perRequest.value',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.http2Route.timeout.perRequest.value', props);
    return resource.getResponseField('route.spec.http2Route.timeout.perRequest.value') as unknown as number;
  }

}

export class AppMeshCreateRouteRouteSpecHttpRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get action(): AppMeshCreateRouteRouteSpecHttpRouteAction {
    return new AppMeshCreateRouteRouteSpecHttpRouteAction(this, 'Action', this.__resources, this.input);
  }

  public get match(): AppMeshCreateRouteRouteSpecHttpRouteMatch {
    return new AppMeshCreateRouteRouteSpecHttpRouteMatch(this, 'Match', this.__resources, this.input);
  }

  public get retryPolicy(): AppMeshCreateRouteRouteSpecHttpRouteRetryPolicy {
    return new AppMeshCreateRouteRouteSpecHttpRouteRetryPolicy(this, 'RetryPolicy', this.__resources, this.input);
  }

  public get timeout(): AppMeshCreateRouteRouteSpecHttpRouteTimeout {
    return new AppMeshCreateRouteRouteSpecHttpRouteTimeout(this, 'Timeout', this.__resources, this.input);
  }

}

export class AppMeshCreateRouteRouteSpecHttpRouteAction extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.httpRoute.action.weightedTargets'),
        outputPath: 'route.spec.httpRoute.action.weightedTargets',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.httpRoute.action.weightedTargets', props);
    return resource.getResponseField('route.spec.httpRoute.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshCreateRouteRouteSpecHttpRouteMatch extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get headers(): shapes.AppMeshHttpRouteHeader[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.httpRoute.match.headers'),
        outputPath: 'route.spec.httpRoute.match.headers',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.httpRoute.match.headers', props);
    return resource.getResponseField('route.spec.httpRoute.match.headers') as unknown as shapes.AppMeshHttpRouteHeader[];
  }

  public get method(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.httpRoute.match.method'),
        outputPath: 'route.spec.httpRoute.match.method',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.httpRoute.match.method', props);
    return resource.getResponseField('route.spec.httpRoute.match.method') as unknown as string;
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.httpRoute.match.prefix'),
        outputPath: 'route.spec.httpRoute.match.prefix',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.httpRoute.match.prefix', props);
    return resource.getResponseField('route.spec.httpRoute.match.prefix') as unknown as string;
  }

  public get scheme(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.httpRoute.match.scheme'),
        outputPath: 'route.spec.httpRoute.match.scheme',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.httpRoute.match.scheme', props);
    return resource.getResponseField('route.spec.httpRoute.match.scheme') as unknown as string;
  }

}

export class AppMeshCreateRouteRouteSpecHttpRouteRetryPolicy extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get httpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.httpRoute.retryPolicy.httpRetryEvents'),
        outputPath: 'route.spec.httpRoute.retryPolicy.httpRetryEvents',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.httpRoute.retryPolicy.httpRetryEvents', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.httpRetryEvents') as unknown as string[];
  }

  public get maxRetries(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.httpRoute.retryPolicy.maxRetries'),
        outputPath: 'route.spec.httpRoute.retryPolicy.maxRetries',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.httpRoute.retryPolicy.maxRetries', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.maxRetries') as unknown as number;
  }

  public get perRetryTimeout(): AppMeshCreateRouteRouteSpecHttpRouteRetryPolicyPerRetryTimeout {
    return new AppMeshCreateRouteRouteSpecHttpRouteRetryPolicyPerRetryTimeout(this, 'PerRetryTimeout', this.__resources, this.input);
  }

  public get tcpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.httpRoute.retryPolicy.tcpRetryEvents'),
        outputPath: 'route.spec.httpRoute.retryPolicy.tcpRetryEvents',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.httpRoute.retryPolicy.tcpRetryEvents', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.tcpRetryEvents') as unknown as string[];
  }

}

export class AppMeshCreateRouteRouteSpecHttpRouteRetryPolicyPerRetryTimeout extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.unit'),
        outputPath: 'route.spec.httpRoute.retryPolicy.perRetryTimeout.unit',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.unit', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.perRetryTimeout.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.value'),
        outputPath: 'route.spec.httpRoute.retryPolicy.perRetryTimeout.value',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.value', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.perRetryTimeout.value') as unknown as number;
  }

}

export class AppMeshCreateRouteRouteSpecHttpRouteTimeout extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get idle(): AppMeshCreateRouteRouteSpecHttpRouteTimeoutIdle {
    return new AppMeshCreateRouteRouteSpecHttpRouteTimeoutIdle(this, 'Idle', this.__resources, this.input);
  }

  public get perRequest(): AppMeshCreateRouteRouteSpecHttpRouteTimeoutPerRequest {
    return new AppMeshCreateRouteRouteSpecHttpRouteTimeoutPerRequest(this, 'PerRequest', this.__resources, this.input);
  }

}

export class AppMeshCreateRouteRouteSpecHttpRouteTimeoutIdle extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.httpRoute.timeout.idle.unit'),
        outputPath: 'route.spec.httpRoute.timeout.idle.unit',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.httpRoute.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.httpRoute.timeout.idle.value'),
        outputPath: 'route.spec.httpRoute.timeout.idle.value',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.httpRoute.timeout.idle.value', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshCreateRouteRouteSpecHttpRouteTimeoutPerRequest extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.httpRoute.timeout.perRequest.unit'),
        outputPath: 'route.spec.httpRoute.timeout.perRequest.unit',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.httpRoute.timeout.perRequest.unit', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.perRequest.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.httpRoute.timeout.perRequest.value'),
        outputPath: 'route.spec.httpRoute.timeout.perRequest.value',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.httpRoute.timeout.perRequest.value', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.perRequest.value') as unknown as number;
  }

}

export class AppMeshCreateRouteRouteSpecTcpRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get action(): AppMeshCreateRouteRouteSpecTcpRouteAction {
    return new AppMeshCreateRouteRouteSpecTcpRouteAction(this, 'Action', this.__resources, this.input);
  }

  public get timeout(): AppMeshCreateRouteRouteSpecTcpRouteTimeout {
    return new AppMeshCreateRouteRouteSpecTcpRouteTimeout(this, 'Timeout', this.__resources, this.input);
  }

}

export class AppMeshCreateRouteRouteSpecTcpRouteAction extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.tcpRoute.action.weightedTargets'),
        outputPath: 'route.spec.tcpRoute.action.weightedTargets',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.tcpRoute.action.weightedTargets', props);
    return resource.getResponseField('route.spec.tcpRoute.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshCreateRouteRouteSpecTcpRouteTimeout extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get idle(): AppMeshCreateRouteRouteSpecTcpRouteTimeoutIdle {
    return new AppMeshCreateRouteRouteSpecTcpRouteTimeoutIdle(this, 'Idle', this.__resources, this.input);
  }

}

export class AppMeshCreateRouteRouteSpecTcpRouteTimeoutIdle extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.tcpRoute.timeout.idle.unit'),
        outputPath: 'route.spec.tcpRoute.timeout.idle.unit',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.tcpRoute.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.tcpRoute.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.tcpRoute.timeout.idle.value'),
        outputPath: 'route.spec.tcpRoute.timeout.idle.value',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.spec.tcpRoute.timeout.idle.value', props);
    return resource.getResponseField('route.spec.tcpRoute.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshCreateRouteRouteStatus extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateRouteInput) {
    super(scope, id);
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.status.status'),
        outputPath: 'route.status.status',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateRoute.route.status.status', props);
    return resource.getResponseField('route.status.status') as unknown as string;
  }

}

export class AppMeshCreateVirtualGateway extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualGatewayInput) {
    super(scope, id);
  }

  public get virtualGateway(): AppMeshCreateVirtualGatewayVirtualGateway {
    return new AppMeshCreateVirtualGatewayVirtualGateway(this, 'VirtualGateway', this.__resources, this.input);
  }

}

export class AppMeshCreateVirtualGatewayVirtualGateway extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualGatewayInput) {
    super(scope, id);
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.meshName'),
        outputPath: 'virtualGateway.meshName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualGateway.virtualGateway.meshName', props);
    return resource.getResponseField('virtualGateway.meshName') as unknown as string;
  }

  public get metadata(): AppMeshCreateVirtualGatewayVirtualGatewayMetadata {
    return new AppMeshCreateVirtualGatewayVirtualGatewayMetadata(this, 'Metadata', this.__resources, this.input);
  }

  public get spec(): AppMeshCreateVirtualGatewayVirtualGatewaySpec {
    return new AppMeshCreateVirtualGatewayVirtualGatewaySpec(this, 'Spec', this.__resources, this.input);
  }

  public get status(): AppMeshCreateVirtualGatewayVirtualGatewayStatus {
    return new AppMeshCreateVirtualGatewayVirtualGatewayStatus(this, 'Status', this.__resources, this.input);
  }

  public get virtualGatewayName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.virtualGatewayName'),
        outputPath: 'virtualGateway.virtualGatewayName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualGateway.virtualGateway.virtualGatewayName', props);
    return resource.getResponseField('virtualGateway.virtualGatewayName') as unknown as string;
  }

}

export class AppMeshCreateVirtualGatewayVirtualGatewayMetadata extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualGatewayInput) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.metadata.arn'),
        outputPath: 'virtualGateway.metadata.arn',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualGateway.virtualGateway.metadata.arn', props);
    return resource.getResponseField('virtualGateway.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.metadata.createdAt'),
        outputPath: 'virtualGateway.metadata.createdAt',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualGateway.virtualGateway.metadata.createdAt', props);
    return resource.getResponseField('virtualGateway.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.metadata.lastUpdatedAt'),
        outputPath: 'virtualGateway.metadata.lastUpdatedAt',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualGateway.virtualGateway.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualGateway.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.metadata.meshOwner'),
        outputPath: 'virtualGateway.metadata.meshOwner',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualGateway.virtualGateway.metadata.meshOwner', props);
    return resource.getResponseField('virtualGateway.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.metadata.resourceOwner'),
        outputPath: 'virtualGateway.metadata.resourceOwner',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualGateway.virtualGateway.metadata.resourceOwner', props);
    return resource.getResponseField('virtualGateway.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.metadata.uid'),
        outputPath: 'virtualGateway.metadata.uid',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualGateway.virtualGateway.metadata.uid', props);
    return resource.getResponseField('virtualGateway.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.metadata.version'),
        outputPath: 'virtualGateway.metadata.version',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualGateway.virtualGateway.metadata.version', props);
    return resource.getResponseField('virtualGateway.metadata.version') as unknown as number;
  }

}

export class AppMeshCreateVirtualGatewayVirtualGatewaySpec extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualGatewayInput) {
    super(scope, id);
  }

  public get backendDefaults(): AppMeshCreateVirtualGatewayVirtualGatewaySpecBackendDefaults {
    return new AppMeshCreateVirtualGatewayVirtualGatewaySpecBackendDefaults(this, 'BackendDefaults', this.__resources, this.input);
  }

  public get listeners(): shapes.AppMeshVirtualGatewayListener[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.spec.listeners'),
        outputPath: 'virtualGateway.spec.listeners',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualGateway.virtualGateway.spec.listeners', props);
    return resource.getResponseField('virtualGateway.spec.listeners') as unknown as shapes.AppMeshVirtualGatewayListener[];
  }

  public get logging(): AppMeshCreateVirtualGatewayVirtualGatewaySpecLogging {
    return new AppMeshCreateVirtualGatewayVirtualGatewaySpecLogging(this, 'Logging', this.__resources, this.input);
  }

}

export class AppMeshCreateVirtualGatewayVirtualGatewaySpecBackendDefaults extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualGatewayInput) {
    super(scope, id);
  }

  public get clientPolicy(): AppMeshCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicy {
    return new AppMeshCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicy(this, 'ClientPolicy', this.__resources, this.input);
  }

}

export class AppMeshCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicy extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualGatewayInput) {
    super(scope, id);
  }

  public get tls(): AppMeshCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTls {
    return new AppMeshCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTls(this, 'Tls', this.__resources, this.input);
  }

}

export class AppMeshCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTls extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualGatewayInput) {
    super(scope, id);
  }

  public get enforce(): boolean {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce') as unknown as boolean;
  }

  public get ports(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.ports'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.ports',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.ports', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.ports') as unknown as number[];
  }

  public get validation(): AppMeshCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation {
    return new AppMeshCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation(this, 'Validation', this.__resources, this.input);
  }

}

export class AppMeshCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualGatewayInput) {
    super(scope, id);
  }

  public get trust(): AppMeshCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust {
    return new AppMeshCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust(this, 'Trust', this.__resources, this.input);
  }

}

export class AppMeshCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualGatewayInput) {
    super(scope, id);
  }

  public get acm(): AppMeshCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
    return new AppMeshCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm(this, 'Acm', this.__resources, this.input);
  }

  public get file(): AppMeshCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile {
    return new AppMeshCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile(this, 'File', this.__resources, this.input);
  }

}

export class AppMeshCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualGatewayInput) {
    super(scope, id);
  }

  public get certificateAuthorityArns(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns') as unknown as string[];
  }

}

export class AppMeshCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualGatewayInput) {
    super(scope, id);
  }

  public get certificateChain(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain') as unknown as string;
  }

}

export class AppMeshCreateVirtualGatewayVirtualGatewaySpecLogging extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualGatewayInput) {
    super(scope, id);
  }

  public get accessLog(): AppMeshCreateVirtualGatewayVirtualGatewaySpecLoggingAccessLog {
    return new AppMeshCreateVirtualGatewayVirtualGatewaySpecLoggingAccessLog(this, 'AccessLog', this.__resources, this.input);
  }

}

export class AppMeshCreateVirtualGatewayVirtualGatewaySpecLoggingAccessLog extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualGatewayInput) {
    super(scope, id);
  }

  public get file(): AppMeshCreateVirtualGatewayVirtualGatewaySpecLoggingAccessLogFile {
    return new AppMeshCreateVirtualGatewayVirtualGatewaySpecLoggingAccessLogFile(this, 'File', this.__resources, this.input);
  }

}

export class AppMeshCreateVirtualGatewayVirtualGatewaySpecLoggingAccessLogFile extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualGatewayInput) {
    super(scope, id);
  }

  public get path(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.spec.logging.accessLog.file.path'),
        outputPath: 'virtualGateway.spec.logging.accessLog.file.path',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualGateway.virtualGateway.spec.logging.accessLog.file.path', props);
    return resource.getResponseField('virtualGateway.spec.logging.accessLog.file.path') as unknown as string;
  }

}

export class AppMeshCreateVirtualGatewayVirtualGatewayStatus extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualGatewayInput) {
    super(scope, id);
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.status.status'),
        outputPath: 'virtualGateway.status.status',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.input.tags,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualGateway.virtualGateway.status.status', props);
    return resource.getResponseField('virtualGateway.status.status') as unknown as string;
  }

}

export class AppMeshCreateVirtualNode extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualNodeInput) {
    super(scope, id);
  }

  public get virtualNode(): AppMeshCreateVirtualNodeVirtualNode {
    return new AppMeshCreateVirtualNodeVirtualNode(this, 'VirtualNode', this.__resources, this.input);
  }

}

export class AppMeshCreateVirtualNodeVirtualNode extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualNodeInput) {
    super(scope, id);
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.meshName'),
        outputPath: 'virtualNode.meshName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.input.tags,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualNode.virtualNode.meshName', props);
    return resource.getResponseField('virtualNode.meshName') as unknown as string;
  }

  public get metadata(): AppMeshCreateVirtualNodeVirtualNodeMetadata {
    return new AppMeshCreateVirtualNodeVirtualNodeMetadata(this, 'Metadata', this.__resources, this.input);
  }

  public get spec(): AppMeshCreateVirtualNodeVirtualNodeSpec {
    return new AppMeshCreateVirtualNodeVirtualNodeSpec(this, 'Spec', this.__resources, this.input);
  }

  public get status(): AppMeshCreateVirtualNodeVirtualNodeStatus {
    return new AppMeshCreateVirtualNodeVirtualNodeStatus(this, 'Status', this.__resources, this.input);
  }

  public get virtualNodeName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.virtualNodeName'),
        outputPath: 'virtualNode.virtualNodeName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.input.tags,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualNode.virtualNode.virtualNodeName', props);
    return resource.getResponseField('virtualNode.virtualNodeName') as unknown as string;
  }

}

export class AppMeshCreateVirtualNodeVirtualNodeMetadata extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualNodeInput) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.metadata.arn'),
        outputPath: 'virtualNode.metadata.arn',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.input.tags,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualNode.virtualNode.metadata.arn', props);
    return resource.getResponseField('virtualNode.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.metadata.createdAt'),
        outputPath: 'virtualNode.metadata.createdAt',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.input.tags,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualNode.virtualNode.metadata.createdAt', props);
    return resource.getResponseField('virtualNode.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.metadata.lastUpdatedAt'),
        outputPath: 'virtualNode.metadata.lastUpdatedAt',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.input.tags,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualNode.virtualNode.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualNode.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.metadata.meshOwner'),
        outputPath: 'virtualNode.metadata.meshOwner',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.input.tags,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualNode.virtualNode.metadata.meshOwner', props);
    return resource.getResponseField('virtualNode.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.metadata.resourceOwner'),
        outputPath: 'virtualNode.metadata.resourceOwner',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.input.tags,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualNode.virtualNode.metadata.resourceOwner', props);
    return resource.getResponseField('virtualNode.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.metadata.uid'),
        outputPath: 'virtualNode.metadata.uid',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.input.tags,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualNode.virtualNode.metadata.uid', props);
    return resource.getResponseField('virtualNode.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.metadata.version'),
        outputPath: 'virtualNode.metadata.version',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.input.tags,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualNode.virtualNode.metadata.version', props);
    return resource.getResponseField('virtualNode.metadata.version') as unknown as number;
  }

}

export class AppMeshCreateVirtualNodeVirtualNodeSpec extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualNodeInput) {
    super(scope, id);
  }

  public get backendDefaults(): AppMeshCreateVirtualNodeVirtualNodeSpecBackendDefaults {
    return new AppMeshCreateVirtualNodeVirtualNodeSpecBackendDefaults(this, 'BackendDefaults', this.__resources, this.input);
  }

  public get backends(): shapes.AppMeshBackend[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.spec.backends'),
        outputPath: 'virtualNode.spec.backends',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.input.tags,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualNode.virtualNode.spec.backends', props);
    return resource.getResponseField('virtualNode.spec.backends') as unknown as shapes.AppMeshBackend[];
  }

  public get listeners(): shapes.AppMeshListener[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.spec.listeners'),
        outputPath: 'virtualNode.spec.listeners',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.input.tags,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualNode.virtualNode.spec.listeners', props);
    return resource.getResponseField('virtualNode.spec.listeners') as unknown as shapes.AppMeshListener[];
  }

  public get logging(): AppMeshCreateVirtualNodeVirtualNodeSpecLogging {
    return new AppMeshCreateVirtualNodeVirtualNodeSpecLogging(this, 'Logging', this.__resources, this.input);
  }

  public get serviceDiscovery(): AppMeshCreateVirtualNodeVirtualNodeSpecServiceDiscovery {
    return new AppMeshCreateVirtualNodeVirtualNodeSpecServiceDiscovery(this, 'ServiceDiscovery', this.__resources, this.input);
  }

}

export class AppMeshCreateVirtualNodeVirtualNodeSpecBackendDefaults extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualNodeInput) {
    super(scope, id);
  }

  public get clientPolicy(): AppMeshCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicy {
    return new AppMeshCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicy(this, 'ClientPolicy', this.__resources, this.input);
  }

}

export class AppMeshCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicy extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualNodeInput) {
    super(scope, id);
  }

  public get tls(): AppMeshCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTls {
    return new AppMeshCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTls(this, 'Tls', this.__resources, this.input);
  }

}

export class AppMeshCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTls extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualNodeInput) {
    super(scope, id);
  }

  public get enforce(): boolean {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.enforce'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.enforce',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.input.tags,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.enforce', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.enforce') as unknown as boolean;
  }

  public get ports(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.ports'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.ports',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.input.tags,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.ports', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.ports') as unknown as number[];
  }

  public get validation(): AppMeshCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidation {
    return new AppMeshCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidation(this, 'Validation', this.__resources, this.input);
  }

}

export class AppMeshCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidation extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualNodeInput) {
    super(scope, id);
  }

  public get trust(): AppMeshCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust {
    return new AppMeshCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust(this, 'Trust', this.__resources, this.input);
  }

}

export class AppMeshCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualNodeInput) {
    super(scope, id);
  }

  public get acm(): AppMeshCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
    return new AppMeshCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm(this, 'Acm', this.__resources, this.input);
  }

  public get file(): AppMeshCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile {
    return new AppMeshCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile(this, 'File', this.__resources, this.input);
  }

}

export class AppMeshCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualNodeInput) {
    super(scope, id);
  }

  public get certificateAuthorityArns(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.input.tags,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns') as unknown as string[];
  }

}

export class AppMeshCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualNodeInput) {
    super(scope, id);
  }

  public get certificateChain(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.input.tags,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain') as unknown as string;
  }

}

export class AppMeshCreateVirtualNodeVirtualNodeSpecLogging extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualNodeInput) {
    super(scope, id);
  }

  public get accessLog(): AppMeshCreateVirtualNodeVirtualNodeSpecLoggingAccessLog {
    return new AppMeshCreateVirtualNodeVirtualNodeSpecLoggingAccessLog(this, 'AccessLog', this.__resources, this.input);
  }

}

export class AppMeshCreateVirtualNodeVirtualNodeSpecLoggingAccessLog extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualNodeInput) {
    super(scope, id);
  }

  public get file(): AppMeshCreateVirtualNodeVirtualNodeSpecLoggingAccessLogFile {
    return new AppMeshCreateVirtualNodeVirtualNodeSpecLoggingAccessLogFile(this, 'File', this.__resources, this.input);
  }

}

export class AppMeshCreateVirtualNodeVirtualNodeSpecLoggingAccessLogFile extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualNodeInput) {
    super(scope, id);
  }

  public get path(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.spec.logging.accessLog.file.path'),
        outputPath: 'virtualNode.spec.logging.accessLog.file.path',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.input.tags,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualNode.virtualNode.spec.logging.accessLog.file.path', props);
    return resource.getResponseField('virtualNode.spec.logging.accessLog.file.path') as unknown as string;
  }

}

export class AppMeshCreateVirtualNodeVirtualNodeSpecServiceDiscovery extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualNodeInput) {
    super(scope, id);
  }

  public get awsCloudMap(): AppMeshCreateVirtualNodeVirtualNodeSpecServiceDiscoveryAwsCloudMap {
    return new AppMeshCreateVirtualNodeVirtualNodeSpecServiceDiscoveryAwsCloudMap(this, 'AwsCloudMap', this.__resources, this.input);
  }

  public get dns(): AppMeshCreateVirtualNodeVirtualNodeSpecServiceDiscoveryDns {
    return new AppMeshCreateVirtualNodeVirtualNodeSpecServiceDiscoveryDns(this, 'Dns', this.__resources, this.input);
  }

}

export class AppMeshCreateVirtualNodeVirtualNodeSpecServiceDiscoveryAwsCloudMap extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualNodeInput) {
    super(scope, id);
  }

  public get attributes(): shapes.AppMeshAwsCloudMapInstanceAttribute[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.attributes'),
        outputPath: 'virtualNode.spec.serviceDiscovery.awsCloudMap.attributes',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.input.tags,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.attributes', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.awsCloudMap.attributes') as unknown as shapes.AppMeshAwsCloudMapInstanceAttribute[];
  }

  public get namespaceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName'),
        outputPath: 'virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.input.tags,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName') as unknown as string;
  }

  public get serviceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName'),
        outputPath: 'virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.input.tags,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName') as unknown as string;
  }

}

export class AppMeshCreateVirtualNodeVirtualNodeSpecServiceDiscoveryDns extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualNodeInput) {
    super(scope, id);
  }

  public get hostname(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.spec.serviceDiscovery.dns.hostname'),
        outputPath: 'virtualNode.spec.serviceDiscovery.dns.hostname',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.input.tags,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualNode.virtualNode.spec.serviceDiscovery.dns.hostname', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.dns.hostname') as unknown as string;
  }

}

export class AppMeshCreateVirtualNodeVirtualNodeStatus extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualNodeInput) {
    super(scope, id);
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.status.status'),
        outputPath: 'virtualNode.status.status',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.input.tags,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualNode.virtualNode.status.status', props);
    return resource.getResponseField('virtualNode.status.status') as unknown as string;
  }

}

export class AppMeshCreateVirtualRouter extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualRouterInput) {
    super(scope, id);
  }

  public get virtualRouter(): AppMeshCreateVirtualRouterVirtualRouter {
    return new AppMeshCreateVirtualRouterVirtualRouter(this, 'VirtualRouter', this.__resources, this.input);
  }

}

export class AppMeshCreateVirtualRouterVirtualRouter extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualRouterInput) {
    super(scope, id);
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualRouter.virtualRouter.meshName'),
        outputPath: 'virtualRouter.meshName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            listeners: this.input.spec.listeners,
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualRouter.virtualRouter.meshName', props);
    return resource.getResponseField('virtualRouter.meshName') as unknown as string;
  }

  public get metadata(): AppMeshCreateVirtualRouterVirtualRouterMetadata {
    return new AppMeshCreateVirtualRouterVirtualRouterMetadata(this, 'Metadata', this.__resources, this.input);
  }

  public get spec(): AppMeshCreateVirtualRouterVirtualRouterSpec {
    return new AppMeshCreateVirtualRouterVirtualRouterSpec(this, 'Spec', this.__resources, this.input);
  }

  public get status(): AppMeshCreateVirtualRouterVirtualRouterStatus {
    return new AppMeshCreateVirtualRouterVirtualRouterStatus(this, 'Status', this.__resources, this.input);
  }

  public get virtualRouterName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualRouter.virtualRouter.virtualRouterName'),
        outputPath: 'virtualRouter.virtualRouterName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            listeners: this.input.spec.listeners,
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualRouter.virtualRouter.virtualRouterName', props);
    return resource.getResponseField('virtualRouter.virtualRouterName') as unknown as string;
  }

}

export class AppMeshCreateVirtualRouterVirtualRouterMetadata extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualRouterInput) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualRouter.virtualRouter.metadata.arn'),
        outputPath: 'virtualRouter.metadata.arn',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            listeners: this.input.spec.listeners,
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualRouter.virtualRouter.metadata.arn', props);
    return resource.getResponseField('virtualRouter.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualRouter.virtualRouter.metadata.createdAt'),
        outputPath: 'virtualRouter.metadata.createdAt',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            listeners: this.input.spec.listeners,
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualRouter.virtualRouter.metadata.createdAt', props);
    return resource.getResponseField('virtualRouter.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualRouter.virtualRouter.metadata.lastUpdatedAt'),
        outputPath: 'virtualRouter.metadata.lastUpdatedAt',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            listeners: this.input.spec.listeners,
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualRouter.virtualRouter.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualRouter.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualRouter.virtualRouter.metadata.meshOwner'),
        outputPath: 'virtualRouter.metadata.meshOwner',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            listeners: this.input.spec.listeners,
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualRouter.virtualRouter.metadata.meshOwner', props);
    return resource.getResponseField('virtualRouter.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualRouter.virtualRouter.metadata.resourceOwner'),
        outputPath: 'virtualRouter.metadata.resourceOwner',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            listeners: this.input.spec.listeners,
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualRouter.virtualRouter.metadata.resourceOwner', props);
    return resource.getResponseField('virtualRouter.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualRouter.virtualRouter.metadata.uid'),
        outputPath: 'virtualRouter.metadata.uid',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            listeners: this.input.spec.listeners,
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualRouter.virtualRouter.metadata.uid', props);
    return resource.getResponseField('virtualRouter.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualRouter.virtualRouter.metadata.version'),
        outputPath: 'virtualRouter.metadata.version',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            listeners: this.input.spec.listeners,
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualRouter.virtualRouter.metadata.version', props);
    return resource.getResponseField('virtualRouter.metadata.version') as unknown as number;
  }

}

export class AppMeshCreateVirtualRouterVirtualRouterSpec extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualRouterInput) {
    super(scope, id);
  }

  public get listeners(): shapes.AppMeshVirtualRouterListener[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualRouter.virtualRouter.spec.listeners'),
        outputPath: 'virtualRouter.spec.listeners',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            listeners: this.input.spec.listeners,
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualRouter.virtualRouter.spec.listeners', props);
    return resource.getResponseField('virtualRouter.spec.listeners') as unknown as shapes.AppMeshVirtualRouterListener[];
  }

}

export class AppMeshCreateVirtualRouterVirtualRouterStatus extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualRouterInput) {
    super(scope, id);
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualRouter.virtualRouter.status.status'),
        outputPath: 'virtualRouter.status.status',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            listeners: this.input.spec.listeners,
          },
          tags: this.input.tags,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualRouter.virtualRouter.status.status', props);
    return resource.getResponseField('virtualRouter.status.status') as unknown as string;
  }

}

export class AppMeshCreateVirtualService extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualServiceInput) {
    super(scope, id);
  }

  public get virtualService(): AppMeshCreateVirtualServiceVirtualService {
    return new AppMeshCreateVirtualServiceVirtualService(this, 'VirtualService', this.__resources, this.input);
  }

}

export class AppMeshCreateVirtualServiceVirtualService extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualServiceInput) {
    super(scope, id);
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualService.virtualService.meshName'),
        outputPath: 'virtualService.meshName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          tags: this.input.tags,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualService.virtualService.meshName', props);
    return resource.getResponseField('virtualService.meshName') as unknown as string;
  }

  public get metadata(): AppMeshCreateVirtualServiceVirtualServiceMetadata {
    return new AppMeshCreateVirtualServiceVirtualServiceMetadata(this, 'Metadata', this.__resources, this.input);
  }

  public get spec(): AppMeshCreateVirtualServiceVirtualServiceSpec {
    return new AppMeshCreateVirtualServiceVirtualServiceSpec(this, 'Spec', this.__resources, this.input);
  }

  public get status(): AppMeshCreateVirtualServiceVirtualServiceStatus {
    return new AppMeshCreateVirtualServiceVirtualServiceStatus(this, 'Status', this.__resources, this.input);
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualService.virtualService.virtualServiceName'),
        outputPath: 'virtualService.virtualServiceName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          tags: this.input.tags,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualService.virtualService.virtualServiceName', props);
    return resource.getResponseField('virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshCreateVirtualServiceVirtualServiceMetadata extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualServiceInput) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualService.virtualService.metadata.arn'),
        outputPath: 'virtualService.metadata.arn',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          tags: this.input.tags,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualService.virtualService.metadata.arn', props);
    return resource.getResponseField('virtualService.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualService.virtualService.metadata.createdAt'),
        outputPath: 'virtualService.metadata.createdAt',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          tags: this.input.tags,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualService.virtualService.metadata.createdAt', props);
    return resource.getResponseField('virtualService.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualService.virtualService.metadata.lastUpdatedAt'),
        outputPath: 'virtualService.metadata.lastUpdatedAt',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          tags: this.input.tags,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualService.virtualService.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualService.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualService.virtualService.metadata.meshOwner'),
        outputPath: 'virtualService.metadata.meshOwner',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          tags: this.input.tags,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualService.virtualService.metadata.meshOwner', props);
    return resource.getResponseField('virtualService.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualService.virtualService.metadata.resourceOwner'),
        outputPath: 'virtualService.metadata.resourceOwner',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          tags: this.input.tags,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualService.virtualService.metadata.resourceOwner', props);
    return resource.getResponseField('virtualService.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualService.virtualService.metadata.uid'),
        outputPath: 'virtualService.metadata.uid',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          tags: this.input.tags,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualService.virtualService.metadata.uid', props);
    return resource.getResponseField('virtualService.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualService.virtualService.metadata.version'),
        outputPath: 'virtualService.metadata.version',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          tags: this.input.tags,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualService.virtualService.metadata.version', props);
    return resource.getResponseField('virtualService.metadata.version') as unknown as number;
  }

}

export class AppMeshCreateVirtualServiceVirtualServiceSpec extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualServiceInput) {
    super(scope, id);
  }

  public get provider(): AppMeshCreateVirtualServiceVirtualServiceSpecProvider {
    return new AppMeshCreateVirtualServiceVirtualServiceSpecProvider(this, 'Provider', this.__resources, this.input);
  }

}

export class AppMeshCreateVirtualServiceVirtualServiceSpecProvider extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualServiceInput) {
    super(scope, id);
  }

  public get virtualNode(): AppMeshCreateVirtualServiceVirtualServiceSpecProviderVirtualNode {
    return new AppMeshCreateVirtualServiceVirtualServiceSpecProviderVirtualNode(this, 'VirtualNode', this.__resources, this.input);
  }

  public get virtualRouter(): AppMeshCreateVirtualServiceVirtualServiceSpecProviderVirtualRouter {
    return new AppMeshCreateVirtualServiceVirtualServiceSpecProviderVirtualRouter(this, 'VirtualRouter', this.__resources, this.input);
  }

}

export class AppMeshCreateVirtualServiceVirtualServiceSpecProviderVirtualNode extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualServiceInput) {
    super(scope, id);
  }

  public get virtualNodeName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualService.virtualService.spec.provider.virtualNode.virtualNodeName'),
        outputPath: 'virtualService.spec.provider.virtualNode.virtualNodeName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          tags: this.input.tags,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualService.virtualService.spec.provider.virtualNode.virtualNodeName', props);
    return resource.getResponseField('virtualService.spec.provider.virtualNode.virtualNodeName') as unknown as string;
  }

}

export class AppMeshCreateVirtualServiceVirtualServiceSpecProviderVirtualRouter extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualServiceInput) {
    super(scope, id);
  }

  public get virtualRouterName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualService.virtualService.spec.provider.virtualRouter.virtualRouterName'),
        outputPath: 'virtualService.spec.provider.virtualRouter.virtualRouterName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          tags: this.input.tags,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualService.virtualService.spec.provider.virtualRouter.virtualRouterName', props);
    return resource.getResponseField('virtualService.spec.provider.virtualRouter.virtualRouterName') as unknown as string;
  }

}

export class AppMeshCreateVirtualServiceVirtualServiceStatus extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshCreateVirtualServiceInput) {
    super(scope, id);
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualService.virtualService.status.status'),
        outputPath: 'virtualService.status.status',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          tags: this.input.tags,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateVirtualService.virtualService.status.status', props);
    return resource.getResponseField('virtualService.status.status') as unknown as string;
  }

}

export class AppMeshDeleteGatewayRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteGatewayRouteInput) {
    super(scope, id);
  }

  public get gatewayRoute(): AppMeshDeleteGatewayRouteGatewayRoute {
    return new AppMeshDeleteGatewayRouteGatewayRoute(this, 'GatewayRoute', this.__resources, this.input);
  }

}

export class AppMeshDeleteGatewayRouteGatewayRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteGatewayRouteInput) {
    super(scope, id);
  }

  public get gatewayRouteName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.gatewayRouteName'),
        outputPath: 'gatewayRoute.gatewayRouteName',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteGatewayRoute.gatewayRoute.gatewayRouteName', props);
    return resource.getResponseField('gatewayRoute.gatewayRouteName') as unknown as string;
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.meshName'),
        outputPath: 'gatewayRoute.meshName',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteGatewayRoute.gatewayRoute.meshName', props);
    return resource.getResponseField('gatewayRoute.meshName') as unknown as string;
  }

  public get metadata(): AppMeshDeleteGatewayRouteGatewayRouteMetadata {
    return new AppMeshDeleteGatewayRouteGatewayRouteMetadata(this, 'Metadata', this.__resources, this.input);
  }

  public get spec(): AppMeshDeleteGatewayRouteGatewayRouteSpec {
    return new AppMeshDeleteGatewayRouteGatewayRouteSpec(this, 'Spec', this.__resources, this.input);
  }

  public get status(): AppMeshDeleteGatewayRouteGatewayRouteStatus {
    return new AppMeshDeleteGatewayRouteGatewayRouteStatus(this, 'Status', this.__resources, this.input);
  }

  public get virtualGatewayName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.virtualGatewayName'),
        outputPath: 'gatewayRoute.virtualGatewayName',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteGatewayRoute.gatewayRoute.virtualGatewayName', props);
    return resource.getResponseField('gatewayRoute.virtualGatewayName') as unknown as string;
  }

}

export class AppMeshDeleteGatewayRouteGatewayRouteMetadata extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteGatewayRouteInput) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.metadata.arn'),
        outputPath: 'gatewayRoute.metadata.arn',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteGatewayRoute.gatewayRoute.metadata.arn', props);
    return resource.getResponseField('gatewayRoute.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.metadata.createdAt'),
        outputPath: 'gatewayRoute.metadata.createdAt',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteGatewayRoute.gatewayRoute.metadata.createdAt', props);
    return resource.getResponseField('gatewayRoute.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.metadata.lastUpdatedAt'),
        outputPath: 'gatewayRoute.metadata.lastUpdatedAt',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteGatewayRoute.gatewayRoute.metadata.lastUpdatedAt', props);
    return resource.getResponseField('gatewayRoute.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.metadata.meshOwner'),
        outputPath: 'gatewayRoute.metadata.meshOwner',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteGatewayRoute.gatewayRoute.metadata.meshOwner', props);
    return resource.getResponseField('gatewayRoute.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.metadata.resourceOwner'),
        outputPath: 'gatewayRoute.metadata.resourceOwner',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteGatewayRoute.gatewayRoute.metadata.resourceOwner', props);
    return resource.getResponseField('gatewayRoute.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.metadata.uid'),
        outputPath: 'gatewayRoute.metadata.uid',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteGatewayRoute.gatewayRoute.metadata.uid', props);
    return resource.getResponseField('gatewayRoute.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.metadata.version'),
        outputPath: 'gatewayRoute.metadata.version',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteGatewayRoute.gatewayRoute.metadata.version', props);
    return resource.getResponseField('gatewayRoute.metadata.version') as unknown as number;
  }

}

export class AppMeshDeleteGatewayRouteGatewayRouteSpec extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteGatewayRouteInput) {
    super(scope, id);
  }

  public get grpcRoute(): AppMeshDeleteGatewayRouteGatewayRouteSpecGrpcRoute {
    return new AppMeshDeleteGatewayRouteGatewayRouteSpecGrpcRoute(this, 'GrpcRoute', this.__resources, this.input);
  }

  public get http2Route(): AppMeshDeleteGatewayRouteGatewayRouteSpecHttp2Route {
    return new AppMeshDeleteGatewayRouteGatewayRouteSpecHttp2Route(this, 'Http2Route', this.__resources, this.input);
  }

  public get httpRoute(): AppMeshDeleteGatewayRouteGatewayRouteSpecHttpRoute {
    return new AppMeshDeleteGatewayRouteGatewayRouteSpecHttpRoute(this, 'HttpRoute', this.__resources, this.input);
  }

}

export class AppMeshDeleteGatewayRouteGatewayRouteSpecGrpcRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteGatewayRouteInput) {
    super(scope, id);
  }

  public get action(): AppMeshDeleteGatewayRouteGatewayRouteSpecGrpcRouteAction {
    return new AppMeshDeleteGatewayRouteGatewayRouteSpecGrpcRouteAction(this, 'Action', this.__resources, this.input);
  }

  public get match(): AppMeshDeleteGatewayRouteGatewayRouteSpecGrpcRouteMatch {
    return new AppMeshDeleteGatewayRouteGatewayRouteSpecGrpcRouteMatch(this, 'Match', this.__resources, this.input);
  }

}

export class AppMeshDeleteGatewayRouteGatewayRouteSpecGrpcRouteAction extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteGatewayRouteInput) {
    super(scope, id);
  }

  public get target(): AppMeshDeleteGatewayRouteGatewayRouteSpecGrpcRouteActionTarget {
    return new AppMeshDeleteGatewayRouteGatewayRouteSpecGrpcRouteActionTarget(this, 'Target', this.__resources, this.input);
  }

}

export class AppMeshDeleteGatewayRouteGatewayRouteSpecGrpcRouteActionTarget extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteGatewayRouteInput) {
    super(scope, id);
  }

  public get virtualService(): AppMeshDeleteGatewayRouteGatewayRouteSpecGrpcRouteActionTargetVirtualService {
    return new AppMeshDeleteGatewayRouteGatewayRouteSpecGrpcRouteActionTargetVirtualService(this, 'VirtualService', this.__resources, this.input);
  }

}

export class AppMeshDeleteGatewayRouteGatewayRouteSpecGrpcRouteActionTargetVirtualService extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteGatewayRouteInput) {
    super(scope, id);
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName'),
        outputPath: 'gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteGatewayRoute.gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName', props);
    return resource.getResponseField('gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshDeleteGatewayRouteGatewayRouteSpecGrpcRouteMatch extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteGatewayRouteInput) {
    super(scope, id);
  }

  public get serviceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.spec.grpcRoute.match.serviceName'),
        outputPath: 'gatewayRoute.spec.grpcRoute.match.serviceName',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteGatewayRoute.gatewayRoute.spec.grpcRoute.match.serviceName', props);
    return resource.getResponseField('gatewayRoute.spec.grpcRoute.match.serviceName') as unknown as string;
  }

}

export class AppMeshDeleteGatewayRouteGatewayRouteSpecHttp2Route extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteGatewayRouteInput) {
    super(scope, id);
  }

  public get action(): AppMeshDeleteGatewayRouteGatewayRouteSpecHttp2RouteAction {
    return new AppMeshDeleteGatewayRouteGatewayRouteSpecHttp2RouteAction(this, 'Action', this.__resources, this.input);
  }

  public get match(): AppMeshDeleteGatewayRouteGatewayRouteSpecHttp2RouteMatch {
    return new AppMeshDeleteGatewayRouteGatewayRouteSpecHttp2RouteMatch(this, 'Match', this.__resources, this.input);
  }

}

export class AppMeshDeleteGatewayRouteGatewayRouteSpecHttp2RouteAction extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteGatewayRouteInput) {
    super(scope, id);
  }

  public get target(): AppMeshDeleteGatewayRouteGatewayRouteSpecHttp2RouteActionTarget {
    return new AppMeshDeleteGatewayRouteGatewayRouteSpecHttp2RouteActionTarget(this, 'Target', this.__resources, this.input);
  }

}

export class AppMeshDeleteGatewayRouteGatewayRouteSpecHttp2RouteActionTarget extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteGatewayRouteInput) {
    super(scope, id);
  }

  public get virtualService(): AppMeshDeleteGatewayRouteGatewayRouteSpecHttp2RouteActionTargetVirtualService {
    return new AppMeshDeleteGatewayRouteGatewayRouteSpecHttp2RouteActionTargetVirtualService(this, 'VirtualService', this.__resources, this.input);
  }

}

export class AppMeshDeleteGatewayRouteGatewayRouteSpecHttp2RouteActionTargetVirtualService extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteGatewayRouteInput) {
    super(scope, id);
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName'),
        outputPath: 'gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteGatewayRoute.gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName', props);
    return resource.getResponseField('gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshDeleteGatewayRouteGatewayRouteSpecHttp2RouteMatch extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteGatewayRouteInput) {
    super(scope, id);
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.spec.http2Route.match.prefix'),
        outputPath: 'gatewayRoute.spec.http2Route.match.prefix',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteGatewayRoute.gatewayRoute.spec.http2Route.match.prefix', props);
    return resource.getResponseField('gatewayRoute.spec.http2Route.match.prefix') as unknown as string;
  }

}

export class AppMeshDeleteGatewayRouteGatewayRouteSpecHttpRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteGatewayRouteInput) {
    super(scope, id);
  }

  public get action(): AppMeshDeleteGatewayRouteGatewayRouteSpecHttpRouteAction {
    return new AppMeshDeleteGatewayRouteGatewayRouteSpecHttpRouteAction(this, 'Action', this.__resources, this.input);
  }

  public get match(): AppMeshDeleteGatewayRouteGatewayRouteSpecHttpRouteMatch {
    return new AppMeshDeleteGatewayRouteGatewayRouteSpecHttpRouteMatch(this, 'Match', this.__resources, this.input);
  }

}

export class AppMeshDeleteGatewayRouteGatewayRouteSpecHttpRouteAction extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteGatewayRouteInput) {
    super(scope, id);
  }

  public get target(): AppMeshDeleteGatewayRouteGatewayRouteSpecHttpRouteActionTarget {
    return new AppMeshDeleteGatewayRouteGatewayRouteSpecHttpRouteActionTarget(this, 'Target', this.__resources, this.input);
  }

}

export class AppMeshDeleteGatewayRouteGatewayRouteSpecHttpRouteActionTarget extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteGatewayRouteInput) {
    super(scope, id);
  }

  public get virtualService(): AppMeshDeleteGatewayRouteGatewayRouteSpecHttpRouteActionTargetVirtualService {
    return new AppMeshDeleteGatewayRouteGatewayRouteSpecHttpRouteActionTargetVirtualService(this, 'VirtualService', this.__resources, this.input);
  }

}

export class AppMeshDeleteGatewayRouteGatewayRouteSpecHttpRouteActionTargetVirtualService extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteGatewayRouteInput) {
    super(scope, id);
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName'),
        outputPath: 'gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteGatewayRoute.gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName', props);
    return resource.getResponseField('gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshDeleteGatewayRouteGatewayRouteSpecHttpRouteMatch extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteGatewayRouteInput) {
    super(scope, id);
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.spec.httpRoute.match.prefix'),
        outputPath: 'gatewayRoute.spec.httpRoute.match.prefix',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteGatewayRoute.gatewayRoute.spec.httpRoute.match.prefix', props);
    return resource.getResponseField('gatewayRoute.spec.httpRoute.match.prefix') as unknown as string;
  }

}

export class AppMeshDeleteGatewayRouteGatewayRouteStatus extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteGatewayRouteInput) {
    super(scope, id);
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.status.status'),
        outputPath: 'gatewayRoute.status.status',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteGatewayRoute.gatewayRoute.status.status', props);
    return resource.getResponseField('gatewayRoute.status.status') as unknown as string;
  }

}

export class AppMeshDeleteMesh extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteMeshInput) {
    super(scope, id);
  }

  public get mesh(): AppMeshDeleteMeshMesh {
    return new AppMeshDeleteMeshMesh(this, 'Mesh', this.__resources, this.input);
  }

}

export class AppMeshDeleteMeshMesh extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteMeshInput) {
    super(scope, id);
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteMesh.mesh.meshName'),
        outputPath: 'mesh.meshName',
        parameters: {
          meshName: this.input.meshName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMesh.mesh.meshName', props);
    return resource.getResponseField('mesh.meshName') as unknown as string;
  }

  public get metadata(): AppMeshDeleteMeshMeshMetadata {
    return new AppMeshDeleteMeshMeshMetadata(this, 'Metadata', this.__resources, this.input);
  }

  public get spec(): AppMeshDeleteMeshMeshSpec {
    return new AppMeshDeleteMeshMeshSpec(this, 'Spec', this.__resources, this.input);
  }

  public get status(): AppMeshDeleteMeshMeshStatus {
    return new AppMeshDeleteMeshMeshStatus(this, 'Status', this.__resources, this.input);
  }

}

export class AppMeshDeleteMeshMeshMetadata extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteMeshInput) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteMesh.mesh.metadata.arn'),
        outputPath: 'mesh.metadata.arn',
        parameters: {
          meshName: this.input.meshName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMesh.mesh.metadata.arn', props);
    return resource.getResponseField('mesh.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteMesh.mesh.metadata.createdAt'),
        outputPath: 'mesh.metadata.createdAt',
        parameters: {
          meshName: this.input.meshName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMesh.mesh.metadata.createdAt', props);
    return resource.getResponseField('mesh.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteMesh.mesh.metadata.lastUpdatedAt'),
        outputPath: 'mesh.metadata.lastUpdatedAt',
        parameters: {
          meshName: this.input.meshName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMesh.mesh.metadata.lastUpdatedAt', props);
    return resource.getResponseField('mesh.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteMesh.mesh.metadata.meshOwner'),
        outputPath: 'mesh.metadata.meshOwner',
        parameters: {
          meshName: this.input.meshName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMesh.mesh.metadata.meshOwner', props);
    return resource.getResponseField('mesh.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteMesh.mesh.metadata.resourceOwner'),
        outputPath: 'mesh.metadata.resourceOwner',
        parameters: {
          meshName: this.input.meshName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMesh.mesh.metadata.resourceOwner', props);
    return resource.getResponseField('mesh.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteMesh.mesh.metadata.uid'),
        outputPath: 'mesh.metadata.uid',
        parameters: {
          meshName: this.input.meshName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMesh.mesh.metadata.uid', props);
    return resource.getResponseField('mesh.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteMesh.mesh.metadata.version'),
        outputPath: 'mesh.metadata.version',
        parameters: {
          meshName: this.input.meshName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMesh.mesh.metadata.version', props);
    return resource.getResponseField('mesh.metadata.version') as unknown as number;
  }

}

export class AppMeshDeleteMeshMeshSpec extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteMeshInput) {
    super(scope, id);
  }

  public get egressFilter(): AppMeshDeleteMeshMeshSpecEgressFilter {
    return new AppMeshDeleteMeshMeshSpecEgressFilter(this, 'EgressFilter', this.__resources, this.input);
  }

}

export class AppMeshDeleteMeshMeshSpecEgressFilter extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteMeshInput) {
    super(scope, id);
  }

  public get type(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteMesh.mesh.spec.egressFilter.type'),
        outputPath: 'mesh.spec.egressFilter.type',
        parameters: {
          meshName: this.input.meshName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMesh.mesh.spec.egressFilter.type', props);
    return resource.getResponseField('mesh.spec.egressFilter.type') as unknown as string;
  }

}

export class AppMeshDeleteMeshMeshStatus extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteMeshInput) {
    super(scope, id);
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteMesh.mesh.status.status'),
        outputPath: 'mesh.status.status',
        parameters: {
          meshName: this.input.meshName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMesh.mesh.status.status', props);
    return resource.getResponseField('mesh.status.status') as unknown as string;
  }

}

export class AppMeshDeleteRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get route(): AppMeshDeleteRouteRoute {
    return new AppMeshDeleteRouteRoute(this, 'Route', this.__resources, this.input);
  }

}

export class AppMeshDeleteRouteRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.meshName'),
        outputPath: 'route.meshName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.meshName', props);
    return resource.getResponseField('route.meshName') as unknown as string;
  }

  public get metadata(): AppMeshDeleteRouteRouteMetadata {
    return new AppMeshDeleteRouteRouteMetadata(this, 'Metadata', this.__resources, this.input);
  }

  public get routeName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.routeName'),
        outputPath: 'route.routeName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.routeName', props);
    return resource.getResponseField('route.routeName') as unknown as string;
  }

  public get spec(): AppMeshDeleteRouteRouteSpec {
    return new AppMeshDeleteRouteRouteSpec(this, 'Spec', this.__resources, this.input);
  }

  public get status(): AppMeshDeleteRouteRouteStatus {
    return new AppMeshDeleteRouteRouteStatus(this, 'Status', this.__resources, this.input);
  }

  public get virtualRouterName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.virtualRouterName'),
        outputPath: 'route.virtualRouterName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.virtualRouterName', props);
    return resource.getResponseField('route.virtualRouterName') as unknown as string;
  }

}

export class AppMeshDeleteRouteRouteMetadata extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.metadata.arn'),
        outputPath: 'route.metadata.arn',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.metadata.arn', props);
    return resource.getResponseField('route.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.metadata.createdAt'),
        outputPath: 'route.metadata.createdAt',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.metadata.createdAt', props);
    return resource.getResponseField('route.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.metadata.lastUpdatedAt'),
        outputPath: 'route.metadata.lastUpdatedAt',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.metadata.lastUpdatedAt', props);
    return resource.getResponseField('route.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.metadata.meshOwner'),
        outputPath: 'route.metadata.meshOwner',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.metadata.meshOwner', props);
    return resource.getResponseField('route.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.metadata.resourceOwner'),
        outputPath: 'route.metadata.resourceOwner',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.metadata.resourceOwner', props);
    return resource.getResponseField('route.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.metadata.uid'),
        outputPath: 'route.metadata.uid',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.metadata.uid', props);
    return resource.getResponseField('route.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.metadata.version'),
        outputPath: 'route.metadata.version',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.metadata.version', props);
    return resource.getResponseField('route.metadata.version') as unknown as number;
  }

}

export class AppMeshDeleteRouteRouteSpec extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get grpcRoute(): AppMeshDeleteRouteRouteSpecGrpcRoute {
    return new AppMeshDeleteRouteRouteSpecGrpcRoute(this, 'GrpcRoute', this.__resources, this.input);
  }

  public get http2Route(): AppMeshDeleteRouteRouteSpecHttp2Route {
    return new AppMeshDeleteRouteRouteSpecHttp2Route(this, 'Http2Route', this.__resources, this.input);
  }

  public get httpRoute(): AppMeshDeleteRouteRouteSpecHttpRoute {
    return new AppMeshDeleteRouteRouteSpecHttpRoute(this, 'HttpRoute', this.__resources, this.input);
  }

  public get priority(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.priority'),
        outputPath: 'route.spec.priority',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.priority', props);
    return resource.getResponseField('route.spec.priority') as unknown as number;
  }

  public get tcpRoute(): AppMeshDeleteRouteRouteSpecTcpRoute {
    return new AppMeshDeleteRouteRouteSpecTcpRoute(this, 'TcpRoute', this.__resources, this.input);
  }

}

export class AppMeshDeleteRouteRouteSpecGrpcRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get action(): AppMeshDeleteRouteRouteSpecGrpcRouteAction {
    return new AppMeshDeleteRouteRouteSpecGrpcRouteAction(this, 'Action', this.__resources, this.input);
  }

  public get match(): AppMeshDeleteRouteRouteSpecGrpcRouteMatch {
    return new AppMeshDeleteRouteRouteSpecGrpcRouteMatch(this, 'Match', this.__resources, this.input);
  }

  public get retryPolicy(): AppMeshDeleteRouteRouteSpecGrpcRouteRetryPolicy {
    return new AppMeshDeleteRouteRouteSpecGrpcRouteRetryPolicy(this, 'RetryPolicy', this.__resources, this.input);
  }

  public get timeout(): AppMeshDeleteRouteRouteSpecGrpcRouteTimeout {
    return new AppMeshDeleteRouteRouteSpecGrpcRouteTimeout(this, 'Timeout', this.__resources, this.input);
  }

}

export class AppMeshDeleteRouteRouteSpecGrpcRouteAction extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.grpcRoute.action.weightedTargets'),
        outputPath: 'route.spec.grpcRoute.action.weightedTargets',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.grpcRoute.action.weightedTargets', props);
    return resource.getResponseField('route.spec.grpcRoute.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshDeleteRouteRouteSpecGrpcRouteMatch extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get metadata(): shapes.AppMeshGrpcRouteMetadata[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.grpcRoute.match.metadata'),
        outputPath: 'route.spec.grpcRoute.match.metadata',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.grpcRoute.match.metadata', props);
    return resource.getResponseField('route.spec.grpcRoute.match.metadata') as unknown as shapes.AppMeshGrpcRouteMetadata[];
  }

  public get methodName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.grpcRoute.match.methodName'),
        outputPath: 'route.spec.grpcRoute.match.methodName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.grpcRoute.match.methodName', props);
    return resource.getResponseField('route.spec.grpcRoute.match.methodName') as unknown as string;
  }

  public get serviceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.grpcRoute.match.serviceName'),
        outputPath: 'route.spec.grpcRoute.match.serviceName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.grpcRoute.match.serviceName', props);
    return resource.getResponseField('route.spec.grpcRoute.match.serviceName') as unknown as string;
  }

}

export class AppMeshDeleteRouteRouteSpecGrpcRouteRetryPolicy extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get grpcRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.grpcRoute.retryPolicy.grpcRetryEvents'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.grpcRetryEvents',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.grpcRoute.retryPolicy.grpcRetryEvents', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.grpcRetryEvents') as unknown as string[];
  }

  public get httpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.grpcRoute.retryPolicy.httpRetryEvents'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.httpRetryEvents',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.grpcRoute.retryPolicy.httpRetryEvents', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.httpRetryEvents') as unknown as string[];
  }

  public get maxRetries(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.grpcRoute.retryPolicy.maxRetries'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.maxRetries',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.grpcRoute.retryPolicy.maxRetries', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.maxRetries') as unknown as number;
  }

  public get perRetryTimeout(): AppMeshDeleteRouteRouteSpecGrpcRouteRetryPolicyPerRetryTimeout {
    return new AppMeshDeleteRouteRouteSpecGrpcRouteRetryPolicyPerRetryTimeout(this, 'PerRetryTimeout', this.__resources, this.input);
  }

  public get tcpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.grpcRoute.retryPolicy.tcpRetryEvents'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.tcpRetryEvents',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.grpcRoute.retryPolicy.tcpRetryEvents', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.tcpRetryEvents') as unknown as string[];
  }

}

export class AppMeshDeleteRouteRouteSpecGrpcRouteRetryPolicyPerRetryTimeout extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.value'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.perRetryTimeout.value',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.value', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.perRetryTimeout.value') as unknown as number;
  }

}

export class AppMeshDeleteRouteRouteSpecGrpcRouteTimeout extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get idle(): AppMeshDeleteRouteRouteSpecGrpcRouteTimeoutIdle {
    return new AppMeshDeleteRouteRouteSpecGrpcRouteTimeoutIdle(this, 'Idle', this.__resources, this.input);
  }

  public get perRequest(): AppMeshDeleteRouteRouteSpecGrpcRouteTimeoutPerRequest {
    return new AppMeshDeleteRouteRouteSpecGrpcRouteTimeoutPerRequest(this, 'PerRequest', this.__resources, this.input);
  }

}

export class AppMeshDeleteRouteRouteSpecGrpcRouteTimeoutIdle extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.grpcRoute.timeout.idle.unit'),
        outputPath: 'route.spec.grpcRoute.timeout.idle.unit',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.grpcRoute.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.grpcRoute.timeout.idle.value'),
        outputPath: 'route.spec.grpcRoute.timeout.idle.value',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.grpcRoute.timeout.idle.value', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshDeleteRouteRouteSpecGrpcRouteTimeoutPerRequest extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.grpcRoute.timeout.perRequest.unit'),
        outputPath: 'route.spec.grpcRoute.timeout.perRequest.unit',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.grpcRoute.timeout.perRequest.unit', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.perRequest.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.grpcRoute.timeout.perRequest.value'),
        outputPath: 'route.spec.grpcRoute.timeout.perRequest.value',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.grpcRoute.timeout.perRequest.value', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.perRequest.value') as unknown as number;
  }

}

export class AppMeshDeleteRouteRouteSpecHttp2Route extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get action(): AppMeshDeleteRouteRouteSpecHttp2RouteAction {
    return new AppMeshDeleteRouteRouteSpecHttp2RouteAction(this, 'Action', this.__resources, this.input);
  }

  public get match(): AppMeshDeleteRouteRouteSpecHttp2RouteMatch {
    return new AppMeshDeleteRouteRouteSpecHttp2RouteMatch(this, 'Match', this.__resources, this.input);
  }

  public get retryPolicy(): AppMeshDeleteRouteRouteSpecHttp2RouteRetryPolicy {
    return new AppMeshDeleteRouteRouteSpecHttp2RouteRetryPolicy(this, 'RetryPolicy', this.__resources, this.input);
  }

  public get timeout(): AppMeshDeleteRouteRouteSpecHttp2RouteTimeout {
    return new AppMeshDeleteRouteRouteSpecHttp2RouteTimeout(this, 'Timeout', this.__resources, this.input);
  }

}

export class AppMeshDeleteRouteRouteSpecHttp2RouteAction extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.http2Route.action.weightedTargets'),
        outputPath: 'route.spec.http2Route.action.weightedTargets',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.http2Route.action.weightedTargets', props);
    return resource.getResponseField('route.spec.http2Route.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshDeleteRouteRouteSpecHttp2RouteMatch extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get headers(): shapes.AppMeshHttpRouteHeader[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.http2Route.match.headers'),
        outputPath: 'route.spec.http2Route.match.headers',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.http2Route.match.headers', props);
    return resource.getResponseField('route.spec.http2Route.match.headers') as unknown as shapes.AppMeshHttpRouteHeader[];
  }

  public get method(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.http2Route.match.method'),
        outputPath: 'route.spec.http2Route.match.method',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.http2Route.match.method', props);
    return resource.getResponseField('route.spec.http2Route.match.method') as unknown as string;
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.http2Route.match.prefix'),
        outputPath: 'route.spec.http2Route.match.prefix',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.http2Route.match.prefix', props);
    return resource.getResponseField('route.spec.http2Route.match.prefix') as unknown as string;
  }

  public get scheme(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.http2Route.match.scheme'),
        outputPath: 'route.spec.http2Route.match.scheme',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.http2Route.match.scheme', props);
    return resource.getResponseField('route.spec.http2Route.match.scheme') as unknown as string;
  }

}

export class AppMeshDeleteRouteRouteSpecHttp2RouteRetryPolicy extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get httpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.http2Route.retryPolicy.httpRetryEvents'),
        outputPath: 'route.spec.http2Route.retryPolicy.httpRetryEvents',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.http2Route.retryPolicy.httpRetryEvents', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.httpRetryEvents') as unknown as string[];
  }

  public get maxRetries(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.http2Route.retryPolicy.maxRetries'),
        outputPath: 'route.spec.http2Route.retryPolicy.maxRetries',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.http2Route.retryPolicy.maxRetries', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.maxRetries') as unknown as number;
  }

  public get perRetryTimeout(): AppMeshDeleteRouteRouteSpecHttp2RouteRetryPolicyPerRetryTimeout {
    return new AppMeshDeleteRouteRouteSpecHttp2RouteRetryPolicyPerRetryTimeout(this, 'PerRetryTimeout', this.__resources, this.input);
  }

  public get tcpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.http2Route.retryPolicy.tcpRetryEvents'),
        outputPath: 'route.spec.http2Route.retryPolicy.tcpRetryEvents',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.http2Route.retryPolicy.tcpRetryEvents', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.tcpRetryEvents') as unknown as string[];
  }

}

export class AppMeshDeleteRouteRouteSpecHttp2RouteRetryPolicyPerRetryTimeout extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.unit'),
        outputPath: 'route.spec.http2Route.retryPolicy.perRetryTimeout.unit',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.unit', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.perRetryTimeout.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.value'),
        outputPath: 'route.spec.http2Route.retryPolicy.perRetryTimeout.value',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.value', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.perRetryTimeout.value') as unknown as number;
  }

}

export class AppMeshDeleteRouteRouteSpecHttp2RouteTimeout extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get idle(): AppMeshDeleteRouteRouteSpecHttp2RouteTimeoutIdle {
    return new AppMeshDeleteRouteRouteSpecHttp2RouteTimeoutIdle(this, 'Idle', this.__resources, this.input);
  }

  public get perRequest(): AppMeshDeleteRouteRouteSpecHttp2RouteTimeoutPerRequest {
    return new AppMeshDeleteRouteRouteSpecHttp2RouteTimeoutPerRequest(this, 'PerRequest', this.__resources, this.input);
  }

}

export class AppMeshDeleteRouteRouteSpecHttp2RouteTimeoutIdle extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.http2Route.timeout.idle.unit'),
        outputPath: 'route.spec.http2Route.timeout.idle.unit',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.http2Route.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.http2Route.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.http2Route.timeout.idle.value'),
        outputPath: 'route.spec.http2Route.timeout.idle.value',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.http2Route.timeout.idle.value', props);
    return resource.getResponseField('route.spec.http2Route.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshDeleteRouteRouteSpecHttp2RouteTimeoutPerRequest extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.http2Route.timeout.perRequest.unit'),
        outputPath: 'route.spec.http2Route.timeout.perRequest.unit',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.http2Route.timeout.perRequest.unit', props);
    return resource.getResponseField('route.spec.http2Route.timeout.perRequest.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.http2Route.timeout.perRequest.value'),
        outputPath: 'route.spec.http2Route.timeout.perRequest.value',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.http2Route.timeout.perRequest.value', props);
    return resource.getResponseField('route.spec.http2Route.timeout.perRequest.value') as unknown as number;
  }

}

export class AppMeshDeleteRouteRouteSpecHttpRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get action(): AppMeshDeleteRouteRouteSpecHttpRouteAction {
    return new AppMeshDeleteRouteRouteSpecHttpRouteAction(this, 'Action', this.__resources, this.input);
  }

  public get match(): AppMeshDeleteRouteRouteSpecHttpRouteMatch {
    return new AppMeshDeleteRouteRouteSpecHttpRouteMatch(this, 'Match', this.__resources, this.input);
  }

  public get retryPolicy(): AppMeshDeleteRouteRouteSpecHttpRouteRetryPolicy {
    return new AppMeshDeleteRouteRouteSpecHttpRouteRetryPolicy(this, 'RetryPolicy', this.__resources, this.input);
  }

  public get timeout(): AppMeshDeleteRouteRouteSpecHttpRouteTimeout {
    return new AppMeshDeleteRouteRouteSpecHttpRouteTimeout(this, 'Timeout', this.__resources, this.input);
  }

}

export class AppMeshDeleteRouteRouteSpecHttpRouteAction extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.httpRoute.action.weightedTargets'),
        outputPath: 'route.spec.httpRoute.action.weightedTargets',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.httpRoute.action.weightedTargets', props);
    return resource.getResponseField('route.spec.httpRoute.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshDeleteRouteRouteSpecHttpRouteMatch extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get headers(): shapes.AppMeshHttpRouteHeader[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.httpRoute.match.headers'),
        outputPath: 'route.spec.httpRoute.match.headers',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.httpRoute.match.headers', props);
    return resource.getResponseField('route.spec.httpRoute.match.headers') as unknown as shapes.AppMeshHttpRouteHeader[];
  }

  public get method(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.httpRoute.match.method'),
        outputPath: 'route.spec.httpRoute.match.method',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.httpRoute.match.method', props);
    return resource.getResponseField('route.spec.httpRoute.match.method') as unknown as string;
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.httpRoute.match.prefix'),
        outputPath: 'route.spec.httpRoute.match.prefix',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.httpRoute.match.prefix', props);
    return resource.getResponseField('route.spec.httpRoute.match.prefix') as unknown as string;
  }

  public get scheme(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.httpRoute.match.scheme'),
        outputPath: 'route.spec.httpRoute.match.scheme',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.httpRoute.match.scheme', props);
    return resource.getResponseField('route.spec.httpRoute.match.scheme') as unknown as string;
  }

}

export class AppMeshDeleteRouteRouteSpecHttpRouteRetryPolicy extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get httpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.httpRoute.retryPolicy.httpRetryEvents'),
        outputPath: 'route.spec.httpRoute.retryPolicy.httpRetryEvents',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.httpRoute.retryPolicy.httpRetryEvents', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.httpRetryEvents') as unknown as string[];
  }

  public get maxRetries(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.httpRoute.retryPolicy.maxRetries'),
        outputPath: 'route.spec.httpRoute.retryPolicy.maxRetries',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.httpRoute.retryPolicy.maxRetries', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.maxRetries') as unknown as number;
  }

  public get perRetryTimeout(): AppMeshDeleteRouteRouteSpecHttpRouteRetryPolicyPerRetryTimeout {
    return new AppMeshDeleteRouteRouteSpecHttpRouteRetryPolicyPerRetryTimeout(this, 'PerRetryTimeout', this.__resources, this.input);
  }

  public get tcpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.httpRoute.retryPolicy.tcpRetryEvents'),
        outputPath: 'route.spec.httpRoute.retryPolicy.tcpRetryEvents',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.httpRoute.retryPolicy.tcpRetryEvents', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.tcpRetryEvents') as unknown as string[];
  }

}

export class AppMeshDeleteRouteRouteSpecHttpRouteRetryPolicyPerRetryTimeout extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.unit'),
        outputPath: 'route.spec.httpRoute.retryPolicy.perRetryTimeout.unit',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.unit', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.perRetryTimeout.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.value'),
        outputPath: 'route.spec.httpRoute.retryPolicy.perRetryTimeout.value',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.value', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.perRetryTimeout.value') as unknown as number;
  }

}

export class AppMeshDeleteRouteRouteSpecHttpRouteTimeout extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get idle(): AppMeshDeleteRouteRouteSpecHttpRouteTimeoutIdle {
    return new AppMeshDeleteRouteRouteSpecHttpRouteTimeoutIdle(this, 'Idle', this.__resources, this.input);
  }

  public get perRequest(): AppMeshDeleteRouteRouteSpecHttpRouteTimeoutPerRequest {
    return new AppMeshDeleteRouteRouteSpecHttpRouteTimeoutPerRequest(this, 'PerRequest', this.__resources, this.input);
  }

}

export class AppMeshDeleteRouteRouteSpecHttpRouteTimeoutIdle extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.httpRoute.timeout.idle.unit'),
        outputPath: 'route.spec.httpRoute.timeout.idle.unit',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.httpRoute.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.httpRoute.timeout.idle.value'),
        outputPath: 'route.spec.httpRoute.timeout.idle.value',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.httpRoute.timeout.idle.value', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshDeleteRouteRouteSpecHttpRouteTimeoutPerRequest extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.httpRoute.timeout.perRequest.unit'),
        outputPath: 'route.spec.httpRoute.timeout.perRequest.unit',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.httpRoute.timeout.perRequest.unit', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.perRequest.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.httpRoute.timeout.perRequest.value'),
        outputPath: 'route.spec.httpRoute.timeout.perRequest.value',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.httpRoute.timeout.perRequest.value', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.perRequest.value') as unknown as number;
  }

}

export class AppMeshDeleteRouteRouteSpecTcpRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get action(): AppMeshDeleteRouteRouteSpecTcpRouteAction {
    return new AppMeshDeleteRouteRouteSpecTcpRouteAction(this, 'Action', this.__resources, this.input);
  }

  public get timeout(): AppMeshDeleteRouteRouteSpecTcpRouteTimeout {
    return new AppMeshDeleteRouteRouteSpecTcpRouteTimeout(this, 'Timeout', this.__resources, this.input);
  }

}

export class AppMeshDeleteRouteRouteSpecTcpRouteAction extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.tcpRoute.action.weightedTargets'),
        outputPath: 'route.spec.tcpRoute.action.weightedTargets',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.tcpRoute.action.weightedTargets', props);
    return resource.getResponseField('route.spec.tcpRoute.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshDeleteRouteRouteSpecTcpRouteTimeout extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get idle(): AppMeshDeleteRouteRouteSpecTcpRouteTimeoutIdle {
    return new AppMeshDeleteRouteRouteSpecTcpRouteTimeoutIdle(this, 'Idle', this.__resources, this.input);
  }

}

export class AppMeshDeleteRouteRouteSpecTcpRouteTimeoutIdle extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.tcpRoute.timeout.idle.unit'),
        outputPath: 'route.spec.tcpRoute.timeout.idle.unit',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.tcpRoute.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.tcpRoute.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.tcpRoute.timeout.idle.value'),
        outputPath: 'route.spec.tcpRoute.timeout.idle.value',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.spec.tcpRoute.timeout.idle.value', props);
    return resource.getResponseField('route.spec.tcpRoute.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshDeleteRouteRouteStatus extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteRouteInput) {
    super(scope, id);
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.status.status'),
        outputPath: 'route.status.status',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteRoute.route.status.status', props);
    return resource.getResponseField('route.status.status') as unknown as string;
  }

}

export class AppMeshDeleteVirtualGateway extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualGatewayInput) {
    super(scope, id);
  }

  public get virtualGateway(): AppMeshDeleteVirtualGatewayVirtualGateway {
    return new AppMeshDeleteVirtualGatewayVirtualGateway(this, 'VirtualGateway', this.__resources, this.input);
  }

}

export class AppMeshDeleteVirtualGatewayVirtualGateway extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualGatewayInput) {
    super(scope, id);
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.meshName'),
        outputPath: 'virtualGateway.meshName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualGateway.virtualGateway.meshName', props);
    return resource.getResponseField('virtualGateway.meshName') as unknown as string;
  }

  public get metadata(): AppMeshDeleteVirtualGatewayVirtualGatewayMetadata {
    return new AppMeshDeleteVirtualGatewayVirtualGatewayMetadata(this, 'Metadata', this.__resources, this.input);
  }

  public get spec(): AppMeshDeleteVirtualGatewayVirtualGatewaySpec {
    return new AppMeshDeleteVirtualGatewayVirtualGatewaySpec(this, 'Spec', this.__resources, this.input);
  }

  public get status(): AppMeshDeleteVirtualGatewayVirtualGatewayStatus {
    return new AppMeshDeleteVirtualGatewayVirtualGatewayStatus(this, 'Status', this.__resources, this.input);
  }

  public get virtualGatewayName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.virtualGatewayName'),
        outputPath: 'virtualGateway.virtualGatewayName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualGateway.virtualGateway.virtualGatewayName', props);
    return resource.getResponseField('virtualGateway.virtualGatewayName') as unknown as string;
  }

}

export class AppMeshDeleteVirtualGatewayVirtualGatewayMetadata extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualGatewayInput) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.metadata.arn'),
        outputPath: 'virtualGateway.metadata.arn',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualGateway.virtualGateway.metadata.arn', props);
    return resource.getResponseField('virtualGateway.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.metadata.createdAt'),
        outputPath: 'virtualGateway.metadata.createdAt',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualGateway.virtualGateway.metadata.createdAt', props);
    return resource.getResponseField('virtualGateway.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.metadata.lastUpdatedAt'),
        outputPath: 'virtualGateway.metadata.lastUpdatedAt',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualGateway.virtualGateway.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualGateway.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.metadata.meshOwner'),
        outputPath: 'virtualGateway.metadata.meshOwner',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualGateway.virtualGateway.metadata.meshOwner', props);
    return resource.getResponseField('virtualGateway.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.metadata.resourceOwner'),
        outputPath: 'virtualGateway.metadata.resourceOwner',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualGateway.virtualGateway.metadata.resourceOwner', props);
    return resource.getResponseField('virtualGateway.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.metadata.uid'),
        outputPath: 'virtualGateway.metadata.uid',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualGateway.virtualGateway.metadata.uid', props);
    return resource.getResponseField('virtualGateway.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.metadata.version'),
        outputPath: 'virtualGateway.metadata.version',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualGateway.virtualGateway.metadata.version', props);
    return resource.getResponseField('virtualGateway.metadata.version') as unknown as number;
  }

}

export class AppMeshDeleteVirtualGatewayVirtualGatewaySpec extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualGatewayInput) {
    super(scope, id);
  }

  public get backendDefaults(): AppMeshDeleteVirtualGatewayVirtualGatewaySpecBackendDefaults {
    return new AppMeshDeleteVirtualGatewayVirtualGatewaySpecBackendDefaults(this, 'BackendDefaults', this.__resources, this.input);
  }

  public get listeners(): shapes.AppMeshVirtualGatewayListener[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.spec.listeners'),
        outputPath: 'virtualGateway.spec.listeners',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualGateway.virtualGateway.spec.listeners', props);
    return resource.getResponseField('virtualGateway.spec.listeners') as unknown as shapes.AppMeshVirtualGatewayListener[];
  }

  public get logging(): AppMeshDeleteVirtualGatewayVirtualGatewaySpecLogging {
    return new AppMeshDeleteVirtualGatewayVirtualGatewaySpecLogging(this, 'Logging', this.__resources, this.input);
  }

}

export class AppMeshDeleteVirtualGatewayVirtualGatewaySpecBackendDefaults extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualGatewayInput) {
    super(scope, id);
  }

  public get clientPolicy(): AppMeshDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicy {
    return new AppMeshDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicy(this, 'ClientPolicy', this.__resources, this.input);
  }

}

export class AppMeshDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicy extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualGatewayInput) {
    super(scope, id);
  }

  public get tls(): AppMeshDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTls {
    return new AppMeshDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTls(this, 'Tls', this.__resources, this.input);
  }

}

export class AppMeshDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTls extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualGatewayInput) {
    super(scope, id);
  }

  public get enforce(): boolean {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce') as unknown as boolean;
  }

  public get ports(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.ports'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.ports',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.ports', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.ports') as unknown as number[];
  }

  public get validation(): AppMeshDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation {
    return new AppMeshDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation(this, 'Validation', this.__resources, this.input);
  }

}

export class AppMeshDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualGatewayInput) {
    super(scope, id);
  }

  public get trust(): AppMeshDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust {
    return new AppMeshDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust(this, 'Trust', this.__resources, this.input);
  }

}

export class AppMeshDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualGatewayInput) {
    super(scope, id);
  }

  public get acm(): AppMeshDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
    return new AppMeshDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm(this, 'Acm', this.__resources, this.input);
  }

  public get file(): AppMeshDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile {
    return new AppMeshDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile(this, 'File', this.__resources, this.input);
  }

}

export class AppMeshDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualGatewayInput) {
    super(scope, id);
  }

  public get certificateAuthorityArns(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns') as unknown as string[];
  }

}

export class AppMeshDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualGatewayInput) {
    super(scope, id);
  }

  public get certificateChain(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain') as unknown as string;
  }

}

export class AppMeshDeleteVirtualGatewayVirtualGatewaySpecLogging extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualGatewayInput) {
    super(scope, id);
  }

  public get accessLog(): AppMeshDeleteVirtualGatewayVirtualGatewaySpecLoggingAccessLog {
    return new AppMeshDeleteVirtualGatewayVirtualGatewaySpecLoggingAccessLog(this, 'AccessLog', this.__resources, this.input);
  }

}

export class AppMeshDeleteVirtualGatewayVirtualGatewaySpecLoggingAccessLog extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualGatewayInput) {
    super(scope, id);
  }

  public get file(): AppMeshDeleteVirtualGatewayVirtualGatewaySpecLoggingAccessLogFile {
    return new AppMeshDeleteVirtualGatewayVirtualGatewaySpecLoggingAccessLogFile(this, 'File', this.__resources, this.input);
  }

}

export class AppMeshDeleteVirtualGatewayVirtualGatewaySpecLoggingAccessLogFile extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualGatewayInput) {
    super(scope, id);
  }

  public get path(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.spec.logging.accessLog.file.path'),
        outputPath: 'virtualGateway.spec.logging.accessLog.file.path',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualGateway.virtualGateway.spec.logging.accessLog.file.path', props);
    return resource.getResponseField('virtualGateway.spec.logging.accessLog.file.path') as unknown as string;
  }

}

export class AppMeshDeleteVirtualGatewayVirtualGatewayStatus extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualGatewayInput) {
    super(scope, id);
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.status.status'),
        outputPath: 'virtualGateway.status.status',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualGateway.virtualGateway.status.status', props);
    return resource.getResponseField('virtualGateway.status.status') as unknown as string;
  }

}

export class AppMeshDeleteVirtualNode extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualNodeInput) {
    super(scope, id);
  }

  public get virtualNode(): AppMeshDeleteVirtualNodeVirtualNode {
    return new AppMeshDeleteVirtualNodeVirtualNode(this, 'VirtualNode', this.__resources, this.input);
  }

}

export class AppMeshDeleteVirtualNodeVirtualNode extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualNodeInput) {
    super(scope, id);
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.meshName'),
        outputPath: 'virtualNode.meshName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualNode.virtualNode.meshName', props);
    return resource.getResponseField('virtualNode.meshName') as unknown as string;
  }

  public get metadata(): AppMeshDeleteVirtualNodeVirtualNodeMetadata {
    return new AppMeshDeleteVirtualNodeVirtualNodeMetadata(this, 'Metadata', this.__resources, this.input);
  }

  public get spec(): AppMeshDeleteVirtualNodeVirtualNodeSpec {
    return new AppMeshDeleteVirtualNodeVirtualNodeSpec(this, 'Spec', this.__resources, this.input);
  }

  public get status(): AppMeshDeleteVirtualNodeVirtualNodeStatus {
    return new AppMeshDeleteVirtualNodeVirtualNodeStatus(this, 'Status', this.__resources, this.input);
  }

  public get virtualNodeName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.virtualNodeName'),
        outputPath: 'virtualNode.virtualNodeName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualNode.virtualNode.virtualNodeName', props);
    return resource.getResponseField('virtualNode.virtualNodeName') as unknown as string;
  }

}

export class AppMeshDeleteVirtualNodeVirtualNodeMetadata extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualNodeInput) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.metadata.arn'),
        outputPath: 'virtualNode.metadata.arn',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualNode.virtualNode.metadata.arn', props);
    return resource.getResponseField('virtualNode.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.metadata.createdAt'),
        outputPath: 'virtualNode.metadata.createdAt',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualNode.virtualNode.metadata.createdAt', props);
    return resource.getResponseField('virtualNode.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.metadata.lastUpdatedAt'),
        outputPath: 'virtualNode.metadata.lastUpdatedAt',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualNode.virtualNode.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualNode.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.metadata.meshOwner'),
        outputPath: 'virtualNode.metadata.meshOwner',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualNode.virtualNode.metadata.meshOwner', props);
    return resource.getResponseField('virtualNode.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.metadata.resourceOwner'),
        outputPath: 'virtualNode.metadata.resourceOwner',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualNode.virtualNode.metadata.resourceOwner', props);
    return resource.getResponseField('virtualNode.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.metadata.uid'),
        outputPath: 'virtualNode.metadata.uid',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualNode.virtualNode.metadata.uid', props);
    return resource.getResponseField('virtualNode.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.metadata.version'),
        outputPath: 'virtualNode.metadata.version',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualNode.virtualNode.metadata.version', props);
    return resource.getResponseField('virtualNode.metadata.version') as unknown as number;
  }

}

export class AppMeshDeleteVirtualNodeVirtualNodeSpec extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualNodeInput) {
    super(scope, id);
  }

  public get backendDefaults(): AppMeshDeleteVirtualNodeVirtualNodeSpecBackendDefaults {
    return new AppMeshDeleteVirtualNodeVirtualNodeSpecBackendDefaults(this, 'BackendDefaults', this.__resources, this.input);
  }

  public get backends(): shapes.AppMeshBackend[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.spec.backends'),
        outputPath: 'virtualNode.spec.backends',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualNode.virtualNode.spec.backends', props);
    return resource.getResponseField('virtualNode.spec.backends') as unknown as shapes.AppMeshBackend[];
  }

  public get listeners(): shapes.AppMeshListener[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.spec.listeners'),
        outputPath: 'virtualNode.spec.listeners',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualNode.virtualNode.spec.listeners', props);
    return resource.getResponseField('virtualNode.spec.listeners') as unknown as shapes.AppMeshListener[];
  }

  public get logging(): AppMeshDeleteVirtualNodeVirtualNodeSpecLogging {
    return new AppMeshDeleteVirtualNodeVirtualNodeSpecLogging(this, 'Logging', this.__resources, this.input);
  }

  public get serviceDiscovery(): AppMeshDeleteVirtualNodeVirtualNodeSpecServiceDiscovery {
    return new AppMeshDeleteVirtualNodeVirtualNodeSpecServiceDiscovery(this, 'ServiceDiscovery', this.__resources, this.input);
  }

}

export class AppMeshDeleteVirtualNodeVirtualNodeSpecBackendDefaults extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualNodeInput) {
    super(scope, id);
  }

  public get clientPolicy(): AppMeshDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicy {
    return new AppMeshDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicy(this, 'ClientPolicy', this.__resources, this.input);
  }

}

export class AppMeshDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicy extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualNodeInput) {
    super(scope, id);
  }

  public get tls(): AppMeshDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTls {
    return new AppMeshDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTls(this, 'Tls', this.__resources, this.input);
  }

}

export class AppMeshDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTls extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualNodeInput) {
    super(scope, id);
  }

  public get enforce(): boolean {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.enforce'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.enforce',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.enforce', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.enforce') as unknown as boolean;
  }

  public get ports(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.ports'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.ports',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.ports', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.ports') as unknown as number[];
  }

  public get validation(): AppMeshDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidation {
    return new AppMeshDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidation(this, 'Validation', this.__resources, this.input);
  }

}

export class AppMeshDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidation extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualNodeInput) {
    super(scope, id);
  }

  public get trust(): AppMeshDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust {
    return new AppMeshDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust(this, 'Trust', this.__resources, this.input);
  }

}

export class AppMeshDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualNodeInput) {
    super(scope, id);
  }

  public get acm(): AppMeshDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
    return new AppMeshDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm(this, 'Acm', this.__resources, this.input);
  }

  public get file(): AppMeshDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile {
    return new AppMeshDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile(this, 'File', this.__resources, this.input);
  }

}

export class AppMeshDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualNodeInput) {
    super(scope, id);
  }

  public get certificateAuthorityArns(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns') as unknown as string[];
  }

}

export class AppMeshDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualNodeInput) {
    super(scope, id);
  }

  public get certificateChain(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain') as unknown as string;
  }

}

export class AppMeshDeleteVirtualNodeVirtualNodeSpecLogging extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualNodeInput) {
    super(scope, id);
  }

  public get accessLog(): AppMeshDeleteVirtualNodeVirtualNodeSpecLoggingAccessLog {
    return new AppMeshDeleteVirtualNodeVirtualNodeSpecLoggingAccessLog(this, 'AccessLog', this.__resources, this.input);
  }

}

export class AppMeshDeleteVirtualNodeVirtualNodeSpecLoggingAccessLog extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualNodeInput) {
    super(scope, id);
  }

  public get file(): AppMeshDeleteVirtualNodeVirtualNodeSpecLoggingAccessLogFile {
    return new AppMeshDeleteVirtualNodeVirtualNodeSpecLoggingAccessLogFile(this, 'File', this.__resources, this.input);
  }

}

export class AppMeshDeleteVirtualNodeVirtualNodeSpecLoggingAccessLogFile extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualNodeInput) {
    super(scope, id);
  }

  public get path(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.spec.logging.accessLog.file.path'),
        outputPath: 'virtualNode.spec.logging.accessLog.file.path',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualNode.virtualNode.spec.logging.accessLog.file.path', props);
    return resource.getResponseField('virtualNode.spec.logging.accessLog.file.path') as unknown as string;
  }

}

export class AppMeshDeleteVirtualNodeVirtualNodeSpecServiceDiscovery extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualNodeInput) {
    super(scope, id);
  }

  public get awsCloudMap(): AppMeshDeleteVirtualNodeVirtualNodeSpecServiceDiscoveryAwsCloudMap {
    return new AppMeshDeleteVirtualNodeVirtualNodeSpecServiceDiscoveryAwsCloudMap(this, 'AwsCloudMap', this.__resources, this.input);
  }

  public get dns(): AppMeshDeleteVirtualNodeVirtualNodeSpecServiceDiscoveryDns {
    return new AppMeshDeleteVirtualNodeVirtualNodeSpecServiceDiscoveryDns(this, 'Dns', this.__resources, this.input);
  }

}

export class AppMeshDeleteVirtualNodeVirtualNodeSpecServiceDiscoveryAwsCloudMap extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualNodeInput) {
    super(scope, id);
  }

  public get attributes(): shapes.AppMeshAwsCloudMapInstanceAttribute[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.attributes'),
        outputPath: 'virtualNode.spec.serviceDiscovery.awsCloudMap.attributes',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.attributes', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.awsCloudMap.attributes') as unknown as shapes.AppMeshAwsCloudMapInstanceAttribute[];
  }

  public get namespaceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName'),
        outputPath: 'virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName') as unknown as string;
  }

  public get serviceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName'),
        outputPath: 'virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName') as unknown as string;
  }

}

export class AppMeshDeleteVirtualNodeVirtualNodeSpecServiceDiscoveryDns extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualNodeInput) {
    super(scope, id);
  }

  public get hostname(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.spec.serviceDiscovery.dns.hostname'),
        outputPath: 'virtualNode.spec.serviceDiscovery.dns.hostname',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualNode.virtualNode.spec.serviceDiscovery.dns.hostname', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.dns.hostname') as unknown as string;
  }

}

export class AppMeshDeleteVirtualNodeVirtualNodeStatus extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualNodeInput) {
    super(scope, id);
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.status.status'),
        outputPath: 'virtualNode.status.status',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualNode.virtualNode.status.status', props);
    return resource.getResponseField('virtualNode.status.status') as unknown as string;
  }

}

export class AppMeshDeleteVirtualRouter extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualRouterInput) {
    super(scope, id);
  }

  public get virtualRouter(): AppMeshDeleteVirtualRouterVirtualRouter {
    return new AppMeshDeleteVirtualRouterVirtualRouter(this, 'VirtualRouter', this.__resources, this.input);
  }

}

export class AppMeshDeleteVirtualRouterVirtualRouter extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualRouterInput) {
    super(scope, id);
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualRouter.virtualRouter.meshName'),
        outputPath: 'virtualRouter.meshName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualRouter.virtualRouter.meshName', props);
    return resource.getResponseField('virtualRouter.meshName') as unknown as string;
  }

  public get metadata(): AppMeshDeleteVirtualRouterVirtualRouterMetadata {
    return new AppMeshDeleteVirtualRouterVirtualRouterMetadata(this, 'Metadata', this.__resources, this.input);
  }

  public get spec(): AppMeshDeleteVirtualRouterVirtualRouterSpec {
    return new AppMeshDeleteVirtualRouterVirtualRouterSpec(this, 'Spec', this.__resources, this.input);
  }

  public get status(): AppMeshDeleteVirtualRouterVirtualRouterStatus {
    return new AppMeshDeleteVirtualRouterVirtualRouterStatus(this, 'Status', this.__resources, this.input);
  }

  public get virtualRouterName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualRouter.virtualRouter.virtualRouterName'),
        outputPath: 'virtualRouter.virtualRouterName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualRouter.virtualRouter.virtualRouterName', props);
    return resource.getResponseField('virtualRouter.virtualRouterName') as unknown as string;
  }

}

export class AppMeshDeleteVirtualRouterVirtualRouterMetadata extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualRouterInput) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualRouter.virtualRouter.metadata.arn'),
        outputPath: 'virtualRouter.metadata.arn',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualRouter.virtualRouter.metadata.arn', props);
    return resource.getResponseField('virtualRouter.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualRouter.virtualRouter.metadata.createdAt'),
        outputPath: 'virtualRouter.metadata.createdAt',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualRouter.virtualRouter.metadata.createdAt', props);
    return resource.getResponseField('virtualRouter.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualRouter.virtualRouter.metadata.lastUpdatedAt'),
        outputPath: 'virtualRouter.metadata.lastUpdatedAt',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualRouter.virtualRouter.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualRouter.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualRouter.virtualRouter.metadata.meshOwner'),
        outputPath: 'virtualRouter.metadata.meshOwner',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualRouter.virtualRouter.metadata.meshOwner', props);
    return resource.getResponseField('virtualRouter.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualRouter.virtualRouter.metadata.resourceOwner'),
        outputPath: 'virtualRouter.metadata.resourceOwner',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualRouter.virtualRouter.metadata.resourceOwner', props);
    return resource.getResponseField('virtualRouter.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualRouter.virtualRouter.metadata.uid'),
        outputPath: 'virtualRouter.metadata.uid',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualRouter.virtualRouter.metadata.uid', props);
    return resource.getResponseField('virtualRouter.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualRouter.virtualRouter.metadata.version'),
        outputPath: 'virtualRouter.metadata.version',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualRouter.virtualRouter.metadata.version', props);
    return resource.getResponseField('virtualRouter.metadata.version') as unknown as number;
  }

}

export class AppMeshDeleteVirtualRouterVirtualRouterSpec extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualRouterInput) {
    super(scope, id);
  }

  public get listeners(): shapes.AppMeshVirtualRouterListener[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualRouter.virtualRouter.spec.listeners'),
        outputPath: 'virtualRouter.spec.listeners',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualRouter.virtualRouter.spec.listeners', props);
    return resource.getResponseField('virtualRouter.spec.listeners') as unknown as shapes.AppMeshVirtualRouterListener[];
  }

}

export class AppMeshDeleteVirtualRouterVirtualRouterStatus extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualRouterInput) {
    super(scope, id);
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualRouter.virtualRouter.status.status'),
        outputPath: 'virtualRouter.status.status',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualRouter.virtualRouter.status.status', props);
    return resource.getResponseField('virtualRouter.status.status') as unknown as string;
  }

}

export class AppMeshDeleteVirtualService extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualServiceInput) {
    super(scope, id);
  }

  public get virtualService(): AppMeshDeleteVirtualServiceVirtualService {
    return new AppMeshDeleteVirtualServiceVirtualService(this, 'VirtualService', this.__resources, this.input);
  }

}

export class AppMeshDeleteVirtualServiceVirtualService extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualServiceInput) {
    super(scope, id);
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualService.virtualService.meshName'),
        outputPath: 'virtualService.meshName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualService.virtualService.meshName', props);
    return resource.getResponseField('virtualService.meshName') as unknown as string;
  }

  public get metadata(): AppMeshDeleteVirtualServiceVirtualServiceMetadata {
    return new AppMeshDeleteVirtualServiceVirtualServiceMetadata(this, 'Metadata', this.__resources, this.input);
  }

  public get spec(): AppMeshDeleteVirtualServiceVirtualServiceSpec {
    return new AppMeshDeleteVirtualServiceVirtualServiceSpec(this, 'Spec', this.__resources, this.input);
  }

  public get status(): AppMeshDeleteVirtualServiceVirtualServiceStatus {
    return new AppMeshDeleteVirtualServiceVirtualServiceStatus(this, 'Status', this.__resources, this.input);
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualService.virtualService.virtualServiceName'),
        outputPath: 'virtualService.virtualServiceName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualService.virtualService.virtualServiceName', props);
    return resource.getResponseField('virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshDeleteVirtualServiceVirtualServiceMetadata extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualServiceInput) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualService.virtualService.metadata.arn'),
        outputPath: 'virtualService.metadata.arn',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualService.virtualService.metadata.arn', props);
    return resource.getResponseField('virtualService.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualService.virtualService.metadata.createdAt'),
        outputPath: 'virtualService.metadata.createdAt',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualService.virtualService.metadata.createdAt', props);
    return resource.getResponseField('virtualService.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualService.virtualService.metadata.lastUpdatedAt'),
        outputPath: 'virtualService.metadata.lastUpdatedAt',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualService.virtualService.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualService.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualService.virtualService.metadata.meshOwner'),
        outputPath: 'virtualService.metadata.meshOwner',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualService.virtualService.metadata.meshOwner', props);
    return resource.getResponseField('virtualService.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualService.virtualService.metadata.resourceOwner'),
        outputPath: 'virtualService.metadata.resourceOwner',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualService.virtualService.metadata.resourceOwner', props);
    return resource.getResponseField('virtualService.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualService.virtualService.metadata.uid'),
        outputPath: 'virtualService.metadata.uid',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualService.virtualService.metadata.uid', props);
    return resource.getResponseField('virtualService.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualService.virtualService.metadata.version'),
        outputPath: 'virtualService.metadata.version',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualService.virtualService.metadata.version', props);
    return resource.getResponseField('virtualService.metadata.version') as unknown as number;
  }

}

export class AppMeshDeleteVirtualServiceVirtualServiceSpec extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualServiceInput) {
    super(scope, id);
  }

  public get provider(): AppMeshDeleteVirtualServiceVirtualServiceSpecProvider {
    return new AppMeshDeleteVirtualServiceVirtualServiceSpecProvider(this, 'Provider', this.__resources, this.input);
  }

}

export class AppMeshDeleteVirtualServiceVirtualServiceSpecProvider extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualServiceInput) {
    super(scope, id);
  }

  public get virtualNode(): AppMeshDeleteVirtualServiceVirtualServiceSpecProviderVirtualNode {
    return new AppMeshDeleteVirtualServiceVirtualServiceSpecProviderVirtualNode(this, 'VirtualNode', this.__resources, this.input);
  }

  public get virtualRouter(): AppMeshDeleteVirtualServiceVirtualServiceSpecProviderVirtualRouter {
    return new AppMeshDeleteVirtualServiceVirtualServiceSpecProviderVirtualRouter(this, 'VirtualRouter', this.__resources, this.input);
  }

}

export class AppMeshDeleteVirtualServiceVirtualServiceSpecProviderVirtualNode extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualServiceInput) {
    super(scope, id);
  }

  public get virtualNodeName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualService.virtualService.spec.provider.virtualNode.virtualNodeName'),
        outputPath: 'virtualService.spec.provider.virtualNode.virtualNodeName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualService.virtualService.spec.provider.virtualNode.virtualNodeName', props);
    return resource.getResponseField('virtualService.spec.provider.virtualNode.virtualNodeName') as unknown as string;
  }

}

export class AppMeshDeleteVirtualServiceVirtualServiceSpecProviderVirtualRouter extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualServiceInput) {
    super(scope, id);
  }

  public get virtualRouterName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualService.virtualService.spec.provider.virtualRouter.virtualRouterName'),
        outputPath: 'virtualService.spec.provider.virtualRouter.virtualRouterName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualService.virtualService.spec.provider.virtualRouter.virtualRouterName', props);
    return resource.getResponseField('virtualService.spec.provider.virtualRouter.virtualRouterName') as unknown as string;
  }

}

export class AppMeshDeleteVirtualServiceVirtualServiceStatus extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDeleteVirtualServiceInput) {
    super(scope, id);
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualService.virtualService.status.status'),
        outputPath: 'virtualService.status.status',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteVirtualService.virtualService.status.status', props);
    return resource.getResponseField('virtualService.status.status') as unknown as string;
  }

}

export class AppMeshDescribeGatewayRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeGatewayRouteInput) {
    super(scope, id);
  }

  public get gatewayRoute(): AppMeshDescribeGatewayRouteGatewayRoute {
    return new AppMeshDescribeGatewayRouteGatewayRoute(this, 'GatewayRoute', this.__resources, this.input);
  }

}

export class AppMeshDescribeGatewayRouteGatewayRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeGatewayRouteInput) {
    super(scope, id);
  }

  public get gatewayRouteName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.gatewayRouteName'),
        outputPath: 'gatewayRoute.gatewayRouteName',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeGatewayRoute.gatewayRoute.gatewayRouteName', props);
    return resource.getResponseField('gatewayRoute.gatewayRouteName') as unknown as string;
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.meshName'),
        outputPath: 'gatewayRoute.meshName',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeGatewayRoute.gatewayRoute.meshName', props);
    return resource.getResponseField('gatewayRoute.meshName') as unknown as string;
  }

  public get metadata(): AppMeshDescribeGatewayRouteGatewayRouteMetadata {
    return new AppMeshDescribeGatewayRouteGatewayRouteMetadata(this, 'Metadata', this.__resources, this.input);
  }

  public get spec(): AppMeshDescribeGatewayRouteGatewayRouteSpec {
    return new AppMeshDescribeGatewayRouteGatewayRouteSpec(this, 'Spec', this.__resources, this.input);
  }

  public get status(): AppMeshDescribeGatewayRouteGatewayRouteStatus {
    return new AppMeshDescribeGatewayRouteGatewayRouteStatus(this, 'Status', this.__resources, this.input);
  }

  public get virtualGatewayName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.virtualGatewayName'),
        outputPath: 'gatewayRoute.virtualGatewayName',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeGatewayRoute.gatewayRoute.virtualGatewayName', props);
    return resource.getResponseField('gatewayRoute.virtualGatewayName') as unknown as string;
  }

}

export class AppMeshDescribeGatewayRouteGatewayRouteMetadata extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeGatewayRouteInput) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.metadata.arn'),
        outputPath: 'gatewayRoute.metadata.arn',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeGatewayRoute.gatewayRoute.metadata.arn', props);
    return resource.getResponseField('gatewayRoute.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.metadata.createdAt'),
        outputPath: 'gatewayRoute.metadata.createdAt',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeGatewayRoute.gatewayRoute.metadata.createdAt', props);
    return resource.getResponseField('gatewayRoute.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.metadata.lastUpdatedAt'),
        outputPath: 'gatewayRoute.metadata.lastUpdatedAt',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeGatewayRoute.gatewayRoute.metadata.lastUpdatedAt', props);
    return resource.getResponseField('gatewayRoute.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.metadata.meshOwner'),
        outputPath: 'gatewayRoute.metadata.meshOwner',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeGatewayRoute.gatewayRoute.metadata.meshOwner', props);
    return resource.getResponseField('gatewayRoute.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.metadata.resourceOwner'),
        outputPath: 'gatewayRoute.metadata.resourceOwner',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeGatewayRoute.gatewayRoute.metadata.resourceOwner', props);
    return resource.getResponseField('gatewayRoute.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.metadata.uid'),
        outputPath: 'gatewayRoute.metadata.uid',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeGatewayRoute.gatewayRoute.metadata.uid', props);
    return resource.getResponseField('gatewayRoute.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.metadata.version'),
        outputPath: 'gatewayRoute.metadata.version',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeGatewayRoute.gatewayRoute.metadata.version', props);
    return resource.getResponseField('gatewayRoute.metadata.version') as unknown as number;
  }

}

export class AppMeshDescribeGatewayRouteGatewayRouteSpec extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeGatewayRouteInput) {
    super(scope, id);
  }

  public get grpcRoute(): AppMeshDescribeGatewayRouteGatewayRouteSpecGrpcRoute {
    return new AppMeshDescribeGatewayRouteGatewayRouteSpecGrpcRoute(this, 'GrpcRoute', this.__resources, this.input);
  }

  public get http2Route(): AppMeshDescribeGatewayRouteGatewayRouteSpecHttp2Route {
    return new AppMeshDescribeGatewayRouteGatewayRouteSpecHttp2Route(this, 'Http2Route', this.__resources, this.input);
  }

  public get httpRoute(): AppMeshDescribeGatewayRouteGatewayRouteSpecHttpRoute {
    return new AppMeshDescribeGatewayRouteGatewayRouteSpecHttpRoute(this, 'HttpRoute', this.__resources, this.input);
  }

}

export class AppMeshDescribeGatewayRouteGatewayRouteSpecGrpcRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeGatewayRouteInput) {
    super(scope, id);
  }

  public get action(): AppMeshDescribeGatewayRouteGatewayRouteSpecGrpcRouteAction {
    return new AppMeshDescribeGatewayRouteGatewayRouteSpecGrpcRouteAction(this, 'Action', this.__resources, this.input);
  }

  public get match(): AppMeshDescribeGatewayRouteGatewayRouteSpecGrpcRouteMatch {
    return new AppMeshDescribeGatewayRouteGatewayRouteSpecGrpcRouteMatch(this, 'Match', this.__resources, this.input);
  }

}

export class AppMeshDescribeGatewayRouteGatewayRouteSpecGrpcRouteAction extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeGatewayRouteInput) {
    super(scope, id);
  }

  public get target(): AppMeshDescribeGatewayRouteGatewayRouteSpecGrpcRouteActionTarget {
    return new AppMeshDescribeGatewayRouteGatewayRouteSpecGrpcRouteActionTarget(this, 'Target', this.__resources, this.input);
  }

}

export class AppMeshDescribeGatewayRouteGatewayRouteSpecGrpcRouteActionTarget extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeGatewayRouteInput) {
    super(scope, id);
  }

  public get virtualService(): AppMeshDescribeGatewayRouteGatewayRouteSpecGrpcRouteActionTargetVirtualService {
    return new AppMeshDescribeGatewayRouteGatewayRouteSpecGrpcRouteActionTargetVirtualService(this, 'VirtualService', this.__resources, this.input);
  }

}

export class AppMeshDescribeGatewayRouteGatewayRouteSpecGrpcRouteActionTargetVirtualService extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeGatewayRouteInput) {
    super(scope, id);
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName'),
        outputPath: 'gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeGatewayRoute.gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName', props);
    return resource.getResponseField('gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshDescribeGatewayRouteGatewayRouteSpecGrpcRouteMatch extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeGatewayRouteInput) {
    super(scope, id);
  }

  public get serviceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.spec.grpcRoute.match.serviceName'),
        outputPath: 'gatewayRoute.spec.grpcRoute.match.serviceName',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeGatewayRoute.gatewayRoute.spec.grpcRoute.match.serviceName', props);
    return resource.getResponseField('gatewayRoute.spec.grpcRoute.match.serviceName') as unknown as string;
  }

}

export class AppMeshDescribeGatewayRouteGatewayRouteSpecHttp2Route extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeGatewayRouteInput) {
    super(scope, id);
  }

  public get action(): AppMeshDescribeGatewayRouteGatewayRouteSpecHttp2RouteAction {
    return new AppMeshDescribeGatewayRouteGatewayRouteSpecHttp2RouteAction(this, 'Action', this.__resources, this.input);
  }

  public get match(): AppMeshDescribeGatewayRouteGatewayRouteSpecHttp2RouteMatch {
    return new AppMeshDescribeGatewayRouteGatewayRouteSpecHttp2RouteMatch(this, 'Match', this.__resources, this.input);
  }

}

export class AppMeshDescribeGatewayRouteGatewayRouteSpecHttp2RouteAction extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeGatewayRouteInput) {
    super(scope, id);
  }

  public get target(): AppMeshDescribeGatewayRouteGatewayRouteSpecHttp2RouteActionTarget {
    return new AppMeshDescribeGatewayRouteGatewayRouteSpecHttp2RouteActionTarget(this, 'Target', this.__resources, this.input);
  }

}

export class AppMeshDescribeGatewayRouteGatewayRouteSpecHttp2RouteActionTarget extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeGatewayRouteInput) {
    super(scope, id);
  }

  public get virtualService(): AppMeshDescribeGatewayRouteGatewayRouteSpecHttp2RouteActionTargetVirtualService {
    return new AppMeshDescribeGatewayRouteGatewayRouteSpecHttp2RouteActionTargetVirtualService(this, 'VirtualService', this.__resources, this.input);
  }

}

export class AppMeshDescribeGatewayRouteGatewayRouteSpecHttp2RouteActionTargetVirtualService extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeGatewayRouteInput) {
    super(scope, id);
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName'),
        outputPath: 'gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeGatewayRoute.gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName', props);
    return resource.getResponseField('gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshDescribeGatewayRouteGatewayRouteSpecHttp2RouteMatch extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeGatewayRouteInput) {
    super(scope, id);
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.spec.http2Route.match.prefix'),
        outputPath: 'gatewayRoute.spec.http2Route.match.prefix',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeGatewayRoute.gatewayRoute.spec.http2Route.match.prefix', props);
    return resource.getResponseField('gatewayRoute.spec.http2Route.match.prefix') as unknown as string;
  }

}

export class AppMeshDescribeGatewayRouteGatewayRouteSpecHttpRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeGatewayRouteInput) {
    super(scope, id);
  }

  public get action(): AppMeshDescribeGatewayRouteGatewayRouteSpecHttpRouteAction {
    return new AppMeshDescribeGatewayRouteGatewayRouteSpecHttpRouteAction(this, 'Action', this.__resources, this.input);
  }

  public get match(): AppMeshDescribeGatewayRouteGatewayRouteSpecHttpRouteMatch {
    return new AppMeshDescribeGatewayRouteGatewayRouteSpecHttpRouteMatch(this, 'Match', this.__resources, this.input);
  }

}

export class AppMeshDescribeGatewayRouteGatewayRouteSpecHttpRouteAction extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeGatewayRouteInput) {
    super(scope, id);
  }

  public get target(): AppMeshDescribeGatewayRouteGatewayRouteSpecHttpRouteActionTarget {
    return new AppMeshDescribeGatewayRouteGatewayRouteSpecHttpRouteActionTarget(this, 'Target', this.__resources, this.input);
  }

}

export class AppMeshDescribeGatewayRouteGatewayRouteSpecHttpRouteActionTarget extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeGatewayRouteInput) {
    super(scope, id);
  }

  public get virtualService(): AppMeshDescribeGatewayRouteGatewayRouteSpecHttpRouteActionTargetVirtualService {
    return new AppMeshDescribeGatewayRouteGatewayRouteSpecHttpRouteActionTargetVirtualService(this, 'VirtualService', this.__resources, this.input);
  }

}

export class AppMeshDescribeGatewayRouteGatewayRouteSpecHttpRouteActionTargetVirtualService extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeGatewayRouteInput) {
    super(scope, id);
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName'),
        outputPath: 'gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeGatewayRoute.gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName', props);
    return resource.getResponseField('gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshDescribeGatewayRouteGatewayRouteSpecHttpRouteMatch extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeGatewayRouteInput) {
    super(scope, id);
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.spec.httpRoute.match.prefix'),
        outputPath: 'gatewayRoute.spec.httpRoute.match.prefix',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeGatewayRoute.gatewayRoute.spec.httpRoute.match.prefix', props);
    return resource.getResponseField('gatewayRoute.spec.httpRoute.match.prefix') as unknown as string;
  }

}

export class AppMeshDescribeGatewayRouteGatewayRouteStatus extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeGatewayRouteInput) {
    super(scope, id);
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.status.status'),
        outputPath: 'gatewayRoute.status.status',
        parameters: {
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeGatewayRoute.gatewayRoute.status.status', props);
    return resource.getResponseField('gatewayRoute.status.status') as unknown as string;
  }

}

export class AppMeshDescribeMesh extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeMeshInput) {
    super(scope, id);
  }

  public get mesh(): AppMeshDescribeMeshMesh {
    return new AppMeshDescribeMeshMesh(this, 'Mesh', this.__resources, this.input);
  }

}

export class AppMeshDescribeMeshMesh extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeMeshInput) {
    super(scope, id);
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeMesh.mesh.meshName'),
        outputPath: 'mesh.meshName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMesh.mesh.meshName', props);
    return resource.getResponseField('mesh.meshName') as unknown as string;
  }

  public get metadata(): AppMeshDescribeMeshMeshMetadata {
    return new AppMeshDescribeMeshMeshMetadata(this, 'Metadata', this.__resources, this.input);
  }

  public get spec(): AppMeshDescribeMeshMeshSpec {
    return new AppMeshDescribeMeshMeshSpec(this, 'Spec', this.__resources, this.input);
  }

  public get status(): AppMeshDescribeMeshMeshStatus {
    return new AppMeshDescribeMeshMeshStatus(this, 'Status', this.__resources, this.input);
  }

}

export class AppMeshDescribeMeshMeshMetadata extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeMeshInput) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeMesh.mesh.metadata.arn'),
        outputPath: 'mesh.metadata.arn',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMesh.mesh.metadata.arn', props);
    return resource.getResponseField('mesh.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeMesh.mesh.metadata.createdAt'),
        outputPath: 'mesh.metadata.createdAt',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMesh.mesh.metadata.createdAt', props);
    return resource.getResponseField('mesh.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeMesh.mesh.metadata.lastUpdatedAt'),
        outputPath: 'mesh.metadata.lastUpdatedAt',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMesh.mesh.metadata.lastUpdatedAt', props);
    return resource.getResponseField('mesh.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeMesh.mesh.metadata.meshOwner'),
        outputPath: 'mesh.metadata.meshOwner',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMesh.mesh.metadata.meshOwner', props);
    return resource.getResponseField('mesh.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeMesh.mesh.metadata.resourceOwner'),
        outputPath: 'mesh.metadata.resourceOwner',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMesh.mesh.metadata.resourceOwner', props);
    return resource.getResponseField('mesh.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeMesh.mesh.metadata.uid'),
        outputPath: 'mesh.metadata.uid',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMesh.mesh.metadata.uid', props);
    return resource.getResponseField('mesh.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeMesh.mesh.metadata.version'),
        outputPath: 'mesh.metadata.version',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMesh.mesh.metadata.version', props);
    return resource.getResponseField('mesh.metadata.version') as unknown as number;
  }

}

export class AppMeshDescribeMeshMeshSpec extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeMeshInput) {
    super(scope, id);
  }

  public get egressFilter(): AppMeshDescribeMeshMeshSpecEgressFilter {
    return new AppMeshDescribeMeshMeshSpecEgressFilter(this, 'EgressFilter', this.__resources, this.input);
  }

}

export class AppMeshDescribeMeshMeshSpecEgressFilter extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeMeshInput) {
    super(scope, id);
  }

  public get type(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeMesh.mesh.spec.egressFilter.type'),
        outputPath: 'mesh.spec.egressFilter.type',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMesh.mesh.spec.egressFilter.type', props);
    return resource.getResponseField('mesh.spec.egressFilter.type') as unknown as string;
  }

}

export class AppMeshDescribeMeshMeshStatus extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeMeshInput) {
    super(scope, id);
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeMesh.mesh.status.status'),
        outputPath: 'mesh.status.status',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMesh.mesh.status.status', props);
    return resource.getResponseField('mesh.status.status') as unknown as string;
  }

}

export class AppMeshDescribeRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get route(): AppMeshDescribeRouteRoute {
    return new AppMeshDescribeRouteRoute(this, 'Route', this.__resources, this.input);
  }

}

export class AppMeshDescribeRouteRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.meshName'),
        outputPath: 'route.meshName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.meshName', props);
    return resource.getResponseField('route.meshName') as unknown as string;
  }

  public get metadata(): AppMeshDescribeRouteRouteMetadata {
    return new AppMeshDescribeRouteRouteMetadata(this, 'Metadata', this.__resources, this.input);
  }

  public get routeName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.routeName'),
        outputPath: 'route.routeName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.routeName', props);
    return resource.getResponseField('route.routeName') as unknown as string;
  }

  public get spec(): AppMeshDescribeRouteRouteSpec {
    return new AppMeshDescribeRouteRouteSpec(this, 'Spec', this.__resources, this.input);
  }

  public get status(): AppMeshDescribeRouteRouteStatus {
    return new AppMeshDescribeRouteRouteStatus(this, 'Status', this.__resources, this.input);
  }

  public get virtualRouterName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.virtualRouterName'),
        outputPath: 'route.virtualRouterName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.virtualRouterName', props);
    return resource.getResponseField('route.virtualRouterName') as unknown as string;
  }

}

export class AppMeshDescribeRouteRouteMetadata extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.metadata.arn'),
        outputPath: 'route.metadata.arn',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.metadata.arn', props);
    return resource.getResponseField('route.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.metadata.createdAt'),
        outputPath: 'route.metadata.createdAt',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.metadata.createdAt', props);
    return resource.getResponseField('route.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.metadata.lastUpdatedAt'),
        outputPath: 'route.metadata.lastUpdatedAt',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.metadata.lastUpdatedAt', props);
    return resource.getResponseField('route.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.metadata.meshOwner'),
        outputPath: 'route.metadata.meshOwner',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.metadata.meshOwner', props);
    return resource.getResponseField('route.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.metadata.resourceOwner'),
        outputPath: 'route.metadata.resourceOwner',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.metadata.resourceOwner', props);
    return resource.getResponseField('route.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.metadata.uid'),
        outputPath: 'route.metadata.uid',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.metadata.uid', props);
    return resource.getResponseField('route.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.metadata.version'),
        outputPath: 'route.metadata.version',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.metadata.version', props);
    return resource.getResponseField('route.metadata.version') as unknown as number;
  }

}

export class AppMeshDescribeRouteRouteSpec extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get grpcRoute(): AppMeshDescribeRouteRouteSpecGrpcRoute {
    return new AppMeshDescribeRouteRouteSpecGrpcRoute(this, 'GrpcRoute', this.__resources, this.input);
  }

  public get http2Route(): AppMeshDescribeRouteRouteSpecHttp2Route {
    return new AppMeshDescribeRouteRouteSpecHttp2Route(this, 'Http2Route', this.__resources, this.input);
  }

  public get httpRoute(): AppMeshDescribeRouteRouteSpecHttpRoute {
    return new AppMeshDescribeRouteRouteSpecHttpRoute(this, 'HttpRoute', this.__resources, this.input);
  }

  public get priority(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.priority'),
        outputPath: 'route.spec.priority',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.priority', props);
    return resource.getResponseField('route.spec.priority') as unknown as number;
  }

  public get tcpRoute(): AppMeshDescribeRouteRouteSpecTcpRoute {
    return new AppMeshDescribeRouteRouteSpecTcpRoute(this, 'TcpRoute', this.__resources, this.input);
  }

}

export class AppMeshDescribeRouteRouteSpecGrpcRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get action(): AppMeshDescribeRouteRouteSpecGrpcRouteAction {
    return new AppMeshDescribeRouteRouteSpecGrpcRouteAction(this, 'Action', this.__resources, this.input);
  }

  public get match(): AppMeshDescribeRouteRouteSpecGrpcRouteMatch {
    return new AppMeshDescribeRouteRouteSpecGrpcRouteMatch(this, 'Match', this.__resources, this.input);
  }

  public get retryPolicy(): AppMeshDescribeRouteRouteSpecGrpcRouteRetryPolicy {
    return new AppMeshDescribeRouteRouteSpecGrpcRouteRetryPolicy(this, 'RetryPolicy', this.__resources, this.input);
  }

  public get timeout(): AppMeshDescribeRouteRouteSpecGrpcRouteTimeout {
    return new AppMeshDescribeRouteRouteSpecGrpcRouteTimeout(this, 'Timeout', this.__resources, this.input);
  }

}

export class AppMeshDescribeRouteRouteSpecGrpcRouteAction extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.grpcRoute.action.weightedTargets'),
        outputPath: 'route.spec.grpcRoute.action.weightedTargets',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.grpcRoute.action.weightedTargets', props);
    return resource.getResponseField('route.spec.grpcRoute.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshDescribeRouteRouteSpecGrpcRouteMatch extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get metadata(): shapes.AppMeshGrpcRouteMetadata[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.grpcRoute.match.metadata'),
        outputPath: 'route.spec.grpcRoute.match.metadata',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.grpcRoute.match.metadata', props);
    return resource.getResponseField('route.spec.grpcRoute.match.metadata') as unknown as shapes.AppMeshGrpcRouteMetadata[];
  }

  public get methodName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.grpcRoute.match.methodName'),
        outputPath: 'route.spec.grpcRoute.match.methodName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.grpcRoute.match.methodName', props);
    return resource.getResponseField('route.spec.grpcRoute.match.methodName') as unknown as string;
  }

  public get serviceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.grpcRoute.match.serviceName'),
        outputPath: 'route.spec.grpcRoute.match.serviceName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.grpcRoute.match.serviceName', props);
    return resource.getResponseField('route.spec.grpcRoute.match.serviceName') as unknown as string;
  }

}

export class AppMeshDescribeRouteRouteSpecGrpcRouteRetryPolicy extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get grpcRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.grpcRoute.retryPolicy.grpcRetryEvents'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.grpcRetryEvents',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.grpcRoute.retryPolicy.grpcRetryEvents', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.grpcRetryEvents') as unknown as string[];
  }

  public get httpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.grpcRoute.retryPolicy.httpRetryEvents'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.httpRetryEvents',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.grpcRoute.retryPolicy.httpRetryEvents', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.httpRetryEvents') as unknown as string[];
  }

  public get maxRetries(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.grpcRoute.retryPolicy.maxRetries'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.maxRetries',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.grpcRoute.retryPolicy.maxRetries', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.maxRetries') as unknown as number;
  }

  public get perRetryTimeout(): AppMeshDescribeRouteRouteSpecGrpcRouteRetryPolicyPerRetryTimeout {
    return new AppMeshDescribeRouteRouteSpecGrpcRouteRetryPolicyPerRetryTimeout(this, 'PerRetryTimeout', this.__resources, this.input);
  }

  public get tcpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.grpcRoute.retryPolicy.tcpRetryEvents'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.tcpRetryEvents',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.grpcRoute.retryPolicy.tcpRetryEvents', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.tcpRetryEvents') as unknown as string[];
  }

}

export class AppMeshDescribeRouteRouteSpecGrpcRouteRetryPolicyPerRetryTimeout extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.value'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.perRetryTimeout.value',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.value', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.perRetryTimeout.value') as unknown as number;
  }

}

export class AppMeshDescribeRouteRouteSpecGrpcRouteTimeout extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get idle(): AppMeshDescribeRouteRouteSpecGrpcRouteTimeoutIdle {
    return new AppMeshDescribeRouteRouteSpecGrpcRouteTimeoutIdle(this, 'Idle', this.__resources, this.input);
  }

  public get perRequest(): AppMeshDescribeRouteRouteSpecGrpcRouteTimeoutPerRequest {
    return new AppMeshDescribeRouteRouteSpecGrpcRouteTimeoutPerRequest(this, 'PerRequest', this.__resources, this.input);
  }

}

export class AppMeshDescribeRouteRouteSpecGrpcRouteTimeoutIdle extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.grpcRoute.timeout.idle.unit'),
        outputPath: 'route.spec.grpcRoute.timeout.idle.unit',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.grpcRoute.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.grpcRoute.timeout.idle.value'),
        outputPath: 'route.spec.grpcRoute.timeout.idle.value',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.grpcRoute.timeout.idle.value', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshDescribeRouteRouteSpecGrpcRouteTimeoutPerRequest extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.grpcRoute.timeout.perRequest.unit'),
        outputPath: 'route.spec.grpcRoute.timeout.perRequest.unit',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.grpcRoute.timeout.perRequest.unit', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.perRequest.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.grpcRoute.timeout.perRequest.value'),
        outputPath: 'route.spec.grpcRoute.timeout.perRequest.value',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.grpcRoute.timeout.perRequest.value', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.perRequest.value') as unknown as number;
  }

}

export class AppMeshDescribeRouteRouteSpecHttp2Route extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get action(): AppMeshDescribeRouteRouteSpecHttp2RouteAction {
    return new AppMeshDescribeRouteRouteSpecHttp2RouteAction(this, 'Action', this.__resources, this.input);
  }

  public get match(): AppMeshDescribeRouteRouteSpecHttp2RouteMatch {
    return new AppMeshDescribeRouteRouteSpecHttp2RouteMatch(this, 'Match', this.__resources, this.input);
  }

  public get retryPolicy(): AppMeshDescribeRouteRouteSpecHttp2RouteRetryPolicy {
    return new AppMeshDescribeRouteRouteSpecHttp2RouteRetryPolicy(this, 'RetryPolicy', this.__resources, this.input);
  }

  public get timeout(): AppMeshDescribeRouteRouteSpecHttp2RouteTimeout {
    return new AppMeshDescribeRouteRouteSpecHttp2RouteTimeout(this, 'Timeout', this.__resources, this.input);
  }

}

export class AppMeshDescribeRouteRouteSpecHttp2RouteAction extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.http2Route.action.weightedTargets'),
        outputPath: 'route.spec.http2Route.action.weightedTargets',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.http2Route.action.weightedTargets', props);
    return resource.getResponseField('route.spec.http2Route.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshDescribeRouteRouteSpecHttp2RouteMatch extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get headers(): shapes.AppMeshHttpRouteHeader[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.http2Route.match.headers'),
        outputPath: 'route.spec.http2Route.match.headers',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.http2Route.match.headers', props);
    return resource.getResponseField('route.spec.http2Route.match.headers') as unknown as shapes.AppMeshHttpRouteHeader[];
  }

  public get method(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.http2Route.match.method'),
        outputPath: 'route.spec.http2Route.match.method',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.http2Route.match.method', props);
    return resource.getResponseField('route.spec.http2Route.match.method') as unknown as string;
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.http2Route.match.prefix'),
        outputPath: 'route.spec.http2Route.match.prefix',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.http2Route.match.prefix', props);
    return resource.getResponseField('route.spec.http2Route.match.prefix') as unknown as string;
  }

  public get scheme(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.http2Route.match.scheme'),
        outputPath: 'route.spec.http2Route.match.scheme',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.http2Route.match.scheme', props);
    return resource.getResponseField('route.spec.http2Route.match.scheme') as unknown as string;
  }

}

export class AppMeshDescribeRouteRouteSpecHttp2RouteRetryPolicy extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get httpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.http2Route.retryPolicy.httpRetryEvents'),
        outputPath: 'route.spec.http2Route.retryPolicy.httpRetryEvents',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.http2Route.retryPolicy.httpRetryEvents', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.httpRetryEvents') as unknown as string[];
  }

  public get maxRetries(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.http2Route.retryPolicy.maxRetries'),
        outputPath: 'route.spec.http2Route.retryPolicy.maxRetries',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.http2Route.retryPolicy.maxRetries', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.maxRetries') as unknown as number;
  }

  public get perRetryTimeout(): AppMeshDescribeRouteRouteSpecHttp2RouteRetryPolicyPerRetryTimeout {
    return new AppMeshDescribeRouteRouteSpecHttp2RouteRetryPolicyPerRetryTimeout(this, 'PerRetryTimeout', this.__resources, this.input);
  }

  public get tcpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.http2Route.retryPolicy.tcpRetryEvents'),
        outputPath: 'route.spec.http2Route.retryPolicy.tcpRetryEvents',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.http2Route.retryPolicy.tcpRetryEvents', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.tcpRetryEvents') as unknown as string[];
  }

}

export class AppMeshDescribeRouteRouteSpecHttp2RouteRetryPolicyPerRetryTimeout extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.unit'),
        outputPath: 'route.spec.http2Route.retryPolicy.perRetryTimeout.unit',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.unit', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.perRetryTimeout.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.value'),
        outputPath: 'route.spec.http2Route.retryPolicy.perRetryTimeout.value',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.value', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.perRetryTimeout.value') as unknown as number;
  }

}

export class AppMeshDescribeRouteRouteSpecHttp2RouteTimeout extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get idle(): AppMeshDescribeRouteRouteSpecHttp2RouteTimeoutIdle {
    return new AppMeshDescribeRouteRouteSpecHttp2RouteTimeoutIdle(this, 'Idle', this.__resources, this.input);
  }

  public get perRequest(): AppMeshDescribeRouteRouteSpecHttp2RouteTimeoutPerRequest {
    return new AppMeshDescribeRouteRouteSpecHttp2RouteTimeoutPerRequest(this, 'PerRequest', this.__resources, this.input);
  }

}

export class AppMeshDescribeRouteRouteSpecHttp2RouteTimeoutIdle extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.http2Route.timeout.idle.unit'),
        outputPath: 'route.spec.http2Route.timeout.idle.unit',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.http2Route.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.http2Route.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.http2Route.timeout.idle.value'),
        outputPath: 'route.spec.http2Route.timeout.idle.value',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.http2Route.timeout.idle.value', props);
    return resource.getResponseField('route.spec.http2Route.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshDescribeRouteRouteSpecHttp2RouteTimeoutPerRequest extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.http2Route.timeout.perRequest.unit'),
        outputPath: 'route.spec.http2Route.timeout.perRequest.unit',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.http2Route.timeout.perRequest.unit', props);
    return resource.getResponseField('route.spec.http2Route.timeout.perRequest.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.http2Route.timeout.perRequest.value'),
        outputPath: 'route.spec.http2Route.timeout.perRequest.value',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.http2Route.timeout.perRequest.value', props);
    return resource.getResponseField('route.spec.http2Route.timeout.perRequest.value') as unknown as number;
  }

}

export class AppMeshDescribeRouteRouteSpecHttpRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get action(): AppMeshDescribeRouteRouteSpecHttpRouteAction {
    return new AppMeshDescribeRouteRouteSpecHttpRouteAction(this, 'Action', this.__resources, this.input);
  }

  public get match(): AppMeshDescribeRouteRouteSpecHttpRouteMatch {
    return new AppMeshDescribeRouteRouteSpecHttpRouteMatch(this, 'Match', this.__resources, this.input);
  }

  public get retryPolicy(): AppMeshDescribeRouteRouteSpecHttpRouteRetryPolicy {
    return new AppMeshDescribeRouteRouteSpecHttpRouteRetryPolicy(this, 'RetryPolicy', this.__resources, this.input);
  }

  public get timeout(): AppMeshDescribeRouteRouteSpecHttpRouteTimeout {
    return new AppMeshDescribeRouteRouteSpecHttpRouteTimeout(this, 'Timeout', this.__resources, this.input);
  }

}

export class AppMeshDescribeRouteRouteSpecHttpRouteAction extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.httpRoute.action.weightedTargets'),
        outputPath: 'route.spec.httpRoute.action.weightedTargets',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.httpRoute.action.weightedTargets', props);
    return resource.getResponseField('route.spec.httpRoute.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshDescribeRouteRouteSpecHttpRouteMatch extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get headers(): shapes.AppMeshHttpRouteHeader[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.httpRoute.match.headers'),
        outputPath: 'route.spec.httpRoute.match.headers',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.httpRoute.match.headers', props);
    return resource.getResponseField('route.spec.httpRoute.match.headers') as unknown as shapes.AppMeshHttpRouteHeader[];
  }

  public get method(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.httpRoute.match.method'),
        outputPath: 'route.spec.httpRoute.match.method',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.httpRoute.match.method', props);
    return resource.getResponseField('route.spec.httpRoute.match.method') as unknown as string;
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.httpRoute.match.prefix'),
        outputPath: 'route.spec.httpRoute.match.prefix',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.httpRoute.match.prefix', props);
    return resource.getResponseField('route.spec.httpRoute.match.prefix') as unknown as string;
  }

  public get scheme(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.httpRoute.match.scheme'),
        outputPath: 'route.spec.httpRoute.match.scheme',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.httpRoute.match.scheme', props);
    return resource.getResponseField('route.spec.httpRoute.match.scheme') as unknown as string;
  }

}

export class AppMeshDescribeRouteRouteSpecHttpRouteRetryPolicy extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get httpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.httpRoute.retryPolicy.httpRetryEvents'),
        outputPath: 'route.spec.httpRoute.retryPolicy.httpRetryEvents',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.httpRoute.retryPolicy.httpRetryEvents', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.httpRetryEvents') as unknown as string[];
  }

  public get maxRetries(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.httpRoute.retryPolicy.maxRetries'),
        outputPath: 'route.spec.httpRoute.retryPolicy.maxRetries',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.httpRoute.retryPolicy.maxRetries', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.maxRetries') as unknown as number;
  }

  public get perRetryTimeout(): AppMeshDescribeRouteRouteSpecHttpRouteRetryPolicyPerRetryTimeout {
    return new AppMeshDescribeRouteRouteSpecHttpRouteRetryPolicyPerRetryTimeout(this, 'PerRetryTimeout', this.__resources, this.input);
  }

  public get tcpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.httpRoute.retryPolicy.tcpRetryEvents'),
        outputPath: 'route.spec.httpRoute.retryPolicy.tcpRetryEvents',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.httpRoute.retryPolicy.tcpRetryEvents', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.tcpRetryEvents') as unknown as string[];
  }

}

export class AppMeshDescribeRouteRouteSpecHttpRouteRetryPolicyPerRetryTimeout extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.unit'),
        outputPath: 'route.spec.httpRoute.retryPolicy.perRetryTimeout.unit',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.unit', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.perRetryTimeout.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.value'),
        outputPath: 'route.spec.httpRoute.retryPolicy.perRetryTimeout.value',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.value', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.perRetryTimeout.value') as unknown as number;
  }

}

export class AppMeshDescribeRouteRouteSpecHttpRouteTimeout extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get idle(): AppMeshDescribeRouteRouteSpecHttpRouteTimeoutIdle {
    return new AppMeshDescribeRouteRouteSpecHttpRouteTimeoutIdle(this, 'Idle', this.__resources, this.input);
  }

  public get perRequest(): AppMeshDescribeRouteRouteSpecHttpRouteTimeoutPerRequest {
    return new AppMeshDescribeRouteRouteSpecHttpRouteTimeoutPerRequest(this, 'PerRequest', this.__resources, this.input);
  }

}

export class AppMeshDescribeRouteRouteSpecHttpRouteTimeoutIdle extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.httpRoute.timeout.idle.unit'),
        outputPath: 'route.spec.httpRoute.timeout.idle.unit',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.httpRoute.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.httpRoute.timeout.idle.value'),
        outputPath: 'route.spec.httpRoute.timeout.idle.value',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.httpRoute.timeout.idle.value', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshDescribeRouteRouteSpecHttpRouteTimeoutPerRequest extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.httpRoute.timeout.perRequest.unit'),
        outputPath: 'route.spec.httpRoute.timeout.perRequest.unit',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.httpRoute.timeout.perRequest.unit', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.perRequest.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.httpRoute.timeout.perRequest.value'),
        outputPath: 'route.spec.httpRoute.timeout.perRequest.value',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.httpRoute.timeout.perRequest.value', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.perRequest.value') as unknown as number;
  }

}

export class AppMeshDescribeRouteRouteSpecTcpRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get action(): AppMeshDescribeRouteRouteSpecTcpRouteAction {
    return new AppMeshDescribeRouteRouteSpecTcpRouteAction(this, 'Action', this.__resources, this.input);
  }

  public get timeout(): AppMeshDescribeRouteRouteSpecTcpRouteTimeout {
    return new AppMeshDescribeRouteRouteSpecTcpRouteTimeout(this, 'Timeout', this.__resources, this.input);
  }

}

export class AppMeshDescribeRouteRouteSpecTcpRouteAction extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.tcpRoute.action.weightedTargets'),
        outputPath: 'route.spec.tcpRoute.action.weightedTargets',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.tcpRoute.action.weightedTargets', props);
    return resource.getResponseField('route.spec.tcpRoute.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshDescribeRouteRouteSpecTcpRouteTimeout extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get idle(): AppMeshDescribeRouteRouteSpecTcpRouteTimeoutIdle {
    return new AppMeshDescribeRouteRouteSpecTcpRouteTimeoutIdle(this, 'Idle', this.__resources, this.input);
  }

}

export class AppMeshDescribeRouteRouteSpecTcpRouteTimeoutIdle extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.tcpRoute.timeout.idle.unit'),
        outputPath: 'route.spec.tcpRoute.timeout.idle.unit',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.tcpRoute.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.tcpRoute.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.tcpRoute.timeout.idle.value'),
        outputPath: 'route.spec.tcpRoute.timeout.idle.value',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.spec.tcpRoute.timeout.idle.value', props);
    return resource.getResponseField('route.spec.tcpRoute.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshDescribeRouteRouteStatus extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeRouteInput) {
    super(scope, id);
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.status.status'),
        outputPath: 'route.status.status',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeRoute.route.status.status', props);
    return resource.getResponseField('route.status.status') as unknown as string;
  }

}

export class AppMeshDescribeVirtualGateway extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualGatewayInput) {
    super(scope, id);
  }

  public get virtualGateway(): AppMeshDescribeVirtualGatewayVirtualGateway {
    return new AppMeshDescribeVirtualGatewayVirtualGateway(this, 'VirtualGateway', this.__resources, this.input);
  }

}

export class AppMeshDescribeVirtualGatewayVirtualGateway extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualGatewayInput) {
    super(scope, id);
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.meshName'),
        outputPath: 'virtualGateway.meshName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualGateway.virtualGateway.meshName', props);
    return resource.getResponseField('virtualGateway.meshName') as unknown as string;
  }

  public get metadata(): AppMeshDescribeVirtualGatewayVirtualGatewayMetadata {
    return new AppMeshDescribeVirtualGatewayVirtualGatewayMetadata(this, 'Metadata', this.__resources, this.input);
  }

  public get spec(): AppMeshDescribeVirtualGatewayVirtualGatewaySpec {
    return new AppMeshDescribeVirtualGatewayVirtualGatewaySpec(this, 'Spec', this.__resources, this.input);
  }

  public get status(): AppMeshDescribeVirtualGatewayVirtualGatewayStatus {
    return new AppMeshDescribeVirtualGatewayVirtualGatewayStatus(this, 'Status', this.__resources, this.input);
  }

  public get virtualGatewayName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.virtualGatewayName'),
        outputPath: 'virtualGateway.virtualGatewayName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualGateway.virtualGateway.virtualGatewayName', props);
    return resource.getResponseField('virtualGateway.virtualGatewayName') as unknown as string;
  }

}

export class AppMeshDescribeVirtualGatewayVirtualGatewayMetadata extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualGatewayInput) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.metadata.arn'),
        outputPath: 'virtualGateway.metadata.arn',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualGateway.virtualGateway.metadata.arn', props);
    return resource.getResponseField('virtualGateway.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.metadata.createdAt'),
        outputPath: 'virtualGateway.metadata.createdAt',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualGateway.virtualGateway.metadata.createdAt', props);
    return resource.getResponseField('virtualGateway.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.metadata.lastUpdatedAt'),
        outputPath: 'virtualGateway.metadata.lastUpdatedAt',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualGateway.virtualGateway.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualGateway.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.metadata.meshOwner'),
        outputPath: 'virtualGateway.metadata.meshOwner',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualGateway.virtualGateway.metadata.meshOwner', props);
    return resource.getResponseField('virtualGateway.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.metadata.resourceOwner'),
        outputPath: 'virtualGateway.metadata.resourceOwner',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualGateway.virtualGateway.metadata.resourceOwner', props);
    return resource.getResponseField('virtualGateway.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.metadata.uid'),
        outputPath: 'virtualGateway.metadata.uid',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualGateway.virtualGateway.metadata.uid', props);
    return resource.getResponseField('virtualGateway.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.metadata.version'),
        outputPath: 'virtualGateway.metadata.version',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualGateway.virtualGateway.metadata.version', props);
    return resource.getResponseField('virtualGateway.metadata.version') as unknown as number;
  }

}

export class AppMeshDescribeVirtualGatewayVirtualGatewaySpec extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualGatewayInput) {
    super(scope, id);
  }

  public get backendDefaults(): AppMeshDescribeVirtualGatewayVirtualGatewaySpecBackendDefaults {
    return new AppMeshDescribeVirtualGatewayVirtualGatewaySpecBackendDefaults(this, 'BackendDefaults', this.__resources, this.input);
  }

  public get listeners(): shapes.AppMeshVirtualGatewayListener[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.spec.listeners'),
        outputPath: 'virtualGateway.spec.listeners',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualGateway.virtualGateway.spec.listeners', props);
    return resource.getResponseField('virtualGateway.spec.listeners') as unknown as shapes.AppMeshVirtualGatewayListener[];
  }

  public get logging(): AppMeshDescribeVirtualGatewayVirtualGatewaySpecLogging {
    return new AppMeshDescribeVirtualGatewayVirtualGatewaySpecLogging(this, 'Logging', this.__resources, this.input);
  }

}

export class AppMeshDescribeVirtualGatewayVirtualGatewaySpecBackendDefaults extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualGatewayInput) {
    super(scope, id);
  }

  public get clientPolicy(): AppMeshDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicy {
    return new AppMeshDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicy(this, 'ClientPolicy', this.__resources, this.input);
  }

}

export class AppMeshDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicy extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualGatewayInput) {
    super(scope, id);
  }

  public get tls(): AppMeshDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTls {
    return new AppMeshDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTls(this, 'Tls', this.__resources, this.input);
  }

}

export class AppMeshDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTls extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualGatewayInput) {
    super(scope, id);
  }

  public get enforce(): boolean {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce') as unknown as boolean;
  }

  public get ports(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.ports'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.ports',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.ports', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.ports') as unknown as number[];
  }

  public get validation(): AppMeshDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation {
    return new AppMeshDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation(this, 'Validation', this.__resources, this.input);
  }

}

export class AppMeshDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualGatewayInput) {
    super(scope, id);
  }

  public get trust(): AppMeshDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust {
    return new AppMeshDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust(this, 'Trust', this.__resources, this.input);
  }

}

export class AppMeshDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualGatewayInput) {
    super(scope, id);
  }

  public get acm(): AppMeshDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
    return new AppMeshDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm(this, 'Acm', this.__resources, this.input);
  }

  public get file(): AppMeshDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile {
    return new AppMeshDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile(this, 'File', this.__resources, this.input);
  }

}

export class AppMeshDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualGatewayInput) {
    super(scope, id);
  }

  public get certificateAuthorityArns(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns') as unknown as string[];
  }

}

export class AppMeshDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualGatewayInput) {
    super(scope, id);
  }

  public get certificateChain(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain') as unknown as string;
  }

}

export class AppMeshDescribeVirtualGatewayVirtualGatewaySpecLogging extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualGatewayInput) {
    super(scope, id);
  }

  public get accessLog(): AppMeshDescribeVirtualGatewayVirtualGatewaySpecLoggingAccessLog {
    return new AppMeshDescribeVirtualGatewayVirtualGatewaySpecLoggingAccessLog(this, 'AccessLog', this.__resources, this.input);
  }

}

export class AppMeshDescribeVirtualGatewayVirtualGatewaySpecLoggingAccessLog extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualGatewayInput) {
    super(scope, id);
  }

  public get file(): AppMeshDescribeVirtualGatewayVirtualGatewaySpecLoggingAccessLogFile {
    return new AppMeshDescribeVirtualGatewayVirtualGatewaySpecLoggingAccessLogFile(this, 'File', this.__resources, this.input);
  }

}

export class AppMeshDescribeVirtualGatewayVirtualGatewaySpecLoggingAccessLogFile extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualGatewayInput) {
    super(scope, id);
  }

  public get path(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.spec.logging.accessLog.file.path'),
        outputPath: 'virtualGateway.spec.logging.accessLog.file.path',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualGateway.virtualGateway.spec.logging.accessLog.file.path', props);
    return resource.getResponseField('virtualGateway.spec.logging.accessLog.file.path') as unknown as string;
  }

}

export class AppMeshDescribeVirtualGatewayVirtualGatewayStatus extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualGatewayInput) {
    super(scope, id);
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.status.status'),
        outputPath: 'virtualGateway.status.status',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualGateway.virtualGateway.status.status', props);
    return resource.getResponseField('virtualGateway.status.status') as unknown as string;
  }

}

export class AppMeshDescribeVirtualNode extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualNodeInput) {
    super(scope, id);
  }

  public get virtualNode(): AppMeshDescribeVirtualNodeVirtualNode {
    return new AppMeshDescribeVirtualNodeVirtualNode(this, 'VirtualNode', this.__resources, this.input);
  }

}

export class AppMeshDescribeVirtualNodeVirtualNode extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualNodeInput) {
    super(scope, id);
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.meshName'),
        outputPath: 'virtualNode.meshName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualNode.virtualNode.meshName', props);
    return resource.getResponseField('virtualNode.meshName') as unknown as string;
  }

  public get metadata(): AppMeshDescribeVirtualNodeVirtualNodeMetadata {
    return new AppMeshDescribeVirtualNodeVirtualNodeMetadata(this, 'Metadata', this.__resources, this.input);
  }

  public get spec(): AppMeshDescribeVirtualNodeVirtualNodeSpec {
    return new AppMeshDescribeVirtualNodeVirtualNodeSpec(this, 'Spec', this.__resources, this.input);
  }

  public get status(): AppMeshDescribeVirtualNodeVirtualNodeStatus {
    return new AppMeshDescribeVirtualNodeVirtualNodeStatus(this, 'Status', this.__resources, this.input);
  }

  public get virtualNodeName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.virtualNodeName'),
        outputPath: 'virtualNode.virtualNodeName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualNode.virtualNode.virtualNodeName', props);
    return resource.getResponseField('virtualNode.virtualNodeName') as unknown as string;
  }

}

export class AppMeshDescribeVirtualNodeVirtualNodeMetadata extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualNodeInput) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.metadata.arn'),
        outputPath: 'virtualNode.metadata.arn',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualNode.virtualNode.metadata.arn', props);
    return resource.getResponseField('virtualNode.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.metadata.createdAt'),
        outputPath: 'virtualNode.metadata.createdAt',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualNode.virtualNode.metadata.createdAt', props);
    return resource.getResponseField('virtualNode.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.metadata.lastUpdatedAt'),
        outputPath: 'virtualNode.metadata.lastUpdatedAt',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualNode.virtualNode.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualNode.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.metadata.meshOwner'),
        outputPath: 'virtualNode.metadata.meshOwner',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualNode.virtualNode.metadata.meshOwner', props);
    return resource.getResponseField('virtualNode.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.metadata.resourceOwner'),
        outputPath: 'virtualNode.metadata.resourceOwner',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualNode.virtualNode.metadata.resourceOwner', props);
    return resource.getResponseField('virtualNode.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.metadata.uid'),
        outputPath: 'virtualNode.metadata.uid',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualNode.virtualNode.metadata.uid', props);
    return resource.getResponseField('virtualNode.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.metadata.version'),
        outputPath: 'virtualNode.metadata.version',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualNode.virtualNode.metadata.version', props);
    return resource.getResponseField('virtualNode.metadata.version') as unknown as number;
  }

}

export class AppMeshDescribeVirtualNodeVirtualNodeSpec extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualNodeInput) {
    super(scope, id);
  }

  public get backendDefaults(): AppMeshDescribeVirtualNodeVirtualNodeSpecBackendDefaults {
    return new AppMeshDescribeVirtualNodeVirtualNodeSpecBackendDefaults(this, 'BackendDefaults', this.__resources, this.input);
  }

  public get backends(): shapes.AppMeshBackend[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.spec.backends'),
        outputPath: 'virtualNode.spec.backends',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualNode.virtualNode.spec.backends', props);
    return resource.getResponseField('virtualNode.spec.backends') as unknown as shapes.AppMeshBackend[];
  }

  public get listeners(): shapes.AppMeshListener[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.spec.listeners'),
        outputPath: 'virtualNode.spec.listeners',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualNode.virtualNode.spec.listeners', props);
    return resource.getResponseField('virtualNode.spec.listeners') as unknown as shapes.AppMeshListener[];
  }

  public get logging(): AppMeshDescribeVirtualNodeVirtualNodeSpecLogging {
    return new AppMeshDescribeVirtualNodeVirtualNodeSpecLogging(this, 'Logging', this.__resources, this.input);
  }

  public get serviceDiscovery(): AppMeshDescribeVirtualNodeVirtualNodeSpecServiceDiscovery {
    return new AppMeshDescribeVirtualNodeVirtualNodeSpecServiceDiscovery(this, 'ServiceDiscovery', this.__resources, this.input);
  }

}

export class AppMeshDescribeVirtualNodeVirtualNodeSpecBackendDefaults extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualNodeInput) {
    super(scope, id);
  }

  public get clientPolicy(): AppMeshDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicy {
    return new AppMeshDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicy(this, 'ClientPolicy', this.__resources, this.input);
  }

}

export class AppMeshDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicy extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualNodeInput) {
    super(scope, id);
  }

  public get tls(): AppMeshDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTls {
    return new AppMeshDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTls(this, 'Tls', this.__resources, this.input);
  }

}

export class AppMeshDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTls extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualNodeInput) {
    super(scope, id);
  }

  public get enforce(): boolean {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.enforce'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.enforce',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.enforce', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.enforce') as unknown as boolean;
  }

  public get ports(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.ports'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.ports',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.ports', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.ports') as unknown as number[];
  }

  public get validation(): AppMeshDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidation {
    return new AppMeshDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidation(this, 'Validation', this.__resources, this.input);
  }

}

export class AppMeshDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidation extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualNodeInput) {
    super(scope, id);
  }

  public get trust(): AppMeshDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust {
    return new AppMeshDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust(this, 'Trust', this.__resources, this.input);
  }

}

export class AppMeshDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualNodeInput) {
    super(scope, id);
  }

  public get acm(): AppMeshDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
    return new AppMeshDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm(this, 'Acm', this.__resources, this.input);
  }

  public get file(): AppMeshDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile {
    return new AppMeshDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile(this, 'File', this.__resources, this.input);
  }

}

export class AppMeshDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualNodeInput) {
    super(scope, id);
  }

  public get certificateAuthorityArns(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns') as unknown as string[];
  }

}

export class AppMeshDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualNodeInput) {
    super(scope, id);
  }

  public get certificateChain(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain') as unknown as string;
  }

}

export class AppMeshDescribeVirtualNodeVirtualNodeSpecLogging extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualNodeInput) {
    super(scope, id);
  }

  public get accessLog(): AppMeshDescribeVirtualNodeVirtualNodeSpecLoggingAccessLog {
    return new AppMeshDescribeVirtualNodeVirtualNodeSpecLoggingAccessLog(this, 'AccessLog', this.__resources, this.input);
  }

}

export class AppMeshDescribeVirtualNodeVirtualNodeSpecLoggingAccessLog extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualNodeInput) {
    super(scope, id);
  }

  public get file(): AppMeshDescribeVirtualNodeVirtualNodeSpecLoggingAccessLogFile {
    return new AppMeshDescribeVirtualNodeVirtualNodeSpecLoggingAccessLogFile(this, 'File', this.__resources, this.input);
  }

}

export class AppMeshDescribeVirtualNodeVirtualNodeSpecLoggingAccessLogFile extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualNodeInput) {
    super(scope, id);
  }

  public get path(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.spec.logging.accessLog.file.path'),
        outputPath: 'virtualNode.spec.logging.accessLog.file.path',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualNode.virtualNode.spec.logging.accessLog.file.path', props);
    return resource.getResponseField('virtualNode.spec.logging.accessLog.file.path') as unknown as string;
  }

}

export class AppMeshDescribeVirtualNodeVirtualNodeSpecServiceDiscovery extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualNodeInput) {
    super(scope, id);
  }

  public get awsCloudMap(): AppMeshDescribeVirtualNodeVirtualNodeSpecServiceDiscoveryAwsCloudMap {
    return new AppMeshDescribeVirtualNodeVirtualNodeSpecServiceDiscoveryAwsCloudMap(this, 'AwsCloudMap', this.__resources, this.input);
  }

  public get dns(): AppMeshDescribeVirtualNodeVirtualNodeSpecServiceDiscoveryDns {
    return new AppMeshDescribeVirtualNodeVirtualNodeSpecServiceDiscoveryDns(this, 'Dns', this.__resources, this.input);
  }

}

export class AppMeshDescribeVirtualNodeVirtualNodeSpecServiceDiscoveryAwsCloudMap extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualNodeInput) {
    super(scope, id);
  }

  public get attributes(): shapes.AppMeshAwsCloudMapInstanceAttribute[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.attributes'),
        outputPath: 'virtualNode.spec.serviceDiscovery.awsCloudMap.attributes',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.attributes', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.awsCloudMap.attributes') as unknown as shapes.AppMeshAwsCloudMapInstanceAttribute[];
  }

  public get namespaceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName'),
        outputPath: 'virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName') as unknown as string;
  }

  public get serviceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName'),
        outputPath: 'virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName') as unknown as string;
  }

}

export class AppMeshDescribeVirtualNodeVirtualNodeSpecServiceDiscoveryDns extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualNodeInput) {
    super(scope, id);
  }

  public get hostname(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.spec.serviceDiscovery.dns.hostname'),
        outputPath: 'virtualNode.spec.serviceDiscovery.dns.hostname',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualNode.virtualNode.spec.serviceDiscovery.dns.hostname', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.dns.hostname') as unknown as string;
  }

}

export class AppMeshDescribeVirtualNodeVirtualNodeStatus extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualNodeInput) {
    super(scope, id);
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.status.status'),
        outputPath: 'virtualNode.status.status',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualNode.virtualNode.status.status', props);
    return resource.getResponseField('virtualNode.status.status') as unknown as string;
  }

}

export class AppMeshDescribeVirtualRouter extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualRouterInput) {
    super(scope, id);
  }

  public get virtualRouter(): AppMeshDescribeVirtualRouterVirtualRouter {
    return new AppMeshDescribeVirtualRouterVirtualRouter(this, 'VirtualRouter', this.__resources, this.input);
  }

}

export class AppMeshDescribeVirtualRouterVirtualRouter extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualRouterInput) {
    super(scope, id);
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualRouter.virtualRouter.meshName'),
        outputPath: 'virtualRouter.meshName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualRouter.virtualRouter.meshName', props);
    return resource.getResponseField('virtualRouter.meshName') as unknown as string;
  }

  public get metadata(): AppMeshDescribeVirtualRouterVirtualRouterMetadata {
    return new AppMeshDescribeVirtualRouterVirtualRouterMetadata(this, 'Metadata', this.__resources, this.input);
  }

  public get spec(): AppMeshDescribeVirtualRouterVirtualRouterSpec {
    return new AppMeshDescribeVirtualRouterVirtualRouterSpec(this, 'Spec', this.__resources, this.input);
  }

  public get status(): AppMeshDescribeVirtualRouterVirtualRouterStatus {
    return new AppMeshDescribeVirtualRouterVirtualRouterStatus(this, 'Status', this.__resources, this.input);
  }

  public get virtualRouterName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualRouter.virtualRouter.virtualRouterName'),
        outputPath: 'virtualRouter.virtualRouterName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualRouter.virtualRouter.virtualRouterName', props);
    return resource.getResponseField('virtualRouter.virtualRouterName') as unknown as string;
  }

}

export class AppMeshDescribeVirtualRouterVirtualRouterMetadata extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualRouterInput) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualRouter.virtualRouter.metadata.arn'),
        outputPath: 'virtualRouter.metadata.arn',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualRouter.virtualRouter.metadata.arn', props);
    return resource.getResponseField('virtualRouter.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualRouter.virtualRouter.metadata.createdAt'),
        outputPath: 'virtualRouter.metadata.createdAt',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualRouter.virtualRouter.metadata.createdAt', props);
    return resource.getResponseField('virtualRouter.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualRouter.virtualRouter.metadata.lastUpdatedAt'),
        outputPath: 'virtualRouter.metadata.lastUpdatedAt',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualRouter.virtualRouter.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualRouter.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualRouter.virtualRouter.metadata.meshOwner'),
        outputPath: 'virtualRouter.metadata.meshOwner',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualRouter.virtualRouter.metadata.meshOwner', props);
    return resource.getResponseField('virtualRouter.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualRouter.virtualRouter.metadata.resourceOwner'),
        outputPath: 'virtualRouter.metadata.resourceOwner',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualRouter.virtualRouter.metadata.resourceOwner', props);
    return resource.getResponseField('virtualRouter.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualRouter.virtualRouter.metadata.uid'),
        outputPath: 'virtualRouter.metadata.uid',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualRouter.virtualRouter.metadata.uid', props);
    return resource.getResponseField('virtualRouter.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualRouter.virtualRouter.metadata.version'),
        outputPath: 'virtualRouter.metadata.version',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualRouter.virtualRouter.metadata.version', props);
    return resource.getResponseField('virtualRouter.metadata.version') as unknown as number;
  }

}

export class AppMeshDescribeVirtualRouterVirtualRouterSpec extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualRouterInput) {
    super(scope, id);
  }

  public get listeners(): shapes.AppMeshVirtualRouterListener[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualRouter.virtualRouter.spec.listeners'),
        outputPath: 'virtualRouter.spec.listeners',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualRouter.virtualRouter.spec.listeners', props);
    return resource.getResponseField('virtualRouter.spec.listeners') as unknown as shapes.AppMeshVirtualRouterListener[];
  }

}

export class AppMeshDescribeVirtualRouterVirtualRouterStatus extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualRouterInput) {
    super(scope, id);
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualRouter.virtualRouter.status.status'),
        outputPath: 'virtualRouter.status.status',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualRouter.virtualRouter.status.status', props);
    return resource.getResponseField('virtualRouter.status.status') as unknown as string;
  }

}

export class AppMeshDescribeVirtualService extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualServiceInput) {
    super(scope, id);
  }

  public get virtualService(): AppMeshDescribeVirtualServiceVirtualService {
    return new AppMeshDescribeVirtualServiceVirtualService(this, 'VirtualService', this.__resources, this.input);
  }

}

export class AppMeshDescribeVirtualServiceVirtualService extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualServiceInput) {
    super(scope, id);
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualService.virtualService.meshName'),
        outputPath: 'virtualService.meshName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualService.virtualService.meshName', props);
    return resource.getResponseField('virtualService.meshName') as unknown as string;
  }

  public get metadata(): AppMeshDescribeVirtualServiceVirtualServiceMetadata {
    return new AppMeshDescribeVirtualServiceVirtualServiceMetadata(this, 'Metadata', this.__resources, this.input);
  }

  public get spec(): AppMeshDescribeVirtualServiceVirtualServiceSpec {
    return new AppMeshDescribeVirtualServiceVirtualServiceSpec(this, 'Spec', this.__resources, this.input);
  }

  public get status(): AppMeshDescribeVirtualServiceVirtualServiceStatus {
    return new AppMeshDescribeVirtualServiceVirtualServiceStatus(this, 'Status', this.__resources, this.input);
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualService.virtualService.virtualServiceName'),
        outputPath: 'virtualService.virtualServiceName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualService.virtualService.virtualServiceName', props);
    return resource.getResponseField('virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshDescribeVirtualServiceVirtualServiceMetadata extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualServiceInput) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualService.virtualService.metadata.arn'),
        outputPath: 'virtualService.metadata.arn',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualService.virtualService.metadata.arn', props);
    return resource.getResponseField('virtualService.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualService.virtualService.metadata.createdAt'),
        outputPath: 'virtualService.metadata.createdAt',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualService.virtualService.metadata.createdAt', props);
    return resource.getResponseField('virtualService.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualService.virtualService.metadata.lastUpdatedAt'),
        outputPath: 'virtualService.metadata.lastUpdatedAt',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualService.virtualService.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualService.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualService.virtualService.metadata.meshOwner'),
        outputPath: 'virtualService.metadata.meshOwner',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualService.virtualService.metadata.meshOwner', props);
    return resource.getResponseField('virtualService.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualService.virtualService.metadata.resourceOwner'),
        outputPath: 'virtualService.metadata.resourceOwner',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualService.virtualService.metadata.resourceOwner', props);
    return resource.getResponseField('virtualService.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualService.virtualService.metadata.uid'),
        outputPath: 'virtualService.metadata.uid',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualService.virtualService.metadata.uid', props);
    return resource.getResponseField('virtualService.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualService.virtualService.metadata.version'),
        outputPath: 'virtualService.metadata.version',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualService.virtualService.metadata.version', props);
    return resource.getResponseField('virtualService.metadata.version') as unknown as number;
  }

}

export class AppMeshDescribeVirtualServiceVirtualServiceSpec extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualServiceInput) {
    super(scope, id);
  }

  public get provider(): AppMeshDescribeVirtualServiceVirtualServiceSpecProvider {
    return new AppMeshDescribeVirtualServiceVirtualServiceSpecProvider(this, 'Provider', this.__resources, this.input);
  }

}

export class AppMeshDescribeVirtualServiceVirtualServiceSpecProvider extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualServiceInput) {
    super(scope, id);
  }

  public get virtualNode(): AppMeshDescribeVirtualServiceVirtualServiceSpecProviderVirtualNode {
    return new AppMeshDescribeVirtualServiceVirtualServiceSpecProviderVirtualNode(this, 'VirtualNode', this.__resources, this.input);
  }

  public get virtualRouter(): AppMeshDescribeVirtualServiceVirtualServiceSpecProviderVirtualRouter {
    return new AppMeshDescribeVirtualServiceVirtualServiceSpecProviderVirtualRouter(this, 'VirtualRouter', this.__resources, this.input);
  }

}

export class AppMeshDescribeVirtualServiceVirtualServiceSpecProviderVirtualNode extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualServiceInput) {
    super(scope, id);
  }

  public get virtualNodeName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualService.virtualService.spec.provider.virtualNode.virtualNodeName'),
        outputPath: 'virtualService.spec.provider.virtualNode.virtualNodeName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualService.virtualService.spec.provider.virtualNode.virtualNodeName', props);
    return resource.getResponseField('virtualService.spec.provider.virtualNode.virtualNodeName') as unknown as string;
  }

}

export class AppMeshDescribeVirtualServiceVirtualServiceSpecProviderVirtualRouter extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualServiceInput) {
    super(scope, id);
  }

  public get virtualRouterName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualService.virtualService.spec.provider.virtualRouter.virtualRouterName'),
        outputPath: 'virtualService.spec.provider.virtualRouter.virtualRouterName',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualService.virtualService.spec.provider.virtualRouter.virtualRouterName', props);
    return resource.getResponseField('virtualService.spec.provider.virtualRouter.virtualRouterName') as unknown as string;
  }

}

export class AppMeshDescribeVirtualServiceVirtualServiceStatus extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshDescribeVirtualServiceInput) {
    super(scope, id);
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualService.virtualService.status.status'),
        outputPath: 'virtualService.status.status',
        parameters: {
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeVirtualService.virtualService.status.status', props);
    return resource.getResponseField('virtualService.status.status') as unknown as string;
  }

}

export class AppMeshListGatewayRoutes extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshListGatewayRoutesInput) {
    super(scope, id);
  }

  public get gatewayRoutes(): shapes.AppMeshGatewayRouteRef[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listGatewayRoutes',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListGatewayRoutes.gatewayRoutes'),
        outputPath: 'gatewayRoutes',
        parameters: {
          limit: this.input.limit,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          nextToken: this.input.nextToken,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListGatewayRoutes.gatewayRoutes', props);
    return resource.getResponseField('gatewayRoutes') as unknown as shapes.AppMeshGatewayRouteRef[];
  }

  public get nextToken(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listGatewayRoutes',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListGatewayRoutes.nextToken'),
        outputPath: 'nextToken',
        parameters: {
          limit: this.input.limit,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          nextToken: this.input.nextToken,
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListGatewayRoutes.nextToken', props);
    return resource.getResponseField('nextToken') as unknown as string;
  }

}

export class AppMeshListMeshes extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshListMeshesInput) {
    super(scope, id);
  }

  public get meshes(): shapes.AppMeshMeshRef[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listMeshes',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListMeshes.meshes'),
        outputPath: 'meshes',
        parameters: {
          limit: this.input.limit,
          nextToken: this.input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListMeshes.meshes', props);
    return resource.getResponseField('meshes') as unknown as shapes.AppMeshMeshRef[];
  }

  public get nextToken(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listMeshes',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListMeshes.nextToken'),
        outputPath: 'nextToken',
        parameters: {
          limit: this.input.limit,
          nextToken: this.input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListMeshes.nextToken', props);
    return resource.getResponseField('nextToken') as unknown as string;
  }

}

export class AppMeshListRoutes extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshListRoutesInput) {
    super(scope, id);
  }

  public get nextToken(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listRoutes',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListRoutes.nextToken'),
        outputPath: 'nextToken',
        parameters: {
          limit: this.input.limit,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          nextToken: this.input.nextToken,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListRoutes.nextToken', props);
    return resource.getResponseField('nextToken') as unknown as string;
  }

  public get routes(): shapes.AppMeshRouteRef[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listRoutes',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListRoutes.routes'),
        outputPath: 'routes',
        parameters: {
          limit: this.input.limit,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          nextToken: this.input.nextToken,
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListRoutes.routes', props);
    return resource.getResponseField('routes') as unknown as shapes.AppMeshRouteRef[];
  }

}

export class AppMeshListTagsForResource extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshListTagsForResourceInput) {
    super(scope, id);
  }

  public get nextToken(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listTagsForResource',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListTagsForResource.nextToken'),
        outputPath: 'nextToken',
        parameters: {
          limit: this.input.limit,
          nextToken: this.input.nextToken,
          resourceArn: this.input.resourceArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListTagsForResource.nextToken', props);
    return resource.getResponseField('nextToken') as unknown as string;
  }

  public get tags(): shapes.AppMeshTagRef[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listTagsForResource',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListTagsForResource.tags'),
        outputPath: 'tags',
        parameters: {
          limit: this.input.limit,
          nextToken: this.input.nextToken,
          resourceArn: this.input.resourceArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListTagsForResource.tags', props);
    return resource.getResponseField('tags') as unknown as shapes.AppMeshTagRef[];
  }

}

export class AppMeshListVirtualGateways extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshListVirtualGatewaysInput) {
    super(scope, id);
  }

  public get nextToken(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listVirtualGateways',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListVirtualGateways.nextToken'),
        outputPath: 'nextToken',
        parameters: {
          limit: this.input.limit,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          nextToken: this.input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListVirtualGateways.nextToken', props);
    return resource.getResponseField('nextToken') as unknown as string;
  }

  public get virtualGateways(): shapes.AppMeshVirtualGatewayRef[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listVirtualGateways',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListVirtualGateways.virtualGateways'),
        outputPath: 'virtualGateways',
        parameters: {
          limit: this.input.limit,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          nextToken: this.input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListVirtualGateways.virtualGateways', props);
    return resource.getResponseField('virtualGateways') as unknown as shapes.AppMeshVirtualGatewayRef[];
  }

}

export class AppMeshListVirtualNodes extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshListVirtualNodesInput) {
    super(scope, id);
  }

  public get nextToken(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listVirtualNodes',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListVirtualNodes.nextToken'),
        outputPath: 'nextToken',
        parameters: {
          limit: this.input.limit,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          nextToken: this.input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListVirtualNodes.nextToken', props);
    return resource.getResponseField('nextToken') as unknown as string;
  }

  public get virtualNodes(): shapes.AppMeshVirtualNodeRef[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listVirtualNodes',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListVirtualNodes.virtualNodes'),
        outputPath: 'virtualNodes',
        parameters: {
          limit: this.input.limit,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          nextToken: this.input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListVirtualNodes.virtualNodes', props);
    return resource.getResponseField('virtualNodes') as unknown as shapes.AppMeshVirtualNodeRef[];
  }

}

export class AppMeshListVirtualRouters extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshListVirtualRoutersInput) {
    super(scope, id);
  }

  public get nextToken(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listVirtualRouters',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListVirtualRouters.nextToken'),
        outputPath: 'nextToken',
        parameters: {
          limit: this.input.limit,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          nextToken: this.input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListVirtualRouters.nextToken', props);
    return resource.getResponseField('nextToken') as unknown as string;
  }

  public get virtualRouters(): shapes.AppMeshVirtualRouterRef[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listVirtualRouters',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListVirtualRouters.virtualRouters'),
        outputPath: 'virtualRouters',
        parameters: {
          limit: this.input.limit,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          nextToken: this.input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListVirtualRouters.virtualRouters', props);
    return resource.getResponseField('virtualRouters') as unknown as shapes.AppMeshVirtualRouterRef[];
  }

}

export class AppMeshListVirtualServices extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshListVirtualServicesInput) {
    super(scope, id);
  }

  public get nextToken(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listVirtualServices',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListVirtualServices.nextToken'),
        outputPath: 'nextToken',
        parameters: {
          limit: this.input.limit,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          nextToken: this.input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListVirtualServices.nextToken', props);
    return resource.getResponseField('nextToken') as unknown as string;
  }

  public get virtualServices(): shapes.AppMeshVirtualServiceRef[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listVirtualServices',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListVirtualServices.virtualServices'),
        outputPath: 'virtualServices',
        parameters: {
          limit: this.input.limit,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          nextToken: this.input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListVirtualServices.virtualServices', props);
    return resource.getResponseField('virtualServices') as unknown as shapes.AppMeshVirtualServiceRef[];
  }

}

export class AppMeshUpdateGatewayRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateGatewayRouteInput) {
    super(scope, id);
  }

  public get gatewayRoute(): AppMeshUpdateGatewayRouteGatewayRoute {
    return new AppMeshUpdateGatewayRouteGatewayRoute(this, 'GatewayRoute', this.__resources, this.input);
  }

}

export class AppMeshUpdateGatewayRouteGatewayRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateGatewayRouteInput) {
    super(scope, id);
  }

  public get gatewayRouteName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.gatewayRouteName'),
        outputPath: 'gatewayRoute.gatewayRouteName',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateGatewayRoute.gatewayRoute.gatewayRouteName', props);
    return resource.getResponseField('gatewayRoute.gatewayRouteName') as unknown as string;
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.meshName'),
        outputPath: 'gatewayRoute.meshName',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateGatewayRoute.gatewayRoute.meshName', props);
    return resource.getResponseField('gatewayRoute.meshName') as unknown as string;
  }

  public get metadata(): AppMeshUpdateGatewayRouteGatewayRouteMetadata {
    return new AppMeshUpdateGatewayRouteGatewayRouteMetadata(this, 'Metadata', this.__resources, this.input);
  }

  public get spec(): AppMeshUpdateGatewayRouteGatewayRouteSpec {
    return new AppMeshUpdateGatewayRouteGatewayRouteSpec(this, 'Spec', this.__resources, this.input);
  }

  public get status(): AppMeshUpdateGatewayRouteGatewayRouteStatus {
    return new AppMeshUpdateGatewayRouteGatewayRouteStatus(this, 'Status', this.__resources, this.input);
  }

  public get virtualGatewayName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.virtualGatewayName'),
        outputPath: 'gatewayRoute.virtualGatewayName',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateGatewayRoute.gatewayRoute.virtualGatewayName', props);
    return resource.getResponseField('gatewayRoute.virtualGatewayName') as unknown as string;
  }

}

export class AppMeshUpdateGatewayRouteGatewayRouteMetadata extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateGatewayRouteInput) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.metadata.arn'),
        outputPath: 'gatewayRoute.metadata.arn',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateGatewayRoute.gatewayRoute.metadata.arn', props);
    return resource.getResponseField('gatewayRoute.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.metadata.createdAt'),
        outputPath: 'gatewayRoute.metadata.createdAt',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateGatewayRoute.gatewayRoute.metadata.createdAt', props);
    return resource.getResponseField('gatewayRoute.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.metadata.lastUpdatedAt'),
        outputPath: 'gatewayRoute.metadata.lastUpdatedAt',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateGatewayRoute.gatewayRoute.metadata.lastUpdatedAt', props);
    return resource.getResponseField('gatewayRoute.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.metadata.meshOwner'),
        outputPath: 'gatewayRoute.metadata.meshOwner',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateGatewayRoute.gatewayRoute.metadata.meshOwner', props);
    return resource.getResponseField('gatewayRoute.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.metadata.resourceOwner'),
        outputPath: 'gatewayRoute.metadata.resourceOwner',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateGatewayRoute.gatewayRoute.metadata.resourceOwner', props);
    return resource.getResponseField('gatewayRoute.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.metadata.uid'),
        outputPath: 'gatewayRoute.metadata.uid',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateGatewayRoute.gatewayRoute.metadata.uid', props);
    return resource.getResponseField('gatewayRoute.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.metadata.version'),
        outputPath: 'gatewayRoute.metadata.version',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateGatewayRoute.gatewayRoute.metadata.version', props);
    return resource.getResponseField('gatewayRoute.metadata.version') as unknown as number;
  }

}

export class AppMeshUpdateGatewayRouteGatewayRouteSpec extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateGatewayRouteInput) {
    super(scope, id);
  }

  public get grpcRoute(): AppMeshUpdateGatewayRouteGatewayRouteSpecGrpcRoute {
    return new AppMeshUpdateGatewayRouteGatewayRouteSpecGrpcRoute(this, 'GrpcRoute', this.__resources, this.input);
  }

  public get http2Route(): AppMeshUpdateGatewayRouteGatewayRouteSpecHttp2Route {
    return new AppMeshUpdateGatewayRouteGatewayRouteSpecHttp2Route(this, 'Http2Route', this.__resources, this.input);
  }

  public get httpRoute(): AppMeshUpdateGatewayRouteGatewayRouteSpecHttpRoute {
    return new AppMeshUpdateGatewayRouteGatewayRouteSpecHttpRoute(this, 'HttpRoute', this.__resources, this.input);
  }

}

export class AppMeshUpdateGatewayRouteGatewayRouteSpecGrpcRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateGatewayRouteInput) {
    super(scope, id);
  }

  public get action(): AppMeshUpdateGatewayRouteGatewayRouteSpecGrpcRouteAction {
    return new AppMeshUpdateGatewayRouteGatewayRouteSpecGrpcRouteAction(this, 'Action', this.__resources, this.input);
  }

  public get match(): AppMeshUpdateGatewayRouteGatewayRouteSpecGrpcRouteMatch {
    return new AppMeshUpdateGatewayRouteGatewayRouteSpecGrpcRouteMatch(this, 'Match', this.__resources, this.input);
  }

}

export class AppMeshUpdateGatewayRouteGatewayRouteSpecGrpcRouteAction extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateGatewayRouteInput) {
    super(scope, id);
  }

  public get target(): AppMeshUpdateGatewayRouteGatewayRouteSpecGrpcRouteActionTarget {
    return new AppMeshUpdateGatewayRouteGatewayRouteSpecGrpcRouteActionTarget(this, 'Target', this.__resources, this.input);
  }

}

export class AppMeshUpdateGatewayRouteGatewayRouteSpecGrpcRouteActionTarget extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateGatewayRouteInput) {
    super(scope, id);
  }

  public get virtualService(): AppMeshUpdateGatewayRouteGatewayRouteSpecGrpcRouteActionTargetVirtualService {
    return new AppMeshUpdateGatewayRouteGatewayRouteSpecGrpcRouteActionTargetVirtualService(this, 'VirtualService', this.__resources, this.input);
  }

}

export class AppMeshUpdateGatewayRouteGatewayRouteSpecGrpcRouteActionTargetVirtualService extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateGatewayRouteInput) {
    super(scope, id);
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName'),
        outputPath: 'gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateGatewayRoute.gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName', props);
    return resource.getResponseField('gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshUpdateGatewayRouteGatewayRouteSpecGrpcRouteMatch extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateGatewayRouteInput) {
    super(scope, id);
  }

  public get serviceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.spec.grpcRoute.match.serviceName'),
        outputPath: 'gatewayRoute.spec.grpcRoute.match.serviceName',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateGatewayRoute.gatewayRoute.spec.grpcRoute.match.serviceName', props);
    return resource.getResponseField('gatewayRoute.spec.grpcRoute.match.serviceName') as unknown as string;
  }

}

export class AppMeshUpdateGatewayRouteGatewayRouteSpecHttp2Route extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateGatewayRouteInput) {
    super(scope, id);
  }

  public get action(): AppMeshUpdateGatewayRouteGatewayRouteSpecHttp2RouteAction {
    return new AppMeshUpdateGatewayRouteGatewayRouteSpecHttp2RouteAction(this, 'Action', this.__resources, this.input);
  }

  public get match(): AppMeshUpdateGatewayRouteGatewayRouteSpecHttp2RouteMatch {
    return new AppMeshUpdateGatewayRouteGatewayRouteSpecHttp2RouteMatch(this, 'Match', this.__resources, this.input);
  }

}

export class AppMeshUpdateGatewayRouteGatewayRouteSpecHttp2RouteAction extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateGatewayRouteInput) {
    super(scope, id);
  }

  public get target(): AppMeshUpdateGatewayRouteGatewayRouteSpecHttp2RouteActionTarget {
    return new AppMeshUpdateGatewayRouteGatewayRouteSpecHttp2RouteActionTarget(this, 'Target', this.__resources, this.input);
  }

}

export class AppMeshUpdateGatewayRouteGatewayRouteSpecHttp2RouteActionTarget extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateGatewayRouteInput) {
    super(scope, id);
  }

  public get virtualService(): AppMeshUpdateGatewayRouteGatewayRouteSpecHttp2RouteActionTargetVirtualService {
    return new AppMeshUpdateGatewayRouteGatewayRouteSpecHttp2RouteActionTargetVirtualService(this, 'VirtualService', this.__resources, this.input);
  }

}

export class AppMeshUpdateGatewayRouteGatewayRouteSpecHttp2RouteActionTargetVirtualService extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateGatewayRouteInput) {
    super(scope, id);
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName'),
        outputPath: 'gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateGatewayRoute.gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName', props);
    return resource.getResponseField('gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshUpdateGatewayRouteGatewayRouteSpecHttp2RouteMatch extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateGatewayRouteInput) {
    super(scope, id);
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.spec.http2Route.match.prefix'),
        outputPath: 'gatewayRoute.spec.http2Route.match.prefix',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateGatewayRoute.gatewayRoute.spec.http2Route.match.prefix', props);
    return resource.getResponseField('gatewayRoute.spec.http2Route.match.prefix') as unknown as string;
  }

}

export class AppMeshUpdateGatewayRouteGatewayRouteSpecHttpRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateGatewayRouteInput) {
    super(scope, id);
  }

  public get action(): AppMeshUpdateGatewayRouteGatewayRouteSpecHttpRouteAction {
    return new AppMeshUpdateGatewayRouteGatewayRouteSpecHttpRouteAction(this, 'Action', this.__resources, this.input);
  }

  public get match(): AppMeshUpdateGatewayRouteGatewayRouteSpecHttpRouteMatch {
    return new AppMeshUpdateGatewayRouteGatewayRouteSpecHttpRouteMatch(this, 'Match', this.__resources, this.input);
  }

}

export class AppMeshUpdateGatewayRouteGatewayRouteSpecHttpRouteAction extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateGatewayRouteInput) {
    super(scope, id);
  }

  public get target(): AppMeshUpdateGatewayRouteGatewayRouteSpecHttpRouteActionTarget {
    return new AppMeshUpdateGatewayRouteGatewayRouteSpecHttpRouteActionTarget(this, 'Target', this.__resources, this.input);
  }

}

export class AppMeshUpdateGatewayRouteGatewayRouteSpecHttpRouteActionTarget extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateGatewayRouteInput) {
    super(scope, id);
  }

  public get virtualService(): AppMeshUpdateGatewayRouteGatewayRouteSpecHttpRouteActionTargetVirtualService {
    return new AppMeshUpdateGatewayRouteGatewayRouteSpecHttpRouteActionTargetVirtualService(this, 'VirtualService', this.__resources, this.input);
  }

}

export class AppMeshUpdateGatewayRouteGatewayRouteSpecHttpRouteActionTargetVirtualService extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateGatewayRouteInput) {
    super(scope, id);
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName'),
        outputPath: 'gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateGatewayRoute.gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName', props);
    return resource.getResponseField('gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshUpdateGatewayRouteGatewayRouteSpecHttpRouteMatch extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateGatewayRouteInput) {
    super(scope, id);
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.spec.httpRoute.match.prefix'),
        outputPath: 'gatewayRoute.spec.httpRoute.match.prefix',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateGatewayRoute.gatewayRoute.spec.httpRoute.match.prefix', props);
    return resource.getResponseField('gatewayRoute.spec.httpRoute.match.prefix') as unknown as string;
  }

}

export class AppMeshUpdateGatewayRouteGatewayRouteStatus extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateGatewayRouteInput) {
    super(scope, id);
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.status.status'),
        outputPath: 'gatewayRoute.status.status',
        parameters: {
          clientToken: this.input.clientToken,
          gatewayRouteName: this.input.gatewayRouteName,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateGatewayRoute.gatewayRoute.status.status', props);
    return resource.getResponseField('gatewayRoute.status.status') as unknown as string;
  }

}

export class AppMeshUpdateMesh extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateMeshInput) {
    super(scope, id);
  }

  public get mesh(): AppMeshUpdateMeshMesh {
    return new AppMeshUpdateMeshMesh(this, 'Mesh', this.__resources, this.input);
  }

}

export class AppMeshUpdateMeshMesh extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateMeshInput) {
    super(scope, id);
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateMesh.mesh.meshName'),
        outputPath: 'mesh.meshName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          spec: {
            egressFilter: {
              type: this.input.spec?.egressFilter?.type,
            },
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMesh.mesh.meshName', props);
    return resource.getResponseField('mesh.meshName') as unknown as string;
  }

  public get metadata(): AppMeshUpdateMeshMeshMetadata {
    return new AppMeshUpdateMeshMeshMetadata(this, 'Metadata', this.__resources, this.input);
  }

  public get spec(): AppMeshUpdateMeshMeshSpec {
    return new AppMeshUpdateMeshMeshSpec(this, 'Spec', this.__resources, this.input);
  }

  public get status(): AppMeshUpdateMeshMeshStatus {
    return new AppMeshUpdateMeshMeshStatus(this, 'Status', this.__resources, this.input);
  }

}

export class AppMeshUpdateMeshMeshMetadata extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateMeshInput) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateMesh.mesh.metadata.arn'),
        outputPath: 'mesh.metadata.arn',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          spec: {
            egressFilter: {
              type: this.input.spec?.egressFilter?.type,
            },
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMesh.mesh.metadata.arn', props);
    return resource.getResponseField('mesh.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateMesh.mesh.metadata.createdAt'),
        outputPath: 'mesh.metadata.createdAt',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          spec: {
            egressFilter: {
              type: this.input.spec?.egressFilter?.type,
            },
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMesh.mesh.metadata.createdAt', props);
    return resource.getResponseField('mesh.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateMesh.mesh.metadata.lastUpdatedAt'),
        outputPath: 'mesh.metadata.lastUpdatedAt',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          spec: {
            egressFilter: {
              type: this.input.spec?.egressFilter?.type,
            },
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMesh.mesh.metadata.lastUpdatedAt', props);
    return resource.getResponseField('mesh.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateMesh.mesh.metadata.meshOwner'),
        outputPath: 'mesh.metadata.meshOwner',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          spec: {
            egressFilter: {
              type: this.input.spec?.egressFilter?.type,
            },
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMesh.mesh.metadata.meshOwner', props);
    return resource.getResponseField('mesh.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateMesh.mesh.metadata.resourceOwner'),
        outputPath: 'mesh.metadata.resourceOwner',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          spec: {
            egressFilter: {
              type: this.input.spec?.egressFilter?.type,
            },
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMesh.mesh.metadata.resourceOwner', props);
    return resource.getResponseField('mesh.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateMesh.mesh.metadata.uid'),
        outputPath: 'mesh.metadata.uid',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          spec: {
            egressFilter: {
              type: this.input.spec?.egressFilter?.type,
            },
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMesh.mesh.metadata.uid', props);
    return resource.getResponseField('mesh.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateMesh.mesh.metadata.version'),
        outputPath: 'mesh.metadata.version',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          spec: {
            egressFilter: {
              type: this.input.spec?.egressFilter?.type,
            },
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMesh.mesh.metadata.version', props);
    return resource.getResponseField('mesh.metadata.version') as unknown as number;
  }

}

export class AppMeshUpdateMeshMeshSpec extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateMeshInput) {
    super(scope, id);
  }

  public get egressFilter(): AppMeshUpdateMeshMeshSpecEgressFilter {
    return new AppMeshUpdateMeshMeshSpecEgressFilter(this, 'EgressFilter', this.__resources, this.input);
  }

}

export class AppMeshUpdateMeshMeshSpecEgressFilter extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateMeshInput) {
    super(scope, id);
  }

  public get type(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateMesh.mesh.spec.egressFilter.type'),
        outputPath: 'mesh.spec.egressFilter.type',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          spec: {
            egressFilter: {
              type: this.input.spec?.egressFilter?.type,
            },
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMesh.mesh.spec.egressFilter.type', props);
    return resource.getResponseField('mesh.spec.egressFilter.type') as unknown as string;
  }

}

export class AppMeshUpdateMeshMeshStatus extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateMeshInput) {
    super(scope, id);
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateMesh.mesh.status.status'),
        outputPath: 'mesh.status.status',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          spec: {
            egressFilter: {
              type: this.input.spec?.egressFilter?.type,
            },
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMesh.mesh.status.status', props);
    return resource.getResponseField('mesh.status.status') as unknown as string;
  }

}

export class AppMeshUpdateRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get route(): AppMeshUpdateRouteRoute {
    return new AppMeshUpdateRouteRoute(this, 'Route', this.__resources, this.input);
  }

}

export class AppMeshUpdateRouteRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.meshName'),
        outputPath: 'route.meshName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.meshName', props);
    return resource.getResponseField('route.meshName') as unknown as string;
  }

  public get metadata(): AppMeshUpdateRouteRouteMetadata {
    return new AppMeshUpdateRouteRouteMetadata(this, 'Metadata', this.__resources, this.input);
  }

  public get routeName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.routeName'),
        outputPath: 'route.routeName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.routeName', props);
    return resource.getResponseField('route.routeName') as unknown as string;
  }

  public get spec(): AppMeshUpdateRouteRouteSpec {
    return new AppMeshUpdateRouteRouteSpec(this, 'Spec', this.__resources, this.input);
  }

  public get status(): AppMeshUpdateRouteRouteStatus {
    return new AppMeshUpdateRouteRouteStatus(this, 'Status', this.__resources, this.input);
  }

  public get virtualRouterName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.virtualRouterName'),
        outputPath: 'route.virtualRouterName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.virtualRouterName', props);
    return resource.getResponseField('route.virtualRouterName') as unknown as string;
  }

}

export class AppMeshUpdateRouteRouteMetadata extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.metadata.arn'),
        outputPath: 'route.metadata.arn',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.metadata.arn', props);
    return resource.getResponseField('route.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.metadata.createdAt'),
        outputPath: 'route.metadata.createdAt',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.metadata.createdAt', props);
    return resource.getResponseField('route.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.metadata.lastUpdatedAt'),
        outputPath: 'route.metadata.lastUpdatedAt',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.metadata.lastUpdatedAt', props);
    return resource.getResponseField('route.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.metadata.meshOwner'),
        outputPath: 'route.metadata.meshOwner',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.metadata.meshOwner', props);
    return resource.getResponseField('route.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.metadata.resourceOwner'),
        outputPath: 'route.metadata.resourceOwner',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.metadata.resourceOwner', props);
    return resource.getResponseField('route.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.metadata.uid'),
        outputPath: 'route.metadata.uid',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.metadata.uid', props);
    return resource.getResponseField('route.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.metadata.version'),
        outputPath: 'route.metadata.version',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.metadata.version', props);
    return resource.getResponseField('route.metadata.version') as unknown as number;
  }

}

export class AppMeshUpdateRouteRouteSpec extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get grpcRoute(): AppMeshUpdateRouteRouteSpecGrpcRoute {
    return new AppMeshUpdateRouteRouteSpecGrpcRoute(this, 'GrpcRoute', this.__resources, this.input);
  }

  public get http2Route(): AppMeshUpdateRouteRouteSpecHttp2Route {
    return new AppMeshUpdateRouteRouteSpecHttp2Route(this, 'Http2Route', this.__resources, this.input);
  }

  public get httpRoute(): AppMeshUpdateRouteRouteSpecHttpRoute {
    return new AppMeshUpdateRouteRouteSpecHttpRoute(this, 'HttpRoute', this.__resources, this.input);
  }

  public get priority(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.priority'),
        outputPath: 'route.spec.priority',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.priority', props);
    return resource.getResponseField('route.spec.priority') as unknown as number;
  }

  public get tcpRoute(): AppMeshUpdateRouteRouteSpecTcpRoute {
    return new AppMeshUpdateRouteRouteSpecTcpRoute(this, 'TcpRoute', this.__resources, this.input);
  }

}

export class AppMeshUpdateRouteRouteSpecGrpcRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get action(): AppMeshUpdateRouteRouteSpecGrpcRouteAction {
    return new AppMeshUpdateRouteRouteSpecGrpcRouteAction(this, 'Action', this.__resources, this.input);
  }

  public get match(): AppMeshUpdateRouteRouteSpecGrpcRouteMatch {
    return new AppMeshUpdateRouteRouteSpecGrpcRouteMatch(this, 'Match', this.__resources, this.input);
  }

  public get retryPolicy(): AppMeshUpdateRouteRouteSpecGrpcRouteRetryPolicy {
    return new AppMeshUpdateRouteRouteSpecGrpcRouteRetryPolicy(this, 'RetryPolicy', this.__resources, this.input);
  }

  public get timeout(): AppMeshUpdateRouteRouteSpecGrpcRouteTimeout {
    return new AppMeshUpdateRouteRouteSpecGrpcRouteTimeout(this, 'Timeout', this.__resources, this.input);
  }

}

export class AppMeshUpdateRouteRouteSpecGrpcRouteAction extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.grpcRoute.action.weightedTargets'),
        outputPath: 'route.spec.grpcRoute.action.weightedTargets',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.grpcRoute.action.weightedTargets', props);
    return resource.getResponseField('route.spec.grpcRoute.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshUpdateRouteRouteSpecGrpcRouteMatch extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get metadata(): shapes.AppMeshGrpcRouteMetadata[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.grpcRoute.match.metadata'),
        outputPath: 'route.spec.grpcRoute.match.metadata',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.grpcRoute.match.metadata', props);
    return resource.getResponseField('route.spec.grpcRoute.match.metadata') as unknown as shapes.AppMeshGrpcRouteMetadata[];
  }

  public get methodName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.grpcRoute.match.methodName'),
        outputPath: 'route.spec.grpcRoute.match.methodName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.grpcRoute.match.methodName', props);
    return resource.getResponseField('route.spec.grpcRoute.match.methodName') as unknown as string;
  }

  public get serviceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.grpcRoute.match.serviceName'),
        outputPath: 'route.spec.grpcRoute.match.serviceName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.grpcRoute.match.serviceName', props);
    return resource.getResponseField('route.spec.grpcRoute.match.serviceName') as unknown as string;
  }

}

export class AppMeshUpdateRouteRouteSpecGrpcRouteRetryPolicy extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get grpcRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.grpcRoute.retryPolicy.grpcRetryEvents'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.grpcRetryEvents',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.grpcRoute.retryPolicy.grpcRetryEvents', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.grpcRetryEvents') as unknown as string[];
  }

  public get httpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.grpcRoute.retryPolicy.httpRetryEvents'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.httpRetryEvents',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.grpcRoute.retryPolicy.httpRetryEvents', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.httpRetryEvents') as unknown as string[];
  }

  public get maxRetries(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.grpcRoute.retryPolicy.maxRetries'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.maxRetries',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.grpcRoute.retryPolicy.maxRetries', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.maxRetries') as unknown as number;
  }

  public get perRetryTimeout(): AppMeshUpdateRouteRouteSpecGrpcRouteRetryPolicyPerRetryTimeout {
    return new AppMeshUpdateRouteRouteSpecGrpcRouteRetryPolicyPerRetryTimeout(this, 'PerRetryTimeout', this.__resources, this.input);
  }

  public get tcpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.grpcRoute.retryPolicy.tcpRetryEvents'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.tcpRetryEvents',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.grpcRoute.retryPolicy.tcpRetryEvents', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.tcpRetryEvents') as unknown as string[];
  }

}

export class AppMeshUpdateRouteRouteSpecGrpcRouteRetryPolicyPerRetryTimeout extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.value'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.perRetryTimeout.value',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.value', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.perRetryTimeout.value') as unknown as number;
  }

}

export class AppMeshUpdateRouteRouteSpecGrpcRouteTimeout extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get idle(): AppMeshUpdateRouteRouteSpecGrpcRouteTimeoutIdle {
    return new AppMeshUpdateRouteRouteSpecGrpcRouteTimeoutIdle(this, 'Idle', this.__resources, this.input);
  }

  public get perRequest(): AppMeshUpdateRouteRouteSpecGrpcRouteTimeoutPerRequest {
    return new AppMeshUpdateRouteRouteSpecGrpcRouteTimeoutPerRequest(this, 'PerRequest', this.__resources, this.input);
  }

}

export class AppMeshUpdateRouteRouteSpecGrpcRouteTimeoutIdle extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.grpcRoute.timeout.idle.unit'),
        outputPath: 'route.spec.grpcRoute.timeout.idle.unit',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.grpcRoute.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.grpcRoute.timeout.idle.value'),
        outputPath: 'route.spec.grpcRoute.timeout.idle.value',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.grpcRoute.timeout.idle.value', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshUpdateRouteRouteSpecGrpcRouteTimeoutPerRequest extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.grpcRoute.timeout.perRequest.unit'),
        outputPath: 'route.spec.grpcRoute.timeout.perRequest.unit',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.grpcRoute.timeout.perRequest.unit', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.perRequest.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.grpcRoute.timeout.perRequest.value'),
        outputPath: 'route.spec.grpcRoute.timeout.perRequest.value',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.grpcRoute.timeout.perRequest.value', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.perRequest.value') as unknown as number;
  }

}

export class AppMeshUpdateRouteRouteSpecHttp2Route extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get action(): AppMeshUpdateRouteRouteSpecHttp2RouteAction {
    return new AppMeshUpdateRouteRouteSpecHttp2RouteAction(this, 'Action', this.__resources, this.input);
  }

  public get match(): AppMeshUpdateRouteRouteSpecHttp2RouteMatch {
    return new AppMeshUpdateRouteRouteSpecHttp2RouteMatch(this, 'Match', this.__resources, this.input);
  }

  public get retryPolicy(): AppMeshUpdateRouteRouteSpecHttp2RouteRetryPolicy {
    return new AppMeshUpdateRouteRouteSpecHttp2RouteRetryPolicy(this, 'RetryPolicy', this.__resources, this.input);
  }

  public get timeout(): AppMeshUpdateRouteRouteSpecHttp2RouteTimeout {
    return new AppMeshUpdateRouteRouteSpecHttp2RouteTimeout(this, 'Timeout', this.__resources, this.input);
  }

}

export class AppMeshUpdateRouteRouteSpecHttp2RouteAction extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.http2Route.action.weightedTargets'),
        outputPath: 'route.spec.http2Route.action.weightedTargets',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.http2Route.action.weightedTargets', props);
    return resource.getResponseField('route.spec.http2Route.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshUpdateRouteRouteSpecHttp2RouteMatch extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get headers(): shapes.AppMeshHttpRouteHeader[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.http2Route.match.headers'),
        outputPath: 'route.spec.http2Route.match.headers',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.http2Route.match.headers', props);
    return resource.getResponseField('route.spec.http2Route.match.headers') as unknown as shapes.AppMeshHttpRouteHeader[];
  }

  public get method(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.http2Route.match.method'),
        outputPath: 'route.spec.http2Route.match.method',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.http2Route.match.method', props);
    return resource.getResponseField('route.spec.http2Route.match.method') as unknown as string;
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.http2Route.match.prefix'),
        outputPath: 'route.spec.http2Route.match.prefix',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.http2Route.match.prefix', props);
    return resource.getResponseField('route.spec.http2Route.match.prefix') as unknown as string;
  }

  public get scheme(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.http2Route.match.scheme'),
        outputPath: 'route.spec.http2Route.match.scheme',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.http2Route.match.scheme', props);
    return resource.getResponseField('route.spec.http2Route.match.scheme') as unknown as string;
  }

}

export class AppMeshUpdateRouteRouteSpecHttp2RouteRetryPolicy extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get httpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.http2Route.retryPolicy.httpRetryEvents'),
        outputPath: 'route.spec.http2Route.retryPolicy.httpRetryEvents',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.http2Route.retryPolicy.httpRetryEvents', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.httpRetryEvents') as unknown as string[];
  }

  public get maxRetries(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.http2Route.retryPolicy.maxRetries'),
        outputPath: 'route.spec.http2Route.retryPolicy.maxRetries',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.http2Route.retryPolicy.maxRetries', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.maxRetries') as unknown as number;
  }

  public get perRetryTimeout(): AppMeshUpdateRouteRouteSpecHttp2RouteRetryPolicyPerRetryTimeout {
    return new AppMeshUpdateRouteRouteSpecHttp2RouteRetryPolicyPerRetryTimeout(this, 'PerRetryTimeout', this.__resources, this.input);
  }

  public get tcpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.http2Route.retryPolicy.tcpRetryEvents'),
        outputPath: 'route.spec.http2Route.retryPolicy.tcpRetryEvents',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.http2Route.retryPolicy.tcpRetryEvents', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.tcpRetryEvents') as unknown as string[];
  }

}

export class AppMeshUpdateRouteRouteSpecHttp2RouteRetryPolicyPerRetryTimeout extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.unit'),
        outputPath: 'route.spec.http2Route.retryPolicy.perRetryTimeout.unit',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.unit', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.perRetryTimeout.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.value'),
        outputPath: 'route.spec.http2Route.retryPolicy.perRetryTimeout.value',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.value', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.perRetryTimeout.value') as unknown as number;
  }

}

export class AppMeshUpdateRouteRouteSpecHttp2RouteTimeout extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get idle(): AppMeshUpdateRouteRouteSpecHttp2RouteTimeoutIdle {
    return new AppMeshUpdateRouteRouteSpecHttp2RouteTimeoutIdle(this, 'Idle', this.__resources, this.input);
  }

  public get perRequest(): AppMeshUpdateRouteRouteSpecHttp2RouteTimeoutPerRequest {
    return new AppMeshUpdateRouteRouteSpecHttp2RouteTimeoutPerRequest(this, 'PerRequest', this.__resources, this.input);
  }

}

export class AppMeshUpdateRouteRouteSpecHttp2RouteTimeoutIdle extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.http2Route.timeout.idle.unit'),
        outputPath: 'route.spec.http2Route.timeout.idle.unit',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.http2Route.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.http2Route.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.http2Route.timeout.idle.value'),
        outputPath: 'route.spec.http2Route.timeout.idle.value',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.http2Route.timeout.idle.value', props);
    return resource.getResponseField('route.spec.http2Route.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshUpdateRouteRouteSpecHttp2RouteTimeoutPerRequest extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.http2Route.timeout.perRequest.unit'),
        outputPath: 'route.spec.http2Route.timeout.perRequest.unit',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.http2Route.timeout.perRequest.unit', props);
    return resource.getResponseField('route.spec.http2Route.timeout.perRequest.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.http2Route.timeout.perRequest.value'),
        outputPath: 'route.spec.http2Route.timeout.perRequest.value',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.http2Route.timeout.perRequest.value', props);
    return resource.getResponseField('route.spec.http2Route.timeout.perRequest.value') as unknown as number;
  }

}

export class AppMeshUpdateRouteRouteSpecHttpRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get action(): AppMeshUpdateRouteRouteSpecHttpRouteAction {
    return new AppMeshUpdateRouteRouteSpecHttpRouteAction(this, 'Action', this.__resources, this.input);
  }

  public get match(): AppMeshUpdateRouteRouteSpecHttpRouteMatch {
    return new AppMeshUpdateRouteRouteSpecHttpRouteMatch(this, 'Match', this.__resources, this.input);
  }

  public get retryPolicy(): AppMeshUpdateRouteRouteSpecHttpRouteRetryPolicy {
    return new AppMeshUpdateRouteRouteSpecHttpRouteRetryPolicy(this, 'RetryPolicy', this.__resources, this.input);
  }

  public get timeout(): AppMeshUpdateRouteRouteSpecHttpRouteTimeout {
    return new AppMeshUpdateRouteRouteSpecHttpRouteTimeout(this, 'Timeout', this.__resources, this.input);
  }

}

export class AppMeshUpdateRouteRouteSpecHttpRouteAction extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.httpRoute.action.weightedTargets'),
        outputPath: 'route.spec.httpRoute.action.weightedTargets',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.httpRoute.action.weightedTargets', props);
    return resource.getResponseField('route.spec.httpRoute.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshUpdateRouteRouteSpecHttpRouteMatch extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get headers(): shapes.AppMeshHttpRouteHeader[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.httpRoute.match.headers'),
        outputPath: 'route.spec.httpRoute.match.headers',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.httpRoute.match.headers', props);
    return resource.getResponseField('route.spec.httpRoute.match.headers') as unknown as shapes.AppMeshHttpRouteHeader[];
  }

  public get method(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.httpRoute.match.method'),
        outputPath: 'route.spec.httpRoute.match.method',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.httpRoute.match.method', props);
    return resource.getResponseField('route.spec.httpRoute.match.method') as unknown as string;
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.httpRoute.match.prefix'),
        outputPath: 'route.spec.httpRoute.match.prefix',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.httpRoute.match.prefix', props);
    return resource.getResponseField('route.spec.httpRoute.match.prefix') as unknown as string;
  }

  public get scheme(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.httpRoute.match.scheme'),
        outputPath: 'route.spec.httpRoute.match.scheme',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.httpRoute.match.scheme', props);
    return resource.getResponseField('route.spec.httpRoute.match.scheme') as unknown as string;
  }

}

export class AppMeshUpdateRouteRouteSpecHttpRouteRetryPolicy extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get httpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.httpRoute.retryPolicy.httpRetryEvents'),
        outputPath: 'route.spec.httpRoute.retryPolicy.httpRetryEvents',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.httpRoute.retryPolicy.httpRetryEvents', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.httpRetryEvents') as unknown as string[];
  }

  public get maxRetries(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.httpRoute.retryPolicy.maxRetries'),
        outputPath: 'route.spec.httpRoute.retryPolicy.maxRetries',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.httpRoute.retryPolicy.maxRetries', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.maxRetries') as unknown as number;
  }

  public get perRetryTimeout(): AppMeshUpdateRouteRouteSpecHttpRouteRetryPolicyPerRetryTimeout {
    return new AppMeshUpdateRouteRouteSpecHttpRouteRetryPolicyPerRetryTimeout(this, 'PerRetryTimeout', this.__resources, this.input);
  }

  public get tcpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.httpRoute.retryPolicy.tcpRetryEvents'),
        outputPath: 'route.spec.httpRoute.retryPolicy.tcpRetryEvents',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.httpRoute.retryPolicy.tcpRetryEvents', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.tcpRetryEvents') as unknown as string[];
  }

}

export class AppMeshUpdateRouteRouteSpecHttpRouteRetryPolicyPerRetryTimeout extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.unit'),
        outputPath: 'route.spec.httpRoute.retryPolicy.perRetryTimeout.unit',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.unit', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.perRetryTimeout.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.value'),
        outputPath: 'route.spec.httpRoute.retryPolicy.perRetryTimeout.value',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.value', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.perRetryTimeout.value') as unknown as number;
  }

}

export class AppMeshUpdateRouteRouteSpecHttpRouteTimeout extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get idle(): AppMeshUpdateRouteRouteSpecHttpRouteTimeoutIdle {
    return new AppMeshUpdateRouteRouteSpecHttpRouteTimeoutIdle(this, 'Idle', this.__resources, this.input);
  }

  public get perRequest(): AppMeshUpdateRouteRouteSpecHttpRouteTimeoutPerRequest {
    return new AppMeshUpdateRouteRouteSpecHttpRouteTimeoutPerRequest(this, 'PerRequest', this.__resources, this.input);
  }

}

export class AppMeshUpdateRouteRouteSpecHttpRouteTimeoutIdle extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.httpRoute.timeout.idle.unit'),
        outputPath: 'route.spec.httpRoute.timeout.idle.unit',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.httpRoute.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.httpRoute.timeout.idle.value'),
        outputPath: 'route.spec.httpRoute.timeout.idle.value',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.httpRoute.timeout.idle.value', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshUpdateRouteRouteSpecHttpRouteTimeoutPerRequest extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.httpRoute.timeout.perRequest.unit'),
        outputPath: 'route.spec.httpRoute.timeout.perRequest.unit',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.httpRoute.timeout.perRequest.unit', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.perRequest.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.httpRoute.timeout.perRequest.value'),
        outputPath: 'route.spec.httpRoute.timeout.perRequest.value',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.httpRoute.timeout.perRequest.value', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.perRequest.value') as unknown as number;
  }

}

export class AppMeshUpdateRouteRouteSpecTcpRoute extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get action(): AppMeshUpdateRouteRouteSpecTcpRouteAction {
    return new AppMeshUpdateRouteRouteSpecTcpRouteAction(this, 'Action', this.__resources, this.input);
  }

  public get timeout(): AppMeshUpdateRouteRouteSpecTcpRouteTimeout {
    return new AppMeshUpdateRouteRouteSpecTcpRouteTimeout(this, 'Timeout', this.__resources, this.input);
  }

}

export class AppMeshUpdateRouteRouteSpecTcpRouteAction extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.tcpRoute.action.weightedTargets'),
        outputPath: 'route.spec.tcpRoute.action.weightedTargets',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.tcpRoute.action.weightedTargets', props);
    return resource.getResponseField('route.spec.tcpRoute.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshUpdateRouteRouteSpecTcpRouteTimeout extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get idle(): AppMeshUpdateRouteRouteSpecTcpRouteTimeoutIdle {
    return new AppMeshUpdateRouteRouteSpecTcpRouteTimeoutIdle(this, 'Idle', this.__resources, this.input);
  }

}

export class AppMeshUpdateRouteRouteSpecTcpRouteTimeoutIdle extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.tcpRoute.timeout.idle.unit'),
        outputPath: 'route.spec.tcpRoute.timeout.idle.unit',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.tcpRoute.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.tcpRoute.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.tcpRoute.timeout.idle.value'),
        outputPath: 'route.spec.tcpRoute.timeout.idle.value',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.spec.tcpRoute.timeout.idle.value', props);
    return resource.getResponseField('route.spec.tcpRoute.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshUpdateRouteRouteStatus extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateRouteInput) {
    super(scope, id);
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.status.status'),
        outputPath: 'route.status.status',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          routeName: this.input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.input.spec.grpcRoute?.match.metadata,
                methodName: this.input.spec.grpcRoute?.match.methodName,
                serviceName: this.input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.http2Route?.match.headers,
                method: this.input.spec.http2Route?.match.method,
                prefix: this.input.spec.http2Route?.match.prefix,
                scheme: this.input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.input.spec.httpRoute?.match.headers,
                method: this.input.spec.httpRoute?.match.method,
                prefix: this.input.spec.httpRoute?.match.prefix,
                scheme: this.input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateRoute.route.status.status', props);
    return resource.getResponseField('route.status.status') as unknown as string;
  }

}

export class AppMeshUpdateVirtualGateway extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualGatewayInput) {
    super(scope, id);
  }

  public get virtualGateway(): AppMeshUpdateVirtualGatewayVirtualGateway {
    return new AppMeshUpdateVirtualGatewayVirtualGateway(this, 'VirtualGateway', this.__resources, this.input);
  }

}

export class AppMeshUpdateVirtualGatewayVirtualGateway extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualGatewayInput) {
    super(scope, id);
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.meshName'),
        outputPath: 'virtualGateway.meshName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualGateway.virtualGateway.meshName', props);
    return resource.getResponseField('virtualGateway.meshName') as unknown as string;
  }

  public get metadata(): AppMeshUpdateVirtualGatewayVirtualGatewayMetadata {
    return new AppMeshUpdateVirtualGatewayVirtualGatewayMetadata(this, 'Metadata', this.__resources, this.input);
  }

  public get spec(): AppMeshUpdateVirtualGatewayVirtualGatewaySpec {
    return new AppMeshUpdateVirtualGatewayVirtualGatewaySpec(this, 'Spec', this.__resources, this.input);
  }

  public get status(): AppMeshUpdateVirtualGatewayVirtualGatewayStatus {
    return new AppMeshUpdateVirtualGatewayVirtualGatewayStatus(this, 'Status', this.__resources, this.input);
  }

  public get virtualGatewayName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.virtualGatewayName'),
        outputPath: 'virtualGateway.virtualGatewayName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualGateway.virtualGateway.virtualGatewayName', props);
    return resource.getResponseField('virtualGateway.virtualGatewayName') as unknown as string;
  }

}

export class AppMeshUpdateVirtualGatewayVirtualGatewayMetadata extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualGatewayInput) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.metadata.arn'),
        outputPath: 'virtualGateway.metadata.arn',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualGateway.virtualGateway.metadata.arn', props);
    return resource.getResponseField('virtualGateway.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.metadata.createdAt'),
        outputPath: 'virtualGateway.metadata.createdAt',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualGateway.virtualGateway.metadata.createdAt', props);
    return resource.getResponseField('virtualGateway.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.metadata.lastUpdatedAt'),
        outputPath: 'virtualGateway.metadata.lastUpdatedAt',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualGateway.virtualGateway.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualGateway.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.metadata.meshOwner'),
        outputPath: 'virtualGateway.metadata.meshOwner',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualGateway.virtualGateway.metadata.meshOwner', props);
    return resource.getResponseField('virtualGateway.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.metadata.resourceOwner'),
        outputPath: 'virtualGateway.metadata.resourceOwner',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualGateway.virtualGateway.metadata.resourceOwner', props);
    return resource.getResponseField('virtualGateway.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.metadata.uid'),
        outputPath: 'virtualGateway.metadata.uid',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualGateway.virtualGateway.metadata.uid', props);
    return resource.getResponseField('virtualGateway.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.metadata.version'),
        outputPath: 'virtualGateway.metadata.version',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualGateway.virtualGateway.metadata.version', props);
    return resource.getResponseField('virtualGateway.metadata.version') as unknown as number;
  }

}

export class AppMeshUpdateVirtualGatewayVirtualGatewaySpec extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualGatewayInput) {
    super(scope, id);
  }

  public get backendDefaults(): AppMeshUpdateVirtualGatewayVirtualGatewaySpecBackendDefaults {
    return new AppMeshUpdateVirtualGatewayVirtualGatewaySpecBackendDefaults(this, 'BackendDefaults', this.__resources, this.input);
  }

  public get listeners(): shapes.AppMeshVirtualGatewayListener[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.spec.listeners'),
        outputPath: 'virtualGateway.spec.listeners',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualGateway.virtualGateway.spec.listeners', props);
    return resource.getResponseField('virtualGateway.spec.listeners') as unknown as shapes.AppMeshVirtualGatewayListener[];
  }

  public get logging(): AppMeshUpdateVirtualGatewayVirtualGatewaySpecLogging {
    return new AppMeshUpdateVirtualGatewayVirtualGatewaySpecLogging(this, 'Logging', this.__resources, this.input);
  }

}

export class AppMeshUpdateVirtualGatewayVirtualGatewaySpecBackendDefaults extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualGatewayInput) {
    super(scope, id);
  }

  public get clientPolicy(): AppMeshUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicy {
    return new AppMeshUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicy(this, 'ClientPolicy', this.__resources, this.input);
  }

}

export class AppMeshUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicy extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualGatewayInput) {
    super(scope, id);
  }

  public get tls(): AppMeshUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTls {
    return new AppMeshUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTls(this, 'Tls', this.__resources, this.input);
  }

}

export class AppMeshUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTls extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualGatewayInput) {
    super(scope, id);
  }

  public get enforce(): boolean {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce') as unknown as boolean;
  }

  public get ports(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.ports'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.ports',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.ports', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.ports') as unknown as number[];
  }

  public get validation(): AppMeshUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation {
    return new AppMeshUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation(this, 'Validation', this.__resources, this.input);
  }

}

export class AppMeshUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualGatewayInput) {
    super(scope, id);
  }

  public get trust(): AppMeshUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust {
    return new AppMeshUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust(this, 'Trust', this.__resources, this.input);
  }

}

export class AppMeshUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualGatewayInput) {
    super(scope, id);
  }

  public get acm(): AppMeshUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
    return new AppMeshUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm(this, 'Acm', this.__resources, this.input);
  }

  public get file(): AppMeshUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile {
    return new AppMeshUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile(this, 'File', this.__resources, this.input);
  }

}

export class AppMeshUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualGatewayInput) {
    super(scope, id);
  }

  public get certificateAuthorityArns(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns') as unknown as string[];
  }

}

export class AppMeshUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualGatewayInput) {
    super(scope, id);
  }

  public get certificateChain(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain') as unknown as string;
  }

}

export class AppMeshUpdateVirtualGatewayVirtualGatewaySpecLogging extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualGatewayInput) {
    super(scope, id);
  }

  public get accessLog(): AppMeshUpdateVirtualGatewayVirtualGatewaySpecLoggingAccessLog {
    return new AppMeshUpdateVirtualGatewayVirtualGatewaySpecLoggingAccessLog(this, 'AccessLog', this.__resources, this.input);
  }

}

export class AppMeshUpdateVirtualGatewayVirtualGatewaySpecLoggingAccessLog extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualGatewayInput) {
    super(scope, id);
  }

  public get file(): AppMeshUpdateVirtualGatewayVirtualGatewaySpecLoggingAccessLogFile {
    return new AppMeshUpdateVirtualGatewayVirtualGatewaySpecLoggingAccessLogFile(this, 'File', this.__resources, this.input);
  }

}

export class AppMeshUpdateVirtualGatewayVirtualGatewaySpecLoggingAccessLogFile extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualGatewayInput) {
    super(scope, id);
  }

  public get path(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.spec.logging.accessLog.file.path'),
        outputPath: 'virtualGateway.spec.logging.accessLog.file.path',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualGateway.virtualGateway.spec.logging.accessLog.file.path', props);
    return resource.getResponseField('virtualGateway.spec.logging.accessLog.file.path') as unknown as string;
  }

}

export class AppMeshUpdateVirtualGatewayVirtualGatewayStatus extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualGatewayInput) {
    super(scope, id);
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.status.status'),
        outputPath: 'virtualGateway.status.status',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualGateway.virtualGateway.status.status', props);
    return resource.getResponseField('virtualGateway.status.status') as unknown as string;
  }

}

export class AppMeshUpdateVirtualNode extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualNodeInput) {
    super(scope, id);
  }

  public get virtualNode(): AppMeshUpdateVirtualNodeVirtualNode {
    return new AppMeshUpdateVirtualNodeVirtualNode(this, 'VirtualNode', this.__resources, this.input);
  }

}

export class AppMeshUpdateVirtualNodeVirtualNode extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualNodeInput) {
    super(scope, id);
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.meshName'),
        outputPath: 'virtualNode.meshName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualNode.virtualNode.meshName', props);
    return resource.getResponseField('virtualNode.meshName') as unknown as string;
  }

  public get metadata(): AppMeshUpdateVirtualNodeVirtualNodeMetadata {
    return new AppMeshUpdateVirtualNodeVirtualNodeMetadata(this, 'Metadata', this.__resources, this.input);
  }

  public get spec(): AppMeshUpdateVirtualNodeVirtualNodeSpec {
    return new AppMeshUpdateVirtualNodeVirtualNodeSpec(this, 'Spec', this.__resources, this.input);
  }

  public get status(): AppMeshUpdateVirtualNodeVirtualNodeStatus {
    return new AppMeshUpdateVirtualNodeVirtualNodeStatus(this, 'Status', this.__resources, this.input);
  }

  public get virtualNodeName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.virtualNodeName'),
        outputPath: 'virtualNode.virtualNodeName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualNode.virtualNode.virtualNodeName', props);
    return resource.getResponseField('virtualNode.virtualNodeName') as unknown as string;
  }

}

export class AppMeshUpdateVirtualNodeVirtualNodeMetadata extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualNodeInput) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.metadata.arn'),
        outputPath: 'virtualNode.metadata.arn',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualNode.virtualNode.metadata.arn', props);
    return resource.getResponseField('virtualNode.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.metadata.createdAt'),
        outputPath: 'virtualNode.metadata.createdAt',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualNode.virtualNode.metadata.createdAt', props);
    return resource.getResponseField('virtualNode.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.metadata.lastUpdatedAt'),
        outputPath: 'virtualNode.metadata.lastUpdatedAt',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualNode.virtualNode.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualNode.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.metadata.meshOwner'),
        outputPath: 'virtualNode.metadata.meshOwner',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualNode.virtualNode.metadata.meshOwner', props);
    return resource.getResponseField('virtualNode.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.metadata.resourceOwner'),
        outputPath: 'virtualNode.metadata.resourceOwner',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualNode.virtualNode.metadata.resourceOwner', props);
    return resource.getResponseField('virtualNode.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.metadata.uid'),
        outputPath: 'virtualNode.metadata.uid',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualNode.virtualNode.metadata.uid', props);
    return resource.getResponseField('virtualNode.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.metadata.version'),
        outputPath: 'virtualNode.metadata.version',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualNode.virtualNode.metadata.version', props);
    return resource.getResponseField('virtualNode.metadata.version') as unknown as number;
  }

}

export class AppMeshUpdateVirtualNodeVirtualNodeSpec extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualNodeInput) {
    super(scope, id);
  }

  public get backendDefaults(): AppMeshUpdateVirtualNodeVirtualNodeSpecBackendDefaults {
    return new AppMeshUpdateVirtualNodeVirtualNodeSpecBackendDefaults(this, 'BackendDefaults', this.__resources, this.input);
  }

  public get backends(): shapes.AppMeshBackend[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.spec.backends'),
        outputPath: 'virtualNode.spec.backends',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualNode.virtualNode.spec.backends', props);
    return resource.getResponseField('virtualNode.spec.backends') as unknown as shapes.AppMeshBackend[];
  }

  public get listeners(): shapes.AppMeshListener[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.spec.listeners'),
        outputPath: 'virtualNode.spec.listeners',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualNode.virtualNode.spec.listeners', props);
    return resource.getResponseField('virtualNode.spec.listeners') as unknown as shapes.AppMeshListener[];
  }

  public get logging(): AppMeshUpdateVirtualNodeVirtualNodeSpecLogging {
    return new AppMeshUpdateVirtualNodeVirtualNodeSpecLogging(this, 'Logging', this.__resources, this.input);
  }

  public get serviceDiscovery(): AppMeshUpdateVirtualNodeVirtualNodeSpecServiceDiscovery {
    return new AppMeshUpdateVirtualNodeVirtualNodeSpecServiceDiscovery(this, 'ServiceDiscovery', this.__resources, this.input);
  }

}

export class AppMeshUpdateVirtualNodeVirtualNodeSpecBackendDefaults extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualNodeInput) {
    super(scope, id);
  }

  public get clientPolicy(): AppMeshUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicy {
    return new AppMeshUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicy(this, 'ClientPolicy', this.__resources, this.input);
  }

}

export class AppMeshUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicy extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualNodeInput) {
    super(scope, id);
  }

  public get tls(): AppMeshUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTls {
    return new AppMeshUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTls(this, 'Tls', this.__resources, this.input);
  }

}

export class AppMeshUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTls extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualNodeInput) {
    super(scope, id);
  }

  public get enforce(): boolean {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.enforce'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.enforce',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.enforce', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.enforce') as unknown as boolean;
  }

  public get ports(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.ports'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.ports',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.ports', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.ports') as unknown as number[];
  }

  public get validation(): AppMeshUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidation {
    return new AppMeshUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidation(this, 'Validation', this.__resources, this.input);
  }

}

export class AppMeshUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidation extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualNodeInput) {
    super(scope, id);
  }

  public get trust(): AppMeshUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust {
    return new AppMeshUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust(this, 'Trust', this.__resources, this.input);
  }

}

export class AppMeshUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualNodeInput) {
    super(scope, id);
  }

  public get acm(): AppMeshUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
    return new AppMeshUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm(this, 'Acm', this.__resources, this.input);
  }

  public get file(): AppMeshUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile {
    return new AppMeshUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile(this, 'File', this.__resources, this.input);
  }

}

export class AppMeshUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualNodeInput) {
    super(scope, id);
  }

  public get certificateAuthorityArns(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns') as unknown as string[];
  }

}

export class AppMeshUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualNodeInput) {
    super(scope, id);
  }

  public get certificateChain(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain') as unknown as string;
  }

}

export class AppMeshUpdateVirtualNodeVirtualNodeSpecLogging extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualNodeInput) {
    super(scope, id);
  }

  public get accessLog(): AppMeshUpdateVirtualNodeVirtualNodeSpecLoggingAccessLog {
    return new AppMeshUpdateVirtualNodeVirtualNodeSpecLoggingAccessLog(this, 'AccessLog', this.__resources, this.input);
  }

}

export class AppMeshUpdateVirtualNodeVirtualNodeSpecLoggingAccessLog extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualNodeInput) {
    super(scope, id);
  }

  public get file(): AppMeshUpdateVirtualNodeVirtualNodeSpecLoggingAccessLogFile {
    return new AppMeshUpdateVirtualNodeVirtualNodeSpecLoggingAccessLogFile(this, 'File', this.__resources, this.input);
  }

}

export class AppMeshUpdateVirtualNodeVirtualNodeSpecLoggingAccessLogFile extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualNodeInput) {
    super(scope, id);
  }

  public get path(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.spec.logging.accessLog.file.path'),
        outputPath: 'virtualNode.spec.logging.accessLog.file.path',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualNode.virtualNode.spec.logging.accessLog.file.path', props);
    return resource.getResponseField('virtualNode.spec.logging.accessLog.file.path') as unknown as string;
  }

}

export class AppMeshUpdateVirtualNodeVirtualNodeSpecServiceDiscovery extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualNodeInput) {
    super(scope, id);
  }

  public get awsCloudMap(): AppMeshUpdateVirtualNodeVirtualNodeSpecServiceDiscoveryAwsCloudMap {
    return new AppMeshUpdateVirtualNodeVirtualNodeSpecServiceDiscoveryAwsCloudMap(this, 'AwsCloudMap', this.__resources, this.input);
  }

  public get dns(): AppMeshUpdateVirtualNodeVirtualNodeSpecServiceDiscoveryDns {
    return new AppMeshUpdateVirtualNodeVirtualNodeSpecServiceDiscoveryDns(this, 'Dns', this.__resources, this.input);
  }

}

export class AppMeshUpdateVirtualNodeVirtualNodeSpecServiceDiscoveryAwsCloudMap extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualNodeInput) {
    super(scope, id);
  }

  public get attributes(): shapes.AppMeshAwsCloudMapInstanceAttribute[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.attributes'),
        outputPath: 'virtualNode.spec.serviceDiscovery.awsCloudMap.attributes',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.attributes', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.awsCloudMap.attributes') as unknown as shapes.AppMeshAwsCloudMapInstanceAttribute[];
  }

  public get namespaceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName'),
        outputPath: 'virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName') as unknown as string;
  }

  public get serviceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName'),
        outputPath: 'virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName') as unknown as string;
  }

}

export class AppMeshUpdateVirtualNodeVirtualNodeSpecServiceDiscoveryDns extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualNodeInput) {
    super(scope, id);
  }

  public get hostname(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.spec.serviceDiscovery.dns.hostname'),
        outputPath: 'virtualNode.spec.serviceDiscovery.dns.hostname',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualNode.virtualNode.spec.serviceDiscovery.dns.hostname', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.dns.hostname') as unknown as string;
  }

}

export class AppMeshUpdateVirtualNodeVirtualNodeStatus extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualNodeInput) {
    super(scope, id);
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.status.status'),
        outputPath: 'virtualNode.status.status',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.input.spec.backends,
            listeners: this.input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualNode.virtualNode.status.status', props);
    return resource.getResponseField('virtualNode.status.status') as unknown as string;
  }

}

export class AppMeshUpdateVirtualRouter extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualRouterInput) {
    super(scope, id);
  }

  public get virtualRouter(): AppMeshUpdateVirtualRouterVirtualRouter {
    return new AppMeshUpdateVirtualRouterVirtualRouter(this, 'VirtualRouter', this.__resources, this.input);
  }

}

export class AppMeshUpdateVirtualRouterVirtualRouter extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualRouterInput) {
    super(scope, id);
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualRouter.virtualRouter.meshName'),
        outputPath: 'virtualRouter.meshName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            listeners: this.input.spec.listeners,
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualRouter.virtualRouter.meshName', props);
    return resource.getResponseField('virtualRouter.meshName') as unknown as string;
  }

  public get metadata(): AppMeshUpdateVirtualRouterVirtualRouterMetadata {
    return new AppMeshUpdateVirtualRouterVirtualRouterMetadata(this, 'Metadata', this.__resources, this.input);
  }

  public get spec(): AppMeshUpdateVirtualRouterVirtualRouterSpec {
    return new AppMeshUpdateVirtualRouterVirtualRouterSpec(this, 'Spec', this.__resources, this.input);
  }

  public get status(): AppMeshUpdateVirtualRouterVirtualRouterStatus {
    return new AppMeshUpdateVirtualRouterVirtualRouterStatus(this, 'Status', this.__resources, this.input);
  }

  public get virtualRouterName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualRouter.virtualRouter.virtualRouterName'),
        outputPath: 'virtualRouter.virtualRouterName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            listeners: this.input.spec.listeners,
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualRouter.virtualRouter.virtualRouterName', props);
    return resource.getResponseField('virtualRouter.virtualRouterName') as unknown as string;
  }

}

export class AppMeshUpdateVirtualRouterVirtualRouterMetadata extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualRouterInput) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualRouter.virtualRouter.metadata.arn'),
        outputPath: 'virtualRouter.metadata.arn',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            listeners: this.input.spec.listeners,
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualRouter.virtualRouter.metadata.arn', props);
    return resource.getResponseField('virtualRouter.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualRouter.virtualRouter.metadata.createdAt'),
        outputPath: 'virtualRouter.metadata.createdAt',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            listeners: this.input.spec.listeners,
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualRouter.virtualRouter.metadata.createdAt', props);
    return resource.getResponseField('virtualRouter.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualRouter.virtualRouter.metadata.lastUpdatedAt'),
        outputPath: 'virtualRouter.metadata.lastUpdatedAt',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            listeners: this.input.spec.listeners,
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualRouter.virtualRouter.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualRouter.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualRouter.virtualRouter.metadata.meshOwner'),
        outputPath: 'virtualRouter.metadata.meshOwner',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            listeners: this.input.spec.listeners,
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualRouter.virtualRouter.metadata.meshOwner', props);
    return resource.getResponseField('virtualRouter.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualRouter.virtualRouter.metadata.resourceOwner'),
        outputPath: 'virtualRouter.metadata.resourceOwner',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            listeners: this.input.spec.listeners,
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualRouter.virtualRouter.metadata.resourceOwner', props);
    return resource.getResponseField('virtualRouter.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualRouter.virtualRouter.metadata.uid'),
        outputPath: 'virtualRouter.metadata.uid',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            listeners: this.input.spec.listeners,
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualRouter.virtualRouter.metadata.uid', props);
    return resource.getResponseField('virtualRouter.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualRouter.virtualRouter.metadata.version'),
        outputPath: 'virtualRouter.metadata.version',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            listeners: this.input.spec.listeners,
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualRouter.virtualRouter.metadata.version', props);
    return resource.getResponseField('virtualRouter.metadata.version') as unknown as number;
  }

}

export class AppMeshUpdateVirtualRouterVirtualRouterSpec extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualRouterInput) {
    super(scope, id);
  }

  public get listeners(): shapes.AppMeshVirtualRouterListener[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualRouter.virtualRouter.spec.listeners'),
        outputPath: 'virtualRouter.spec.listeners',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            listeners: this.input.spec.listeners,
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualRouter.virtualRouter.spec.listeners', props);
    return resource.getResponseField('virtualRouter.spec.listeners') as unknown as shapes.AppMeshVirtualRouterListener[];
  }

}

export class AppMeshUpdateVirtualRouterVirtualRouterStatus extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualRouterInput) {
    super(scope, id);
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualRouter.virtualRouter.status.status'),
        outputPath: 'virtualRouter.status.status',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            listeners: this.input.spec.listeners,
          },
          virtualRouterName: this.input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualRouter.virtualRouter.status.status', props);
    return resource.getResponseField('virtualRouter.status.status') as unknown as string;
  }

}

export class AppMeshUpdateVirtualService extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualServiceInput) {
    super(scope, id);
  }

  public get virtualService(): AppMeshUpdateVirtualServiceVirtualService {
    return new AppMeshUpdateVirtualServiceVirtualService(this, 'VirtualService', this.__resources, this.input);
  }

}

export class AppMeshUpdateVirtualServiceVirtualService extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualServiceInput) {
    super(scope, id);
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualService.virtualService.meshName'),
        outputPath: 'virtualService.meshName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualService.virtualService.meshName', props);
    return resource.getResponseField('virtualService.meshName') as unknown as string;
  }

  public get metadata(): AppMeshUpdateVirtualServiceVirtualServiceMetadata {
    return new AppMeshUpdateVirtualServiceVirtualServiceMetadata(this, 'Metadata', this.__resources, this.input);
  }

  public get spec(): AppMeshUpdateVirtualServiceVirtualServiceSpec {
    return new AppMeshUpdateVirtualServiceVirtualServiceSpec(this, 'Spec', this.__resources, this.input);
  }

  public get status(): AppMeshUpdateVirtualServiceVirtualServiceStatus {
    return new AppMeshUpdateVirtualServiceVirtualServiceStatus(this, 'Status', this.__resources, this.input);
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualService.virtualService.virtualServiceName'),
        outputPath: 'virtualService.virtualServiceName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualService.virtualService.virtualServiceName', props);
    return resource.getResponseField('virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshUpdateVirtualServiceVirtualServiceMetadata extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualServiceInput) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualService.virtualService.metadata.arn'),
        outputPath: 'virtualService.metadata.arn',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualService.virtualService.metadata.arn', props);
    return resource.getResponseField('virtualService.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualService.virtualService.metadata.createdAt'),
        outputPath: 'virtualService.metadata.createdAt',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualService.virtualService.metadata.createdAt', props);
    return resource.getResponseField('virtualService.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualService.virtualService.metadata.lastUpdatedAt'),
        outputPath: 'virtualService.metadata.lastUpdatedAt',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualService.virtualService.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualService.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualService.virtualService.metadata.meshOwner'),
        outputPath: 'virtualService.metadata.meshOwner',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualService.virtualService.metadata.meshOwner', props);
    return resource.getResponseField('virtualService.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualService.virtualService.metadata.resourceOwner'),
        outputPath: 'virtualService.metadata.resourceOwner',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualService.virtualService.metadata.resourceOwner', props);
    return resource.getResponseField('virtualService.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualService.virtualService.metadata.uid'),
        outputPath: 'virtualService.metadata.uid',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualService.virtualService.metadata.uid', props);
    return resource.getResponseField('virtualService.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualService.virtualService.metadata.version'),
        outputPath: 'virtualService.metadata.version',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualService.virtualService.metadata.version', props);
    return resource.getResponseField('virtualService.metadata.version') as unknown as number;
  }

}

export class AppMeshUpdateVirtualServiceVirtualServiceSpec extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualServiceInput) {
    super(scope, id);
  }

  public get provider(): AppMeshUpdateVirtualServiceVirtualServiceSpecProvider {
    return new AppMeshUpdateVirtualServiceVirtualServiceSpecProvider(this, 'Provider', this.__resources, this.input);
  }

}

export class AppMeshUpdateVirtualServiceVirtualServiceSpecProvider extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualServiceInput) {
    super(scope, id);
  }

  public get virtualNode(): AppMeshUpdateVirtualServiceVirtualServiceSpecProviderVirtualNode {
    return new AppMeshUpdateVirtualServiceVirtualServiceSpecProviderVirtualNode(this, 'VirtualNode', this.__resources, this.input);
  }

  public get virtualRouter(): AppMeshUpdateVirtualServiceVirtualServiceSpecProviderVirtualRouter {
    return new AppMeshUpdateVirtualServiceVirtualServiceSpecProviderVirtualRouter(this, 'VirtualRouter', this.__resources, this.input);
  }

}

export class AppMeshUpdateVirtualServiceVirtualServiceSpecProviderVirtualNode extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualServiceInput) {
    super(scope, id);
  }

  public get virtualNodeName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualService.virtualService.spec.provider.virtualNode.virtualNodeName'),
        outputPath: 'virtualService.spec.provider.virtualNode.virtualNodeName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualService.virtualService.spec.provider.virtualNode.virtualNodeName', props);
    return resource.getResponseField('virtualService.spec.provider.virtualNode.virtualNodeName') as unknown as string;
  }

}

export class AppMeshUpdateVirtualServiceVirtualServiceSpecProviderVirtualRouter extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualServiceInput) {
    super(scope, id);
  }

  public get virtualRouterName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualService.virtualService.spec.provider.virtualRouter.virtualRouterName'),
        outputPath: 'virtualService.spec.provider.virtualRouter.virtualRouterName',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualService.virtualService.spec.provider.virtualRouter.virtualRouterName', props);
    return resource.getResponseField('virtualService.spec.provider.virtualRouter.virtualRouterName') as unknown as string;
  }

}

export class AppMeshUpdateVirtualServiceVirtualServiceStatus extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.AppMeshUpdateVirtualServiceInput) {
    super(scope, id);
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualService.virtualService.status.status'),
        outputPath: 'virtualService.status.status',
        parameters: {
          clientToken: this.input.clientToken,
          meshName: this.input.meshName,
          meshOwner: this.input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          virtualServiceName: this.input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateVirtualService.virtualService.status.status', props);
    return resource.getResponseField('virtualService.status.status') as unknown as string;
  }

}


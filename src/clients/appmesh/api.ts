import * as cdk from '@aws-cdk/core';
import * as cr from '@aws-cdk/custom-resources';
import * as shapes from './shapes';

export class AppMeshClient extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[]) {
    super(scope, id);
  }

  public createGatewayRoute(input: shapes.AppMeshCreateGatewayRouteInput): AppMeshResponsesCreateGatewayRoute {
    return new AppMeshResponsesCreateGatewayRoute(this, this.__resources, input);
  }

  public createMesh(input: shapes.AppMeshCreateMeshInput): AppMeshResponsesCreateMesh {
    return new AppMeshResponsesCreateMesh(this, this.__resources, input);
  }

  public createRoute(input: shapes.AppMeshCreateRouteInput): AppMeshResponsesCreateRoute {
    return new AppMeshResponsesCreateRoute(this, this.__resources, input);
  }

  public createVirtualGateway(input: shapes.AppMeshCreateVirtualGatewayInput): AppMeshResponsesCreateVirtualGateway {
    return new AppMeshResponsesCreateVirtualGateway(this, this.__resources, input);
  }

  public createVirtualNode(input: shapes.AppMeshCreateVirtualNodeInput): AppMeshResponsesCreateVirtualNode {
    return new AppMeshResponsesCreateVirtualNode(this, this.__resources, input);
  }

  public createVirtualRouter(input: shapes.AppMeshCreateVirtualRouterInput): AppMeshResponsesCreateVirtualRouter {
    return new AppMeshResponsesCreateVirtualRouter(this, this.__resources, input);
  }

  public createVirtualService(input: shapes.AppMeshCreateVirtualServiceInput): AppMeshResponsesCreateVirtualService {
    return new AppMeshResponsesCreateVirtualService(this, this.__resources, input);
  }

  public deleteGatewayRoute(input: shapes.AppMeshDeleteGatewayRouteInput): AppMeshResponsesDeleteGatewayRoute {
    return new AppMeshResponsesDeleteGatewayRoute(this, this.__resources, input);
  }

  public deleteMesh(input: shapes.AppMeshDeleteMeshInput): AppMeshResponsesDeleteMesh {
    return new AppMeshResponsesDeleteMesh(this, this.__resources, input);
  }

  public deleteRoute(input: shapes.AppMeshDeleteRouteInput): AppMeshResponsesDeleteRoute {
    return new AppMeshResponsesDeleteRoute(this, this.__resources, input);
  }

  public deleteVirtualGateway(input: shapes.AppMeshDeleteVirtualGatewayInput): AppMeshResponsesDeleteVirtualGateway {
    return new AppMeshResponsesDeleteVirtualGateway(this, this.__resources, input);
  }

  public deleteVirtualNode(input: shapes.AppMeshDeleteVirtualNodeInput): AppMeshResponsesDeleteVirtualNode {
    return new AppMeshResponsesDeleteVirtualNode(this, this.__resources, input);
  }

  public deleteVirtualRouter(input: shapes.AppMeshDeleteVirtualRouterInput): AppMeshResponsesDeleteVirtualRouter {
    return new AppMeshResponsesDeleteVirtualRouter(this, this.__resources, input);
  }

  public deleteVirtualService(input: shapes.AppMeshDeleteVirtualServiceInput): AppMeshResponsesDeleteVirtualService {
    return new AppMeshResponsesDeleteVirtualService(this, this.__resources, input);
  }

  public describeGatewayRoute(input: shapes.AppMeshDescribeGatewayRouteInput): AppMeshResponsesDescribeGatewayRoute {
    return new AppMeshResponsesDescribeGatewayRoute(this, this.__resources, input);
  }

  public describeMesh(input: shapes.AppMeshDescribeMeshInput): AppMeshResponsesDescribeMesh {
    return new AppMeshResponsesDescribeMesh(this, this.__resources, input);
  }

  public describeRoute(input: shapes.AppMeshDescribeRouteInput): AppMeshResponsesDescribeRoute {
    return new AppMeshResponsesDescribeRoute(this, this.__resources, input);
  }

  public describeVirtualGateway(input: shapes.AppMeshDescribeVirtualGatewayInput): AppMeshResponsesDescribeVirtualGateway {
    return new AppMeshResponsesDescribeVirtualGateway(this, this.__resources, input);
  }

  public describeVirtualNode(input: shapes.AppMeshDescribeVirtualNodeInput): AppMeshResponsesDescribeVirtualNode {
    return new AppMeshResponsesDescribeVirtualNode(this, this.__resources, input);
  }

  public describeVirtualRouter(input: shapes.AppMeshDescribeVirtualRouterInput): AppMeshResponsesDescribeVirtualRouter {
    return new AppMeshResponsesDescribeVirtualRouter(this, this.__resources, input);
  }

  public describeVirtualService(input: shapes.AppMeshDescribeVirtualServiceInput): AppMeshResponsesDescribeVirtualService {
    return new AppMeshResponsesDescribeVirtualService(this, this.__resources, input);
  }

  public listGatewayRoutes(input: shapes.AppMeshListGatewayRoutesInput): AppMeshResponsesListGatewayRoutes {
    return new AppMeshResponsesListGatewayRoutes(this, this.__resources, input);
  }

  public listMeshes(input: shapes.AppMeshListMeshesInput): AppMeshResponsesListMeshes {
    return new AppMeshResponsesListMeshes(this, this.__resources, input);
  }

  public listRoutes(input: shapes.AppMeshListRoutesInput): AppMeshResponsesListRoutes {
    return new AppMeshResponsesListRoutes(this, this.__resources, input);
  }

  public listTagsForResource(input: shapes.AppMeshListTagsForResourceInput): AppMeshResponsesListTagsForResource {
    return new AppMeshResponsesListTagsForResource(this, this.__resources, input);
  }

  public listVirtualGateways(input: shapes.AppMeshListVirtualGatewaysInput): AppMeshResponsesListVirtualGateways {
    return new AppMeshResponsesListVirtualGateways(this, this.__resources, input);
  }

  public listVirtualNodes(input: shapes.AppMeshListVirtualNodesInput): AppMeshResponsesListVirtualNodes {
    return new AppMeshResponsesListVirtualNodes(this, this.__resources, input);
  }

  public listVirtualRouters(input: shapes.AppMeshListVirtualRoutersInput): AppMeshResponsesListVirtualRouters {
    return new AppMeshResponsesListVirtualRouters(this, this.__resources, input);
  }

  public listVirtualServices(input: shapes.AppMeshListVirtualServicesInput): AppMeshResponsesListVirtualServices {
    return new AppMeshResponsesListVirtualServices(this, this.__resources, input);
  }

  public tagResource(input: shapes.AppMeshTagResourceInput): void {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'tagResource',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.TagResource'),
        parameters: {
          resourceArn: input.resourceArn,
          tags: input.tags,
        },
      },
    };
    new cr.AwsCustomResource(this, 'TagResource', props);
  }

  public untagResource(input: shapes.AppMeshUntagResourceInput): void {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'untagResource',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UntagResource'),
        parameters: {
          resourceArn: input.resourceArn,
          tagKeys: input.tagKeys,
        },
      },
    };
    new cr.AwsCustomResource(this, 'UntagResource', props);
  }

  public updateGatewayRoute(input: shapes.AppMeshUpdateGatewayRouteInput): AppMeshResponsesUpdateGatewayRoute {
    return new AppMeshResponsesUpdateGatewayRoute(this, this.__resources, input);
  }

  public updateMesh(input: shapes.AppMeshUpdateMeshInput): AppMeshResponsesUpdateMesh {
    return new AppMeshResponsesUpdateMesh(this, this.__resources, input);
  }

  public updateRoute(input: shapes.AppMeshUpdateRouteInput): AppMeshResponsesUpdateRoute {
    return new AppMeshResponsesUpdateRoute(this, this.__resources, input);
  }

  public updateVirtualGateway(input: shapes.AppMeshUpdateVirtualGatewayInput): AppMeshResponsesUpdateVirtualGateway {
    return new AppMeshResponsesUpdateVirtualGateway(this, this.__resources, input);
  }

  public updateVirtualNode(input: shapes.AppMeshUpdateVirtualNodeInput): AppMeshResponsesUpdateVirtualNode {
    return new AppMeshResponsesUpdateVirtualNode(this, this.__resources, input);
  }

  public updateVirtualRouter(input: shapes.AppMeshUpdateVirtualRouterInput): AppMeshResponsesUpdateVirtualRouter {
    return new AppMeshResponsesUpdateVirtualRouter(this, this.__resources, input);
  }

  public updateVirtualService(input: shapes.AppMeshUpdateVirtualServiceInput): AppMeshResponsesUpdateVirtualService {
    return new AppMeshResponsesUpdateVirtualService(this, this.__resources, input);
  }

}

export class AppMeshResponsesCreateGatewayRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateGatewayRouteInput) {
  }

  public get gatewayRoute(): AppMeshResponsesCreateGatewayRouteGatewayRoute {
    return new AppMeshResponsesCreateGatewayRouteGatewayRoute(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateGatewayRouteGatewayRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateGatewayRouteInput) {
  }

  public get gatewayRouteName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.gatewayRouteName'),
        outputPath: 'gatewayRoute.gatewayRouteName',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateGatewayRoute.gatewayRoute.gatewayRouteName', props);
    return resource.getResponseField('gatewayRoute.gatewayRouteName') as unknown as string;
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.meshName'),
        outputPath: 'gatewayRoute.meshName',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateGatewayRoute.gatewayRoute.meshName', props);
    return resource.getResponseField('gatewayRoute.meshName') as unknown as string;
  }

  public get metadata(): AppMeshResponsesCreateGatewayRouteGatewayRouteMetadata {
    return new AppMeshResponsesCreateGatewayRouteGatewayRouteMetadata(this.__scope, this.__resources, this.__input);
  }

  public get spec(): AppMeshResponsesCreateGatewayRouteGatewayRouteSpec {
    return new AppMeshResponsesCreateGatewayRouteGatewayRouteSpec(this.__scope, this.__resources, this.__input);
  }

  public get status(): AppMeshResponsesCreateGatewayRouteGatewayRouteStatus {
    return new AppMeshResponsesCreateGatewayRouteGatewayRouteStatus(this.__scope, this.__resources, this.__input);
  }

  public get virtualGatewayName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.virtualGatewayName'),
        outputPath: 'gatewayRoute.virtualGatewayName',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateGatewayRoute.gatewayRoute.virtualGatewayName', props);
    return resource.getResponseField('gatewayRoute.virtualGatewayName') as unknown as string;
  }

}

export class AppMeshResponsesCreateGatewayRouteGatewayRouteMetadata {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateGatewayRouteInput) {
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.metadata.arn'),
        outputPath: 'gatewayRoute.metadata.arn',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateGatewayRoute.gatewayRoute.metadata.arn', props);
    return resource.getResponseField('gatewayRoute.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.metadata.createdAt'),
        outputPath: 'gatewayRoute.metadata.createdAt',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateGatewayRoute.gatewayRoute.metadata.createdAt', props);
    return resource.getResponseField('gatewayRoute.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.metadata.lastUpdatedAt'),
        outputPath: 'gatewayRoute.metadata.lastUpdatedAt',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateGatewayRoute.gatewayRoute.metadata.lastUpdatedAt', props);
    return resource.getResponseField('gatewayRoute.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.metadata.meshOwner'),
        outputPath: 'gatewayRoute.metadata.meshOwner',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateGatewayRoute.gatewayRoute.metadata.meshOwner', props);
    return resource.getResponseField('gatewayRoute.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.metadata.resourceOwner'),
        outputPath: 'gatewayRoute.metadata.resourceOwner',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateGatewayRoute.gatewayRoute.metadata.resourceOwner', props);
    return resource.getResponseField('gatewayRoute.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.metadata.uid'),
        outputPath: 'gatewayRoute.metadata.uid',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateGatewayRoute.gatewayRoute.metadata.uid', props);
    return resource.getResponseField('gatewayRoute.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.metadata.version'),
        outputPath: 'gatewayRoute.metadata.version',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateGatewayRoute.gatewayRoute.metadata.version', props);
    return resource.getResponseField('gatewayRoute.metadata.version') as unknown as number;
  }

}

export class AppMeshResponsesCreateGatewayRouteGatewayRouteSpec {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateGatewayRouteInput) {
  }

  public get grpcRoute(): AppMeshResponsesCreateGatewayRouteGatewayRouteSpecGrpcRoute {
    return new AppMeshResponsesCreateGatewayRouteGatewayRouteSpecGrpcRoute(this.__scope, this.__resources, this.__input);
  }

  public get http2Route(): AppMeshResponsesCreateGatewayRouteGatewayRouteSpecHttp2Route {
    return new AppMeshResponsesCreateGatewayRouteGatewayRouteSpecHttp2Route(this.__scope, this.__resources, this.__input);
  }

  public get httpRoute(): AppMeshResponsesCreateGatewayRouteGatewayRouteSpecHttpRoute {
    return new AppMeshResponsesCreateGatewayRouteGatewayRouteSpecHttpRoute(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateGatewayRouteGatewayRouteSpecGrpcRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateGatewayRouteInput) {
  }

  public get action(): AppMeshResponsesCreateGatewayRouteGatewayRouteSpecGrpcRouteAction {
    return new AppMeshResponsesCreateGatewayRouteGatewayRouteSpecGrpcRouteAction(this.__scope, this.__resources, this.__input);
  }

  public get match(): AppMeshResponsesCreateGatewayRouteGatewayRouteSpecGrpcRouteMatch {
    return new AppMeshResponsesCreateGatewayRouteGatewayRouteSpecGrpcRouteMatch(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateGatewayRouteGatewayRouteSpecGrpcRouteAction {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateGatewayRouteInput) {
  }

  public get target(): AppMeshResponsesCreateGatewayRouteGatewayRouteSpecGrpcRouteActionTarget {
    return new AppMeshResponsesCreateGatewayRouteGatewayRouteSpecGrpcRouteActionTarget(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateGatewayRouteGatewayRouteSpecGrpcRouteActionTarget {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateGatewayRouteInput) {
  }

  public get virtualService(): AppMeshResponsesCreateGatewayRouteGatewayRouteSpecGrpcRouteActionTargetVirtualService {
    return new AppMeshResponsesCreateGatewayRouteGatewayRouteSpecGrpcRouteActionTargetVirtualService(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateGatewayRouteGatewayRouteSpecGrpcRouteActionTargetVirtualService {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateGatewayRouteInput) {
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName'),
        outputPath: 'gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateGatewayRoute.gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName', props);
    return resource.getResponseField('gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshResponsesCreateGatewayRouteGatewayRouteSpecGrpcRouteMatch {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateGatewayRouteInput) {
  }

  public get serviceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.spec.grpcRoute.match.serviceName'),
        outputPath: 'gatewayRoute.spec.grpcRoute.match.serviceName',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateGatewayRoute.gatewayRoute.spec.grpcRoute.match.serviceName', props);
    return resource.getResponseField('gatewayRoute.spec.grpcRoute.match.serviceName') as unknown as string;
  }

}

export class AppMeshResponsesCreateGatewayRouteGatewayRouteSpecHttp2Route {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateGatewayRouteInput) {
  }

  public get action(): AppMeshResponsesCreateGatewayRouteGatewayRouteSpecHttp2RouteAction {
    return new AppMeshResponsesCreateGatewayRouteGatewayRouteSpecHttp2RouteAction(this.__scope, this.__resources, this.__input);
  }

  public get match(): AppMeshResponsesCreateGatewayRouteGatewayRouteSpecHttp2RouteMatch {
    return new AppMeshResponsesCreateGatewayRouteGatewayRouteSpecHttp2RouteMatch(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateGatewayRouteGatewayRouteSpecHttp2RouteAction {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateGatewayRouteInput) {
  }

  public get target(): AppMeshResponsesCreateGatewayRouteGatewayRouteSpecHttp2RouteActionTarget {
    return new AppMeshResponsesCreateGatewayRouteGatewayRouteSpecHttp2RouteActionTarget(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateGatewayRouteGatewayRouteSpecHttp2RouteActionTarget {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateGatewayRouteInput) {
  }

  public get virtualService(): AppMeshResponsesCreateGatewayRouteGatewayRouteSpecHttp2RouteActionTargetVirtualService {
    return new AppMeshResponsesCreateGatewayRouteGatewayRouteSpecHttp2RouteActionTargetVirtualService(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateGatewayRouteGatewayRouteSpecHttp2RouteActionTargetVirtualService {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateGatewayRouteInput) {
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName'),
        outputPath: 'gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateGatewayRoute.gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName', props);
    return resource.getResponseField('gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshResponsesCreateGatewayRouteGatewayRouteSpecHttp2RouteMatch {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateGatewayRouteInput) {
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.spec.http2Route.match.prefix'),
        outputPath: 'gatewayRoute.spec.http2Route.match.prefix',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateGatewayRoute.gatewayRoute.spec.http2Route.match.prefix', props);
    return resource.getResponseField('gatewayRoute.spec.http2Route.match.prefix') as unknown as string;
  }

}

export class AppMeshResponsesCreateGatewayRouteGatewayRouteSpecHttpRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateGatewayRouteInput) {
  }

  public get action(): AppMeshResponsesCreateGatewayRouteGatewayRouteSpecHttpRouteAction {
    return new AppMeshResponsesCreateGatewayRouteGatewayRouteSpecHttpRouteAction(this.__scope, this.__resources, this.__input);
  }

  public get match(): AppMeshResponsesCreateGatewayRouteGatewayRouteSpecHttpRouteMatch {
    return new AppMeshResponsesCreateGatewayRouteGatewayRouteSpecHttpRouteMatch(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateGatewayRouteGatewayRouteSpecHttpRouteAction {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateGatewayRouteInput) {
  }

  public get target(): AppMeshResponsesCreateGatewayRouteGatewayRouteSpecHttpRouteActionTarget {
    return new AppMeshResponsesCreateGatewayRouteGatewayRouteSpecHttpRouteActionTarget(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateGatewayRouteGatewayRouteSpecHttpRouteActionTarget {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateGatewayRouteInput) {
  }

  public get virtualService(): AppMeshResponsesCreateGatewayRouteGatewayRouteSpecHttpRouteActionTargetVirtualService {
    return new AppMeshResponsesCreateGatewayRouteGatewayRouteSpecHttpRouteActionTargetVirtualService(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateGatewayRouteGatewayRouteSpecHttpRouteActionTargetVirtualService {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateGatewayRouteInput) {
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName'),
        outputPath: 'gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateGatewayRoute.gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName', props);
    return resource.getResponseField('gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshResponsesCreateGatewayRouteGatewayRouteSpecHttpRouteMatch {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateGatewayRouteInput) {
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.spec.httpRoute.match.prefix'),
        outputPath: 'gatewayRoute.spec.httpRoute.match.prefix',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateGatewayRoute.gatewayRoute.spec.httpRoute.match.prefix', props);
    return resource.getResponseField('gatewayRoute.spec.httpRoute.match.prefix') as unknown as string;
  }

}

export class AppMeshResponsesCreateGatewayRouteGatewayRouteStatus {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateGatewayRouteInput) {
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateGatewayRoute.gatewayRoute.status.status'),
        outputPath: 'gatewayRoute.status.status',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateGatewayRoute.gatewayRoute.status.status', props);
    return resource.getResponseField('gatewayRoute.status.status') as unknown as string;
  }

}

export class AppMeshResponsesCreateMesh {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateMeshInput) {
  }

  public get mesh(): AppMeshResponsesCreateMeshMesh {
    return new AppMeshResponsesCreateMeshMesh(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateMeshMesh {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateMeshInput) {
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateMesh.mesh.meshName'),
        outputPath: 'mesh.meshName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          spec: {
            egressFilter: {
              type: this.__input.spec?.egressFilter?.type,
            },
          },
          tags: this.__input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateMesh.mesh.meshName', props);
    return resource.getResponseField('mesh.meshName') as unknown as string;
  }

  public get metadata(): AppMeshResponsesCreateMeshMeshMetadata {
    return new AppMeshResponsesCreateMeshMeshMetadata(this.__scope, this.__resources, this.__input);
  }

  public get spec(): AppMeshResponsesCreateMeshMeshSpec {
    return new AppMeshResponsesCreateMeshMeshSpec(this.__scope, this.__resources, this.__input);
  }

  public get status(): AppMeshResponsesCreateMeshMeshStatus {
    return new AppMeshResponsesCreateMeshMeshStatus(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateMeshMeshMetadata {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateMeshInput) {
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateMesh.mesh.metadata.arn'),
        outputPath: 'mesh.metadata.arn',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          spec: {
            egressFilter: {
              type: this.__input.spec?.egressFilter?.type,
            },
          },
          tags: this.__input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateMesh.mesh.metadata.arn', props);
    return resource.getResponseField('mesh.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateMesh.mesh.metadata.createdAt'),
        outputPath: 'mesh.metadata.createdAt',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          spec: {
            egressFilter: {
              type: this.__input.spec?.egressFilter?.type,
            },
          },
          tags: this.__input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateMesh.mesh.metadata.createdAt', props);
    return resource.getResponseField('mesh.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateMesh.mesh.metadata.lastUpdatedAt'),
        outputPath: 'mesh.metadata.lastUpdatedAt',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          spec: {
            egressFilter: {
              type: this.__input.spec?.egressFilter?.type,
            },
          },
          tags: this.__input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateMesh.mesh.metadata.lastUpdatedAt', props);
    return resource.getResponseField('mesh.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateMesh.mesh.metadata.meshOwner'),
        outputPath: 'mesh.metadata.meshOwner',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          spec: {
            egressFilter: {
              type: this.__input.spec?.egressFilter?.type,
            },
          },
          tags: this.__input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateMesh.mesh.metadata.meshOwner', props);
    return resource.getResponseField('mesh.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateMesh.mesh.metadata.resourceOwner'),
        outputPath: 'mesh.metadata.resourceOwner',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          spec: {
            egressFilter: {
              type: this.__input.spec?.egressFilter?.type,
            },
          },
          tags: this.__input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateMesh.mesh.metadata.resourceOwner', props);
    return resource.getResponseField('mesh.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateMesh.mesh.metadata.uid'),
        outputPath: 'mesh.metadata.uid',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          spec: {
            egressFilter: {
              type: this.__input.spec?.egressFilter?.type,
            },
          },
          tags: this.__input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateMesh.mesh.metadata.uid', props);
    return resource.getResponseField('mesh.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateMesh.mesh.metadata.version'),
        outputPath: 'mesh.metadata.version',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          spec: {
            egressFilter: {
              type: this.__input.spec?.egressFilter?.type,
            },
          },
          tags: this.__input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateMesh.mesh.metadata.version', props);
    return resource.getResponseField('mesh.metadata.version') as unknown as number;
  }

}

export class AppMeshResponsesCreateMeshMeshSpec {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateMeshInput) {
  }

  public get egressFilter(): AppMeshResponsesCreateMeshMeshSpecEgressFilter {
    return new AppMeshResponsesCreateMeshMeshSpecEgressFilter(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateMeshMeshSpecEgressFilter {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateMeshInput) {
  }

  public get type(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateMesh.mesh.spec.egressFilter.type'),
        outputPath: 'mesh.spec.egressFilter.type',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          spec: {
            egressFilter: {
              type: this.__input.spec?.egressFilter?.type,
            },
          },
          tags: this.__input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateMesh.mesh.spec.egressFilter.type', props);
    return resource.getResponseField('mesh.spec.egressFilter.type') as unknown as string;
  }

}

export class AppMeshResponsesCreateMeshMeshStatus {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateMeshInput) {
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateMesh.mesh.status.status'),
        outputPath: 'mesh.status.status',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          spec: {
            egressFilter: {
              type: this.__input.spec?.egressFilter?.type,
            },
          },
          tags: this.__input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateMesh.mesh.status.status', props);
    return resource.getResponseField('mesh.status.status') as unknown as string;
  }

}

export class AppMeshResponsesCreateRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get route(): AppMeshResponsesCreateRouteRoute {
    return new AppMeshResponsesCreateRouteRoute(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateRouteRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.meshName'),
        outputPath: 'route.meshName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.meshName', props);
    return resource.getResponseField('route.meshName') as unknown as string;
  }

  public get metadata(): AppMeshResponsesCreateRouteRouteMetadata {
    return new AppMeshResponsesCreateRouteRouteMetadata(this.__scope, this.__resources, this.__input);
  }

  public get routeName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.routeName'),
        outputPath: 'route.routeName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.routeName', props);
    return resource.getResponseField('route.routeName') as unknown as string;
  }

  public get spec(): AppMeshResponsesCreateRouteRouteSpec {
    return new AppMeshResponsesCreateRouteRouteSpec(this.__scope, this.__resources, this.__input);
  }

  public get status(): AppMeshResponsesCreateRouteRouteStatus {
    return new AppMeshResponsesCreateRouteRouteStatus(this.__scope, this.__resources, this.__input);
  }

  public get virtualRouterName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.virtualRouterName'),
        outputPath: 'route.virtualRouterName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.virtualRouterName', props);
    return resource.getResponseField('route.virtualRouterName') as unknown as string;
  }

}

export class AppMeshResponsesCreateRouteRouteMetadata {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.metadata.arn'),
        outputPath: 'route.metadata.arn',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.metadata.arn', props);
    return resource.getResponseField('route.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.metadata.createdAt'),
        outputPath: 'route.metadata.createdAt',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.metadata.createdAt', props);
    return resource.getResponseField('route.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.metadata.lastUpdatedAt'),
        outputPath: 'route.metadata.lastUpdatedAt',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.metadata.lastUpdatedAt', props);
    return resource.getResponseField('route.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.metadata.meshOwner'),
        outputPath: 'route.metadata.meshOwner',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.metadata.meshOwner', props);
    return resource.getResponseField('route.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.metadata.resourceOwner'),
        outputPath: 'route.metadata.resourceOwner',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.metadata.resourceOwner', props);
    return resource.getResponseField('route.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.metadata.uid'),
        outputPath: 'route.metadata.uid',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.metadata.uid', props);
    return resource.getResponseField('route.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.metadata.version'),
        outputPath: 'route.metadata.version',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.metadata.version', props);
    return resource.getResponseField('route.metadata.version') as unknown as number;
  }

}

export class AppMeshResponsesCreateRouteRouteSpec {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get grpcRoute(): AppMeshResponsesCreateRouteRouteSpecGrpcRoute {
    return new AppMeshResponsesCreateRouteRouteSpecGrpcRoute(this.__scope, this.__resources, this.__input);
  }

  public get http2Route(): AppMeshResponsesCreateRouteRouteSpecHttp2Route {
    return new AppMeshResponsesCreateRouteRouteSpecHttp2Route(this.__scope, this.__resources, this.__input);
  }

  public get httpRoute(): AppMeshResponsesCreateRouteRouteSpecHttpRoute {
    return new AppMeshResponsesCreateRouteRouteSpecHttpRoute(this.__scope, this.__resources, this.__input);
  }

  public get priority(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.priority'),
        outputPath: 'route.spec.priority',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.priority', props);
    return resource.getResponseField('route.spec.priority') as unknown as number;
  }

  public get tcpRoute(): AppMeshResponsesCreateRouteRouteSpecTcpRoute {
    return new AppMeshResponsesCreateRouteRouteSpecTcpRoute(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateRouteRouteSpecGrpcRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get action(): AppMeshResponsesCreateRouteRouteSpecGrpcRouteAction {
    return new AppMeshResponsesCreateRouteRouteSpecGrpcRouteAction(this.__scope, this.__resources, this.__input);
  }

  public get match(): AppMeshResponsesCreateRouteRouteSpecGrpcRouteMatch {
    return new AppMeshResponsesCreateRouteRouteSpecGrpcRouteMatch(this.__scope, this.__resources, this.__input);
  }

  public get retryPolicy(): AppMeshResponsesCreateRouteRouteSpecGrpcRouteRetryPolicy {
    return new AppMeshResponsesCreateRouteRouteSpecGrpcRouteRetryPolicy(this.__scope, this.__resources, this.__input);
  }

  public get timeout(): AppMeshResponsesCreateRouteRouteSpecGrpcRouteTimeout {
    return new AppMeshResponsesCreateRouteRouteSpecGrpcRouteTimeout(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateRouteRouteSpecGrpcRouteAction {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.grpcRoute.action.weightedTargets'),
        outputPath: 'route.spec.grpcRoute.action.weightedTargets',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.grpcRoute.action.weightedTargets', props);
    return resource.getResponseField('route.spec.grpcRoute.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshResponsesCreateRouteRouteSpecGrpcRouteMatch {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get metadata(): shapes.AppMeshGrpcRouteMetadata[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.grpcRoute.match.metadata'),
        outputPath: 'route.spec.grpcRoute.match.metadata',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.grpcRoute.match.metadata', props);
    return resource.getResponseField('route.spec.grpcRoute.match.metadata') as unknown as shapes.AppMeshGrpcRouteMetadata[];
  }

  public get methodName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.grpcRoute.match.methodName'),
        outputPath: 'route.spec.grpcRoute.match.methodName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.grpcRoute.match.methodName', props);
    return resource.getResponseField('route.spec.grpcRoute.match.methodName') as unknown as string;
  }

  public get serviceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.grpcRoute.match.serviceName'),
        outputPath: 'route.spec.grpcRoute.match.serviceName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.grpcRoute.match.serviceName', props);
    return resource.getResponseField('route.spec.grpcRoute.match.serviceName') as unknown as string;
  }

}

export class AppMeshResponsesCreateRouteRouteSpecGrpcRouteRetryPolicy {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get grpcRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.grpcRoute.retryPolicy.grpcRetryEvents'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.grpcRetryEvents',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.grpcRoute.retryPolicy.grpcRetryEvents', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.grpcRetryEvents') as unknown as string[];
  }

  public get httpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.grpcRoute.retryPolicy.httpRetryEvents'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.httpRetryEvents',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.grpcRoute.retryPolicy.httpRetryEvents', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.httpRetryEvents') as unknown as string[];
  }

  public get maxRetries(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.grpcRoute.retryPolicy.maxRetries'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.maxRetries',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.grpcRoute.retryPolicy.maxRetries', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.maxRetries') as unknown as number;
  }

  public get perRetryTimeout(): AppMeshResponsesCreateRouteRouteSpecGrpcRouteRetryPolicyPerRetryTimeout {
    return new AppMeshResponsesCreateRouteRouteSpecGrpcRouteRetryPolicyPerRetryTimeout(this.__scope, this.__resources, this.__input);
  }

  public get tcpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.grpcRoute.retryPolicy.tcpRetryEvents'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.tcpRetryEvents',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.grpcRoute.retryPolicy.tcpRetryEvents', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.tcpRetryEvents') as unknown as string[];
  }

}

export class AppMeshResponsesCreateRouteRouteSpecGrpcRouteRetryPolicyPerRetryTimeout {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.value'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.perRetryTimeout.value',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.value', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.perRetryTimeout.value') as unknown as number;
  }

}

export class AppMeshResponsesCreateRouteRouteSpecGrpcRouteTimeout {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get idle(): AppMeshResponsesCreateRouteRouteSpecGrpcRouteTimeoutIdle {
    return new AppMeshResponsesCreateRouteRouteSpecGrpcRouteTimeoutIdle(this.__scope, this.__resources, this.__input);
  }

  public get perRequest(): AppMeshResponsesCreateRouteRouteSpecGrpcRouteTimeoutPerRequest {
    return new AppMeshResponsesCreateRouteRouteSpecGrpcRouteTimeoutPerRequest(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateRouteRouteSpecGrpcRouteTimeoutIdle {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.grpcRoute.timeout.idle.unit'),
        outputPath: 'route.spec.grpcRoute.timeout.idle.unit',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.grpcRoute.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.grpcRoute.timeout.idle.value'),
        outputPath: 'route.spec.grpcRoute.timeout.idle.value',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.grpcRoute.timeout.idle.value', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshResponsesCreateRouteRouteSpecGrpcRouteTimeoutPerRequest {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.grpcRoute.timeout.perRequest.unit'),
        outputPath: 'route.spec.grpcRoute.timeout.perRequest.unit',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.grpcRoute.timeout.perRequest.unit', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.perRequest.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.grpcRoute.timeout.perRequest.value'),
        outputPath: 'route.spec.grpcRoute.timeout.perRequest.value',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.grpcRoute.timeout.perRequest.value', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.perRequest.value') as unknown as number;
  }

}

export class AppMeshResponsesCreateRouteRouteSpecHttp2Route {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get action(): AppMeshResponsesCreateRouteRouteSpecHttp2RouteAction {
    return new AppMeshResponsesCreateRouteRouteSpecHttp2RouteAction(this.__scope, this.__resources, this.__input);
  }

  public get match(): AppMeshResponsesCreateRouteRouteSpecHttp2RouteMatch {
    return new AppMeshResponsesCreateRouteRouteSpecHttp2RouteMatch(this.__scope, this.__resources, this.__input);
  }

  public get retryPolicy(): AppMeshResponsesCreateRouteRouteSpecHttp2RouteRetryPolicy {
    return new AppMeshResponsesCreateRouteRouteSpecHttp2RouteRetryPolicy(this.__scope, this.__resources, this.__input);
  }

  public get timeout(): AppMeshResponsesCreateRouteRouteSpecHttp2RouteTimeout {
    return new AppMeshResponsesCreateRouteRouteSpecHttp2RouteTimeout(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateRouteRouteSpecHttp2RouteAction {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.http2Route.action.weightedTargets'),
        outputPath: 'route.spec.http2Route.action.weightedTargets',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.http2Route.action.weightedTargets', props);
    return resource.getResponseField('route.spec.http2Route.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshResponsesCreateRouteRouteSpecHttp2RouteMatch {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get headers(): shapes.AppMeshHttpRouteHeader[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.http2Route.match.headers'),
        outputPath: 'route.spec.http2Route.match.headers',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.http2Route.match.headers', props);
    return resource.getResponseField('route.spec.http2Route.match.headers') as unknown as shapes.AppMeshHttpRouteHeader[];
  }

  public get method(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.http2Route.match.method'),
        outputPath: 'route.spec.http2Route.match.method',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.http2Route.match.method', props);
    return resource.getResponseField('route.spec.http2Route.match.method') as unknown as string;
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.http2Route.match.prefix'),
        outputPath: 'route.spec.http2Route.match.prefix',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.http2Route.match.prefix', props);
    return resource.getResponseField('route.spec.http2Route.match.prefix') as unknown as string;
  }

  public get scheme(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.http2Route.match.scheme'),
        outputPath: 'route.spec.http2Route.match.scheme',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.http2Route.match.scheme', props);
    return resource.getResponseField('route.spec.http2Route.match.scheme') as unknown as string;
  }

}

export class AppMeshResponsesCreateRouteRouteSpecHttp2RouteRetryPolicy {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get httpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.http2Route.retryPolicy.httpRetryEvents'),
        outputPath: 'route.spec.http2Route.retryPolicy.httpRetryEvents',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.http2Route.retryPolicy.httpRetryEvents', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.httpRetryEvents') as unknown as string[];
  }

  public get maxRetries(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.http2Route.retryPolicy.maxRetries'),
        outputPath: 'route.spec.http2Route.retryPolicy.maxRetries',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.http2Route.retryPolicy.maxRetries', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.maxRetries') as unknown as number;
  }

  public get perRetryTimeout(): AppMeshResponsesCreateRouteRouteSpecHttp2RouteRetryPolicyPerRetryTimeout {
    return new AppMeshResponsesCreateRouteRouteSpecHttp2RouteRetryPolicyPerRetryTimeout(this.__scope, this.__resources, this.__input);
  }

  public get tcpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.http2Route.retryPolicy.tcpRetryEvents'),
        outputPath: 'route.spec.http2Route.retryPolicy.tcpRetryEvents',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.http2Route.retryPolicy.tcpRetryEvents', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.tcpRetryEvents') as unknown as string[];
  }

}

export class AppMeshResponsesCreateRouteRouteSpecHttp2RouteRetryPolicyPerRetryTimeout {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.unit'),
        outputPath: 'route.spec.http2Route.retryPolicy.perRetryTimeout.unit',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.unit', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.perRetryTimeout.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.value'),
        outputPath: 'route.spec.http2Route.retryPolicy.perRetryTimeout.value',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.value', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.perRetryTimeout.value') as unknown as number;
  }

}

export class AppMeshResponsesCreateRouteRouteSpecHttp2RouteTimeout {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get idle(): AppMeshResponsesCreateRouteRouteSpecHttp2RouteTimeoutIdle {
    return new AppMeshResponsesCreateRouteRouteSpecHttp2RouteTimeoutIdle(this.__scope, this.__resources, this.__input);
  }

  public get perRequest(): AppMeshResponsesCreateRouteRouteSpecHttp2RouteTimeoutPerRequest {
    return new AppMeshResponsesCreateRouteRouteSpecHttp2RouteTimeoutPerRequest(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateRouteRouteSpecHttp2RouteTimeoutIdle {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.http2Route.timeout.idle.unit'),
        outputPath: 'route.spec.http2Route.timeout.idle.unit',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.http2Route.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.http2Route.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.http2Route.timeout.idle.value'),
        outputPath: 'route.spec.http2Route.timeout.idle.value',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.http2Route.timeout.idle.value', props);
    return resource.getResponseField('route.spec.http2Route.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshResponsesCreateRouteRouteSpecHttp2RouteTimeoutPerRequest {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.http2Route.timeout.perRequest.unit'),
        outputPath: 'route.spec.http2Route.timeout.perRequest.unit',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.http2Route.timeout.perRequest.unit', props);
    return resource.getResponseField('route.spec.http2Route.timeout.perRequest.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.http2Route.timeout.perRequest.value'),
        outputPath: 'route.spec.http2Route.timeout.perRequest.value',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.http2Route.timeout.perRequest.value', props);
    return resource.getResponseField('route.spec.http2Route.timeout.perRequest.value') as unknown as number;
  }

}

export class AppMeshResponsesCreateRouteRouteSpecHttpRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get action(): AppMeshResponsesCreateRouteRouteSpecHttpRouteAction {
    return new AppMeshResponsesCreateRouteRouteSpecHttpRouteAction(this.__scope, this.__resources, this.__input);
  }

  public get match(): AppMeshResponsesCreateRouteRouteSpecHttpRouteMatch {
    return new AppMeshResponsesCreateRouteRouteSpecHttpRouteMatch(this.__scope, this.__resources, this.__input);
  }

  public get retryPolicy(): AppMeshResponsesCreateRouteRouteSpecHttpRouteRetryPolicy {
    return new AppMeshResponsesCreateRouteRouteSpecHttpRouteRetryPolicy(this.__scope, this.__resources, this.__input);
  }

  public get timeout(): AppMeshResponsesCreateRouteRouteSpecHttpRouteTimeout {
    return new AppMeshResponsesCreateRouteRouteSpecHttpRouteTimeout(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateRouteRouteSpecHttpRouteAction {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.httpRoute.action.weightedTargets'),
        outputPath: 'route.spec.httpRoute.action.weightedTargets',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.httpRoute.action.weightedTargets', props);
    return resource.getResponseField('route.spec.httpRoute.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshResponsesCreateRouteRouteSpecHttpRouteMatch {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get headers(): shapes.AppMeshHttpRouteHeader[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.httpRoute.match.headers'),
        outputPath: 'route.spec.httpRoute.match.headers',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.httpRoute.match.headers', props);
    return resource.getResponseField('route.spec.httpRoute.match.headers') as unknown as shapes.AppMeshHttpRouteHeader[];
  }

  public get method(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.httpRoute.match.method'),
        outputPath: 'route.spec.httpRoute.match.method',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.httpRoute.match.method', props);
    return resource.getResponseField('route.spec.httpRoute.match.method') as unknown as string;
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.httpRoute.match.prefix'),
        outputPath: 'route.spec.httpRoute.match.prefix',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.httpRoute.match.prefix', props);
    return resource.getResponseField('route.spec.httpRoute.match.prefix') as unknown as string;
  }

  public get scheme(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.httpRoute.match.scheme'),
        outputPath: 'route.spec.httpRoute.match.scheme',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.httpRoute.match.scheme', props);
    return resource.getResponseField('route.spec.httpRoute.match.scheme') as unknown as string;
  }

}

export class AppMeshResponsesCreateRouteRouteSpecHttpRouteRetryPolicy {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get httpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.httpRoute.retryPolicy.httpRetryEvents'),
        outputPath: 'route.spec.httpRoute.retryPolicy.httpRetryEvents',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.httpRoute.retryPolicy.httpRetryEvents', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.httpRetryEvents') as unknown as string[];
  }

  public get maxRetries(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.httpRoute.retryPolicy.maxRetries'),
        outputPath: 'route.spec.httpRoute.retryPolicy.maxRetries',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.httpRoute.retryPolicy.maxRetries', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.maxRetries') as unknown as number;
  }

  public get perRetryTimeout(): AppMeshResponsesCreateRouteRouteSpecHttpRouteRetryPolicyPerRetryTimeout {
    return new AppMeshResponsesCreateRouteRouteSpecHttpRouteRetryPolicyPerRetryTimeout(this.__scope, this.__resources, this.__input);
  }

  public get tcpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.httpRoute.retryPolicy.tcpRetryEvents'),
        outputPath: 'route.spec.httpRoute.retryPolicy.tcpRetryEvents',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.httpRoute.retryPolicy.tcpRetryEvents', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.tcpRetryEvents') as unknown as string[];
  }

}

export class AppMeshResponsesCreateRouteRouteSpecHttpRouteRetryPolicyPerRetryTimeout {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.unit'),
        outputPath: 'route.spec.httpRoute.retryPolicy.perRetryTimeout.unit',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.unit', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.perRetryTimeout.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.value'),
        outputPath: 'route.spec.httpRoute.retryPolicy.perRetryTimeout.value',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.value', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.perRetryTimeout.value') as unknown as number;
  }

}

export class AppMeshResponsesCreateRouteRouteSpecHttpRouteTimeout {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get idle(): AppMeshResponsesCreateRouteRouteSpecHttpRouteTimeoutIdle {
    return new AppMeshResponsesCreateRouteRouteSpecHttpRouteTimeoutIdle(this.__scope, this.__resources, this.__input);
  }

  public get perRequest(): AppMeshResponsesCreateRouteRouteSpecHttpRouteTimeoutPerRequest {
    return new AppMeshResponsesCreateRouteRouteSpecHttpRouteTimeoutPerRequest(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateRouteRouteSpecHttpRouteTimeoutIdle {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.httpRoute.timeout.idle.unit'),
        outputPath: 'route.spec.httpRoute.timeout.idle.unit',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.httpRoute.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.httpRoute.timeout.idle.value'),
        outputPath: 'route.spec.httpRoute.timeout.idle.value',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.httpRoute.timeout.idle.value', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshResponsesCreateRouteRouteSpecHttpRouteTimeoutPerRequest {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.httpRoute.timeout.perRequest.unit'),
        outputPath: 'route.spec.httpRoute.timeout.perRequest.unit',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.httpRoute.timeout.perRequest.unit', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.perRequest.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.httpRoute.timeout.perRequest.value'),
        outputPath: 'route.spec.httpRoute.timeout.perRequest.value',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.httpRoute.timeout.perRequest.value', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.perRequest.value') as unknown as number;
  }

}

export class AppMeshResponsesCreateRouteRouteSpecTcpRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get action(): AppMeshResponsesCreateRouteRouteSpecTcpRouteAction {
    return new AppMeshResponsesCreateRouteRouteSpecTcpRouteAction(this.__scope, this.__resources, this.__input);
  }

  public get timeout(): AppMeshResponsesCreateRouteRouteSpecTcpRouteTimeout {
    return new AppMeshResponsesCreateRouteRouteSpecTcpRouteTimeout(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateRouteRouteSpecTcpRouteAction {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.tcpRoute.action.weightedTargets'),
        outputPath: 'route.spec.tcpRoute.action.weightedTargets',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.tcpRoute.action.weightedTargets', props);
    return resource.getResponseField('route.spec.tcpRoute.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshResponsesCreateRouteRouteSpecTcpRouteTimeout {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get idle(): AppMeshResponsesCreateRouteRouteSpecTcpRouteTimeoutIdle {
    return new AppMeshResponsesCreateRouteRouteSpecTcpRouteTimeoutIdle(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateRouteRouteSpecTcpRouteTimeoutIdle {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.tcpRoute.timeout.idle.unit'),
        outputPath: 'route.spec.tcpRoute.timeout.idle.unit',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.tcpRoute.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.tcpRoute.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.spec.tcpRoute.timeout.idle.value'),
        outputPath: 'route.spec.tcpRoute.timeout.idle.value',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.spec.tcpRoute.timeout.idle.value', props);
    return resource.getResponseField('route.spec.tcpRoute.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshResponsesCreateRouteRouteStatus {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateRouteInput) {
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateRoute.route.status.status'),
        outputPath: 'route.status.status',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateRoute.route.status.status', props);
    return resource.getResponseField('route.status.status') as unknown as string;
  }

}

export class AppMeshResponsesCreateVirtualGateway {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualGatewayInput) {
  }

  public get virtualGateway(): AppMeshResponsesCreateVirtualGatewayVirtualGateway {
    return new AppMeshResponsesCreateVirtualGatewayVirtualGateway(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateVirtualGatewayVirtualGateway {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualGatewayInput) {
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.meshName'),
        outputPath: 'virtualGateway.meshName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualGateway.virtualGateway.meshName', props);
    return resource.getResponseField('virtualGateway.meshName') as unknown as string;
  }

  public get metadata(): AppMeshResponsesCreateVirtualGatewayVirtualGatewayMetadata {
    return new AppMeshResponsesCreateVirtualGatewayVirtualGatewayMetadata(this.__scope, this.__resources, this.__input);
  }

  public get spec(): AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpec {
    return new AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpec(this.__scope, this.__resources, this.__input);
  }

  public get status(): AppMeshResponsesCreateVirtualGatewayVirtualGatewayStatus {
    return new AppMeshResponsesCreateVirtualGatewayVirtualGatewayStatus(this.__scope, this.__resources, this.__input);
  }

  public get virtualGatewayName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.virtualGatewayName'),
        outputPath: 'virtualGateway.virtualGatewayName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualGateway.virtualGateway.virtualGatewayName', props);
    return resource.getResponseField('virtualGateway.virtualGatewayName') as unknown as string;
  }

}

export class AppMeshResponsesCreateVirtualGatewayVirtualGatewayMetadata {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualGatewayInput) {
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.metadata.arn'),
        outputPath: 'virtualGateway.metadata.arn',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualGateway.virtualGateway.metadata.arn', props);
    return resource.getResponseField('virtualGateway.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.metadata.createdAt'),
        outputPath: 'virtualGateway.metadata.createdAt',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualGateway.virtualGateway.metadata.createdAt', props);
    return resource.getResponseField('virtualGateway.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.metadata.lastUpdatedAt'),
        outputPath: 'virtualGateway.metadata.lastUpdatedAt',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualGateway.virtualGateway.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualGateway.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.metadata.meshOwner'),
        outputPath: 'virtualGateway.metadata.meshOwner',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualGateway.virtualGateway.metadata.meshOwner', props);
    return resource.getResponseField('virtualGateway.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.metadata.resourceOwner'),
        outputPath: 'virtualGateway.metadata.resourceOwner',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualGateway.virtualGateway.metadata.resourceOwner', props);
    return resource.getResponseField('virtualGateway.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.metadata.uid'),
        outputPath: 'virtualGateway.metadata.uid',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualGateway.virtualGateway.metadata.uid', props);
    return resource.getResponseField('virtualGateway.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.metadata.version'),
        outputPath: 'virtualGateway.metadata.version',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualGateway.virtualGateway.metadata.version', props);
    return resource.getResponseField('virtualGateway.metadata.version') as unknown as number;
  }

}

export class AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpec {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualGatewayInput) {
  }

  public get backendDefaults(): AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpecBackendDefaults {
    return new AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpecBackendDefaults(this.__scope, this.__resources, this.__input);
  }

  public get listeners(): shapes.AppMeshVirtualGatewayListener[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.spec.listeners'),
        outputPath: 'virtualGateway.spec.listeners',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualGateway.virtualGateway.spec.listeners', props);
    return resource.getResponseField('virtualGateway.spec.listeners') as unknown as shapes.AppMeshVirtualGatewayListener[];
  }

  public get logging(): AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpecLogging {
    return new AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpecLogging(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpecBackendDefaults {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualGatewayInput) {
  }

  public get clientPolicy(): AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicy {
    return new AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicy(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicy {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualGatewayInput) {
  }

  public get tls(): AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTls {
    return new AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTls(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTls {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualGatewayInput) {
  }

  public get enforce(): boolean {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce') as unknown as boolean;
  }

  public get ports(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.ports'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.ports',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.ports', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.ports') as unknown as number[];
  }

  public get validation(): AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation {
    return new AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualGatewayInput) {
  }

  public get trust(): AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust {
    return new AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualGatewayInput) {
  }

  public get acm(): AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
    return new AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm(this.__scope, this.__resources, this.__input);
  }

  public get file(): AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile {
    return new AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualGatewayInput) {
  }

  public get certificateAuthorityArns(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns') as unknown as string[];
  }

}

export class AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualGatewayInput) {
  }

  public get certificateChain(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain') as unknown as string;
  }

}

export class AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpecLogging {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualGatewayInput) {
  }

  public get accessLog(): AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpecLoggingAccessLog {
    return new AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpecLoggingAccessLog(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpecLoggingAccessLog {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualGatewayInput) {
  }

  public get file(): AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpecLoggingAccessLogFile {
    return new AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpecLoggingAccessLogFile(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateVirtualGatewayVirtualGatewaySpecLoggingAccessLogFile {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualGatewayInput) {
  }

  public get path(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.spec.logging.accessLog.file.path'),
        outputPath: 'virtualGateway.spec.logging.accessLog.file.path',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualGateway.virtualGateway.spec.logging.accessLog.file.path', props);
    return resource.getResponseField('virtualGateway.spec.logging.accessLog.file.path') as unknown as string;
  }

}

export class AppMeshResponsesCreateVirtualGatewayVirtualGatewayStatus {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualGatewayInput) {
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualGateway.virtualGateway.status.status'),
        outputPath: 'virtualGateway.status.status',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          tags: this.__input.tags,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualGateway.virtualGateway.status.status', props);
    return resource.getResponseField('virtualGateway.status.status') as unknown as string;
  }

}

export class AppMeshResponsesCreateVirtualNode {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualNodeInput) {
  }

  public get virtualNode(): AppMeshResponsesCreateVirtualNodeVirtualNode {
    return new AppMeshResponsesCreateVirtualNodeVirtualNode(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateVirtualNodeVirtualNode {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualNodeInput) {
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.meshName'),
        outputPath: 'virtualNode.meshName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.__input.tags,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualNode.virtualNode.meshName', props);
    return resource.getResponseField('virtualNode.meshName') as unknown as string;
  }

  public get metadata(): AppMeshResponsesCreateVirtualNodeVirtualNodeMetadata {
    return new AppMeshResponsesCreateVirtualNodeVirtualNodeMetadata(this.__scope, this.__resources, this.__input);
  }

  public get spec(): AppMeshResponsesCreateVirtualNodeVirtualNodeSpec {
    return new AppMeshResponsesCreateVirtualNodeVirtualNodeSpec(this.__scope, this.__resources, this.__input);
  }

  public get status(): AppMeshResponsesCreateVirtualNodeVirtualNodeStatus {
    return new AppMeshResponsesCreateVirtualNodeVirtualNodeStatus(this.__scope, this.__resources, this.__input);
  }

  public get virtualNodeName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.virtualNodeName'),
        outputPath: 'virtualNode.virtualNodeName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.__input.tags,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualNode.virtualNode.virtualNodeName', props);
    return resource.getResponseField('virtualNode.virtualNodeName') as unknown as string;
  }

}

export class AppMeshResponsesCreateVirtualNodeVirtualNodeMetadata {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualNodeInput) {
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.metadata.arn'),
        outputPath: 'virtualNode.metadata.arn',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.__input.tags,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualNode.virtualNode.metadata.arn', props);
    return resource.getResponseField('virtualNode.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.metadata.createdAt'),
        outputPath: 'virtualNode.metadata.createdAt',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.__input.tags,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualNode.virtualNode.metadata.createdAt', props);
    return resource.getResponseField('virtualNode.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.metadata.lastUpdatedAt'),
        outputPath: 'virtualNode.metadata.lastUpdatedAt',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.__input.tags,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualNode.virtualNode.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualNode.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.metadata.meshOwner'),
        outputPath: 'virtualNode.metadata.meshOwner',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.__input.tags,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualNode.virtualNode.metadata.meshOwner', props);
    return resource.getResponseField('virtualNode.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.metadata.resourceOwner'),
        outputPath: 'virtualNode.metadata.resourceOwner',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.__input.tags,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualNode.virtualNode.metadata.resourceOwner', props);
    return resource.getResponseField('virtualNode.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.metadata.uid'),
        outputPath: 'virtualNode.metadata.uid',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.__input.tags,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualNode.virtualNode.metadata.uid', props);
    return resource.getResponseField('virtualNode.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.metadata.version'),
        outputPath: 'virtualNode.metadata.version',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.__input.tags,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualNode.virtualNode.metadata.version', props);
    return resource.getResponseField('virtualNode.metadata.version') as unknown as number;
  }

}

export class AppMeshResponsesCreateVirtualNodeVirtualNodeSpec {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualNodeInput) {
  }

  public get backendDefaults(): AppMeshResponsesCreateVirtualNodeVirtualNodeSpecBackendDefaults {
    return new AppMeshResponsesCreateVirtualNodeVirtualNodeSpecBackendDefaults(this.__scope, this.__resources, this.__input);
  }

  public get backends(): shapes.AppMeshBackend[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.spec.backends'),
        outputPath: 'virtualNode.spec.backends',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.__input.tags,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualNode.virtualNode.spec.backends', props);
    return resource.getResponseField('virtualNode.spec.backends') as unknown as shapes.AppMeshBackend[];
  }

  public get listeners(): shapes.AppMeshListener[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.spec.listeners'),
        outputPath: 'virtualNode.spec.listeners',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.__input.tags,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualNode.virtualNode.spec.listeners', props);
    return resource.getResponseField('virtualNode.spec.listeners') as unknown as shapes.AppMeshListener[];
  }

  public get logging(): AppMeshResponsesCreateVirtualNodeVirtualNodeSpecLogging {
    return new AppMeshResponsesCreateVirtualNodeVirtualNodeSpecLogging(this.__scope, this.__resources, this.__input);
  }

  public get serviceDiscovery(): AppMeshResponsesCreateVirtualNodeVirtualNodeSpecServiceDiscovery {
    return new AppMeshResponsesCreateVirtualNodeVirtualNodeSpecServiceDiscovery(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateVirtualNodeVirtualNodeSpecBackendDefaults {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualNodeInput) {
  }

  public get clientPolicy(): AppMeshResponsesCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicy {
    return new AppMeshResponsesCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicy(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicy {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualNodeInput) {
  }

  public get tls(): AppMeshResponsesCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTls {
    return new AppMeshResponsesCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTls(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTls {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualNodeInput) {
  }

  public get enforce(): boolean {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.enforce'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.enforce',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.__input.tags,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.enforce', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.enforce') as unknown as boolean;
  }

  public get ports(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.ports'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.ports',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.__input.tags,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.ports', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.ports') as unknown as number[];
  }

  public get validation(): AppMeshResponsesCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidation {
    return new AppMeshResponsesCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidation(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidation {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualNodeInput) {
  }

  public get trust(): AppMeshResponsesCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust {
    return new AppMeshResponsesCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualNodeInput) {
  }

  public get acm(): AppMeshResponsesCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
    return new AppMeshResponsesCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm(this.__scope, this.__resources, this.__input);
  }

  public get file(): AppMeshResponsesCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile {
    return new AppMeshResponsesCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualNodeInput) {
  }

  public get certificateAuthorityArns(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.__input.tags,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns') as unknown as string[];
  }

}

export class AppMeshResponsesCreateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualNodeInput) {
  }

  public get certificateChain(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.__input.tags,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain') as unknown as string;
  }

}

export class AppMeshResponsesCreateVirtualNodeVirtualNodeSpecLogging {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualNodeInput) {
  }

  public get accessLog(): AppMeshResponsesCreateVirtualNodeVirtualNodeSpecLoggingAccessLog {
    return new AppMeshResponsesCreateVirtualNodeVirtualNodeSpecLoggingAccessLog(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateVirtualNodeVirtualNodeSpecLoggingAccessLog {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualNodeInput) {
  }

  public get file(): AppMeshResponsesCreateVirtualNodeVirtualNodeSpecLoggingAccessLogFile {
    return new AppMeshResponsesCreateVirtualNodeVirtualNodeSpecLoggingAccessLogFile(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateVirtualNodeVirtualNodeSpecLoggingAccessLogFile {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualNodeInput) {
  }

  public get path(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.spec.logging.accessLog.file.path'),
        outputPath: 'virtualNode.spec.logging.accessLog.file.path',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.__input.tags,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualNode.virtualNode.spec.logging.accessLog.file.path', props);
    return resource.getResponseField('virtualNode.spec.logging.accessLog.file.path') as unknown as string;
  }

}

export class AppMeshResponsesCreateVirtualNodeVirtualNodeSpecServiceDiscovery {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualNodeInput) {
  }

  public get awsCloudMap(): AppMeshResponsesCreateVirtualNodeVirtualNodeSpecServiceDiscoveryAwsCloudMap {
    return new AppMeshResponsesCreateVirtualNodeVirtualNodeSpecServiceDiscoveryAwsCloudMap(this.__scope, this.__resources, this.__input);
  }

  public get dns(): AppMeshResponsesCreateVirtualNodeVirtualNodeSpecServiceDiscoveryDns {
    return new AppMeshResponsesCreateVirtualNodeVirtualNodeSpecServiceDiscoveryDns(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateVirtualNodeVirtualNodeSpecServiceDiscoveryAwsCloudMap {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualNodeInput) {
  }

  public get attributes(): shapes.AppMeshAwsCloudMapInstanceAttribute[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.attributes'),
        outputPath: 'virtualNode.spec.serviceDiscovery.awsCloudMap.attributes',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.__input.tags,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.attributes', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.awsCloudMap.attributes') as unknown as shapes.AppMeshAwsCloudMapInstanceAttribute[];
  }

  public get namespaceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName'),
        outputPath: 'virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.__input.tags,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName') as unknown as string;
  }

  public get serviceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName'),
        outputPath: 'virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.__input.tags,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName') as unknown as string;
  }

}

export class AppMeshResponsesCreateVirtualNodeVirtualNodeSpecServiceDiscoveryDns {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualNodeInput) {
  }

  public get hostname(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.spec.serviceDiscovery.dns.hostname'),
        outputPath: 'virtualNode.spec.serviceDiscovery.dns.hostname',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.__input.tags,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualNode.virtualNode.spec.serviceDiscovery.dns.hostname', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.dns.hostname') as unknown as string;
  }

}

export class AppMeshResponsesCreateVirtualNodeVirtualNodeStatus {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualNodeInput) {
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualNode.virtualNode.status.status'),
        outputPath: 'virtualNode.status.status',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          tags: this.__input.tags,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualNode.virtualNode.status.status', props);
    return resource.getResponseField('virtualNode.status.status') as unknown as string;
  }

}

export class AppMeshResponsesCreateVirtualRouter {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualRouterInput) {
  }

  public get virtualRouter(): AppMeshResponsesCreateVirtualRouterVirtualRouter {
    return new AppMeshResponsesCreateVirtualRouterVirtualRouter(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateVirtualRouterVirtualRouter {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualRouterInput) {
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualRouter.virtualRouter.meshName'),
        outputPath: 'virtualRouter.meshName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            listeners: this.__input.spec.listeners,
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualRouter.virtualRouter.meshName', props);
    return resource.getResponseField('virtualRouter.meshName') as unknown as string;
  }

  public get metadata(): AppMeshResponsesCreateVirtualRouterVirtualRouterMetadata {
    return new AppMeshResponsesCreateVirtualRouterVirtualRouterMetadata(this.__scope, this.__resources, this.__input);
  }

  public get spec(): AppMeshResponsesCreateVirtualRouterVirtualRouterSpec {
    return new AppMeshResponsesCreateVirtualRouterVirtualRouterSpec(this.__scope, this.__resources, this.__input);
  }

  public get status(): AppMeshResponsesCreateVirtualRouterVirtualRouterStatus {
    return new AppMeshResponsesCreateVirtualRouterVirtualRouterStatus(this.__scope, this.__resources, this.__input);
  }

  public get virtualRouterName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualRouter.virtualRouter.virtualRouterName'),
        outputPath: 'virtualRouter.virtualRouterName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            listeners: this.__input.spec.listeners,
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualRouter.virtualRouter.virtualRouterName', props);
    return resource.getResponseField('virtualRouter.virtualRouterName') as unknown as string;
  }

}

export class AppMeshResponsesCreateVirtualRouterVirtualRouterMetadata {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualRouterInput) {
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualRouter.virtualRouter.metadata.arn'),
        outputPath: 'virtualRouter.metadata.arn',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            listeners: this.__input.spec.listeners,
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualRouter.virtualRouter.metadata.arn', props);
    return resource.getResponseField('virtualRouter.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualRouter.virtualRouter.metadata.createdAt'),
        outputPath: 'virtualRouter.metadata.createdAt',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            listeners: this.__input.spec.listeners,
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualRouter.virtualRouter.metadata.createdAt', props);
    return resource.getResponseField('virtualRouter.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualRouter.virtualRouter.metadata.lastUpdatedAt'),
        outputPath: 'virtualRouter.metadata.lastUpdatedAt',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            listeners: this.__input.spec.listeners,
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualRouter.virtualRouter.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualRouter.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualRouter.virtualRouter.metadata.meshOwner'),
        outputPath: 'virtualRouter.metadata.meshOwner',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            listeners: this.__input.spec.listeners,
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualRouter.virtualRouter.metadata.meshOwner', props);
    return resource.getResponseField('virtualRouter.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualRouter.virtualRouter.metadata.resourceOwner'),
        outputPath: 'virtualRouter.metadata.resourceOwner',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            listeners: this.__input.spec.listeners,
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualRouter.virtualRouter.metadata.resourceOwner', props);
    return resource.getResponseField('virtualRouter.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualRouter.virtualRouter.metadata.uid'),
        outputPath: 'virtualRouter.metadata.uid',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            listeners: this.__input.spec.listeners,
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualRouter.virtualRouter.metadata.uid', props);
    return resource.getResponseField('virtualRouter.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualRouter.virtualRouter.metadata.version'),
        outputPath: 'virtualRouter.metadata.version',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            listeners: this.__input.spec.listeners,
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualRouter.virtualRouter.metadata.version', props);
    return resource.getResponseField('virtualRouter.metadata.version') as unknown as number;
  }

}

export class AppMeshResponsesCreateVirtualRouterVirtualRouterSpec {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualRouterInput) {
  }

  public get listeners(): shapes.AppMeshVirtualRouterListener[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualRouter.virtualRouter.spec.listeners'),
        outputPath: 'virtualRouter.spec.listeners',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            listeners: this.__input.spec.listeners,
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualRouter.virtualRouter.spec.listeners', props);
    return resource.getResponseField('virtualRouter.spec.listeners') as unknown as shapes.AppMeshVirtualRouterListener[];
  }

}

export class AppMeshResponsesCreateVirtualRouterVirtualRouterStatus {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualRouterInput) {
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualRouter.virtualRouter.status.status'),
        outputPath: 'virtualRouter.status.status',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            listeners: this.__input.spec.listeners,
          },
          tags: this.__input.tags,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualRouter.virtualRouter.status.status', props);
    return resource.getResponseField('virtualRouter.status.status') as unknown as string;
  }

}

export class AppMeshResponsesCreateVirtualService {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualServiceInput) {
  }

  public get virtualService(): AppMeshResponsesCreateVirtualServiceVirtualService {
    return new AppMeshResponsesCreateVirtualServiceVirtualService(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateVirtualServiceVirtualService {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualServiceInput) {
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualService.virtualService.meshName'),
        outputPath: 'virtualService.meshName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.__input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.__input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          tags: this.__input.tags,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualService.virtualService.meshName', props);
    return resource.getResponseField('virtualService.meshName') as unknown as string;
  }

  public get metadata(): AppMeshResponsesCreateVirtualServiceVirtualServiceMetadata {
    return new AppMeshResponsesCreateVirtualServiceVirtualServiceMetadata(this.__scope, this.__resources, this.__input);
  }

  public get spec(): AppMeshResponsesCreateVirtualServiceVirtualServiceSpec {
    return new AppMeshResponsesCreateVirtualServiceVirtualServiceSpec(this.__scope, this.__resources, this.__input);
  }

  public get status(): AppMeshResponsesCreateVirtualServiceVirtualServiceStatus {
    return new AppMeshResponsesCreateVirtualServiceVirtualServiceStatus(this.__scope, this.__resources, this.__input);
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualService.virtualService.virtualServiceName'),
        outputPath: 'virtualService.virtualServiceName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.__input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.__input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          tags: this.__input.tags,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualService.virtualService.virtualServiceName', props);
    return resource.getResponseField('virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshResponsesCreateVirtualServiceVirtualServiceMetadata {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualServiceInput) {
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualService.virtualService.metadata.arn'),
        outputPath: 'virtualService.metadata.arn',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.__input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.__input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          tags: this.__input.tags,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualService.virtualService.metadata.arn', props);
    return resource.getResponseField('virtualService.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualService.virtualService.metadata.createdAt'),
        outputPath: 'virtualService.metadata.createdAt',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.__input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.__input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          tags: this.__input.tags,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualService.virtualService.metadata.createdAt', props);
    return resource.getResponseField('virtualService.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualService.virtualService.metadata.lastUpdatedAt'),
        outputPath: 'virtualService.metadata.lastUpdatedAt',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.__input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.__input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          tags: this.__input.tags,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualService.virtualService.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualService.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualService.virtualService.metadata.meshOwner'),
        outputPath: 'virtualService.metadata.meshOwner',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.__input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.__input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          tags: this.__input.tags,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualService.virtualService.metadata.meshOwner', props);
    return resource.getResponseField('virtualService.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualService.virtualService.metadata.resourceOwner'),
        outputPath: 'virtualService.metadata.resourceOwner',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.__input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.__input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          tags: this.__input.tags,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualService.virtualService.metadata.resourceOwner', props);
    return resource.getResponseField('virtualService.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualService.virtualService.metadata.uid'),
        outputPath: 'virtualService.metadata.uid',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.__input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.__input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          tags: this.__input.tags,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualService.virtualService.metadata.uid', props);
    return resource.getResponseField('virtualService.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualService.virtualService.metadata.version'),
        outputPath: 'virtualService.metadata.version',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.__input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.__input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          tags: this.__input.tags,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualService.virtualService.metadata.version', props);
    return resource.getResponseField('virtualService.metadata.version') as unknown as number;
  }

}

export class AppMeshResponsesCreateVirtualServiceVirtualServiceSpec {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualServiceInput) {
  }

  public get provider(): AppMeshResponsesCreateVirtualServiceVirtualServiceSpecProvider {
    return new AppMeshResponsesCreateVirtualServiceVirtualServiceSpecProvider(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateVirtualServiceVirtualServiceSpecProvider {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualServiceInput) {
  }

  public get virtualNode(): AppMeshResponsesCreateVirtualServiceVirtualServiceSpecProviderVirtualNode {
    return new AppMeshResponsesCreateVirtualServiceVirtualServiceSpecProviderVirtualNode(this.__scope, this.__resources, this.__input);
  }

  public get virtualRouter(): AppMeshResponsesCreateVirtualServiceVirtualServiceSpecProviderVirtualRouter {
    return new AppMeshResponsesCreateVirtualServiceVirtualServiceSpecProviderVirtualRouter(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesCreateVirtualServiceVirtualServiceSpecProviderVirtualNode {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualServiceInput) {
  }

  public get virtualNodeName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualService.virtualService.spec.provider.virtualNode.virtualNodeName'),
        outputPath: 'virtualService.spec.provider.virtualNode.virtualNodeName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.__input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.__input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          tags: this.__input.tags,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualService.virtualService.spec.provider.virtualNode.virtualNodeName', props);
    return resource.getResponseField('virtualService.spec.provider.virtualNode.virtualNodeName') as unknown as string;
  }

}

export class AppMeshResponsesCreateVirtualServiceVirtualServiceSpecProviderVirtualRouter {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualServiceInput) {
  }

  public get virtualRouterName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualService.virtualService.spec.provider.virtualRouter.virtualRouterName'),
        outputPath: 'virtualService.spec.provider.virtualRouter.virtualRouterName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.__input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.__input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          tags: this.__input.tags,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualService.virtualService.spec.provider.virtualRouter.virtualRouterName', props);
    return resource.getResponseField('virtualService.spec.provider.virtualRouter.virtualRouterName') as unknown as string;
  }

}

export class AppMeshResponsesCreateVirtualServiceVirtualServiceStatus {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshCreateVirtualServiceInput) {
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.CreateVirtualService.virtualService.status.status'),
        outputPath: 'virtualService.status.status',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.__input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.__input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          tags: this.__input.tags,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'CreateVirtualService.virtualService.status.status', props);
    return resource.getResponseField('virtualService.status.status') as unknown as string;
  }

}

export class AppMeshResponsesDeleteGatewayRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteGatewayRouteInput) {
  }

  public get gatewayRoute(): AppMeshResponsesDeleteGatewayRouteGatewayRoute {
    return new AppMeshResponsesDeleteGatewayRouteGatewayRoute(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteGatewayRouteGatewayRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteGatewayRouteInput) {
  }

  public get gatewayRouteName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.gatewayRouteName'),
        outputPath: 'gatewayRoute.gatewayRouteName',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteGatewayRoute.gatewayRoute.gatewayRouteName', props);
    return resource.getResponseField('gatewayRoute.gatewayRouteName') as unknown as string;
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.meshName'),
        outputPath: 'gatewayRoute.meshName',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteGatewayRoute.gatewayRoute.meshName', props);
    return resource.getResponseField('gatewayRoute.meshName') as unknown as string;
  }

  public get metadata(): AppMeshResponsesDeleteGatewayRouteGatewayRouteMetadata {
    return new AppMeshResponsesDeleteGatewayRouteGatewayRouteMetadata(this.__scope, this.__resources, this.__input);
  }

  public get spec(): AppMeshResponsesDeleteGatewayRouteGatewayRouteSpec {
    return new AppMeshResponsesDeleteGatewayRouteGatewayRouteSpec(this.__scope, this.__resources, this.__input);
  }

  public get status(): AppMeshResponsesDeleteGatewayRouteGatewayRouteStatus {
    return new AppMeshResponsesDeleteGatewayRouteGatewayRouteStatus(this.__scope, this.__resources, this.__input);
  }

  public get virtualGatewayName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.virtualGatewayName'),
        outputPath: 'gatewayRoute.virtualGatewayName',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteGatewayRoute.gatewayRoute.virtualGatewayName', props);
    return resource.getResponseField('gatewayRoute.virtualGatewayName') as unknown as string;
  }

}

export class AppMeshResponsesDeleteGatewayRouteGatewayRouteMetadata {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteGatewayRouteInput) {
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.metadata.arn'),
        outputPath: 'gatewayRoute.metadata.arn',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteGatewayRoute.gatewayRoute.metadata.arn', props);
    return resource.getResponseField('gatewayRoute.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.metadata.createdAt'),
        outputPath: 'gatewayRoute.metadata.createdAt',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteGatewayRoute.gatewayRoute.metadata.createdAt', props);
    return resource.getResponseField('gatewayRoute.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.metadata.lastUpdatedAt'),
        outputPath: 'gatewayRoute.metadata.lastUpdatedAt',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteGatewayRoute.gatewayRoute.metadata.lastUpdatedAt', props);
    return resource.getResponseField('gatewayRoute.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.metadata.meshOwner'),
        outputPath: 'gatewayRoute.metadata.meshOwner',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteGatewayRoute.gatewayRoute.metadata.meshOwner', props);
    return resource.getResponseField('gatewayRoute.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.metadata.resourceOwner'),
        outputPath: 'gatewayRoute.metadata.resourceOwner',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteGatewayRoute.gatewayRoute.metadata.resourceOwner', props);
    return resource.getResponseField('gatewayRoute.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.metadata.uid'),
        outputPath: 'gatewayRoute.metadata.uid',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteGatewayRoute.gatewayRoute.metadata.uid', props);
    return resource.getResponseField('gatewayRoute.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.metadata.version'),
        outputPath: 'gatewayRoute.metadata.version',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteGatewayRoute.gatewayRoute.metadata.version', props);
    return resource.getResponseField('gatewayRoute.metadata.version') as unknown as number;
  }

}

export class AppMeshResponsesDeleteGatewayRouteGatewayRouteSpec {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteGatewayRouteInput) {
  }

  public get grpcRoute(): AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecGrpcRoute {
    return new AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecGrpcRoute(this.__scope, this.__resources, this.__input);
  }

  public get http2Route(): AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecHttp2Route {
    return new AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecHttp2Route(this.__scope, this.__resources, this.__input);
  }

  public get httpRoute(): AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecHttpRoute {
    return new AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecHttpRoute(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecGrpcRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteGatewayRouteInput) {
  }

  public get action(): AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecGrpcRouteAction {
    return new AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecGrpcRouteAction(this.__scope, this.__resources, this.__input);
  }

  public get match(): AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecGrpcRouteMatch {
    return new AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecGrpcRouteMatch(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecGrpcRouteAction {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteGatewayRouteInput) {
  }

  public get target(): AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecGrpcRouteActionTarget {
    return new AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecGrpcRouteActionTarget(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecGrpcRouteActionTarget {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteGatewayRouteInput) {
  }

  public get virtualService(): AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecGrpcRouteActionTargetVirtualService {
    return new AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecGrpcRouteActionTargetVirtualService(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecGrpcRouteActionTargetVirtualService {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteGatewayRouteInput) {
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName'),
        outputPath: 'gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteGatewayRoute.gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName', props);
    return resource.getResponseField('gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecGrpcRouteMatch {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteGatewayRouteInput) {
  }

  public get serviceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.spec.grpcRoute.match.serviceName'),
        outputPath: 'gatewayRoute.spec.grpcRoute.match.serviceName',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteGatewayRoute.gatewayRoute.spec.grpcRoute.match.serviceName', props);
    return resource.getResponseField('gatewayRoute.spec.grpcRoute.match.serviceName') as unknown as string;
  }

}

export class AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecHttp2Route {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteGatewayRouteInput) {
  }

  public get action(): AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecHttp2RouteAction {
    return new AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecHttp2RouteAction(this.__scope, this.__resources, this.__input);
  }

  public get match(): AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecHttp2RouteMatch {
    return new AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecHttp2RouteMatch(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecHttp2RouteAction {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteGatewayRouteInput) {
  }

  public get target(): AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecHttp2RouteActionTarget {
    return new AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecHttp2RouteActionTarget(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecHttp2RouteActionTarget {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteGatewayRouteInput) {
  }

  public get virtualService(): AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecHttp2RouteActionTargetVirtualService {
    return new AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecHttp2RouteActionTargetVirtualService(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecHttp2RouteActionTargetVirtualService {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteGatewayRouteInput) {
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName'),
        outputPath: 'gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteGatewayRoute.gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName', props);
    return resource.getResponseField('gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecHttp2RouteMatch {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteGatewayRouteInput) {
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.spec.http2Route.match.prefix'),
        outputPath: 'gatewayRoute.spec.http2Route.match.prefix',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteGatewayRoute.gatewayRoute.spec.http2Route.match.prefix', props);
    return resource.getResponseField('gatewayRoute.spec.http2Route.match.prefix') as unknown as string;
  }

}

export class AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecHttpRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteGatewayRouteInput) {
  }

  public get action(): AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecHttpRouteAction {
    return new AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecHttpRouteAction(this.__scope, this.__resources, this.__input);
  }

  public get match(): AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecHttpRouteMatch {
    return new AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecHttpRouteMatch(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecHttpRouteAction {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteGatewayRouteInput) {
  }

  public get target(): AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecHttpRouteActionTarget {
    return new AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecHttpRouteActionTarget(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecHttpRouteActionTarget {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteGatewayRouteInput) {
  }

  public get virtualService(): AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecHttpRouteActionTargetVirtualService {
    return new AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecHttpRouteActionTargetVirtualService(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecHttpRouteActionTargetVirtualService {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteGatewayRouteInput) {
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName'),
        outputPath: 'gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteGatewayRoute.gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName', props);
    return resource.getResponseField('gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshResponsesDeleteGatewayRouteGatewayRouteSpecHttpRouteMatch {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteGatewayRouteInput) {
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.spec.httpRoute.match.prefix'),
        outputPath: 'gatewayRoute.spec.httpRoute.match.prefix',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteGatewayRoute.gatewayRoute.spec.httpRoute.match.prefix', props);
    return resource.getResponseField('gatewayRoute.spec.httpRoute.match.prefix') as unknown as string;
  }

}

export class AppMeshResponsesDeleteGatewayRouteGatewayRouteStatus {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteGatewayRouteInput) {
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteGatewayRoute.gatewayRoute.status.status'),
        outputPath: 'gatewayRoute.status.status',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteGatewayRoute.gatewayRoute.status.status', props);
    return resource.getResponseField('gatewayRoute.status.status') as unknown as string;
  }

}

export class AppMeshResponsesDeleteMesh {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteMeshInput) {
  }

  public get mesh(): AppMeshResponsesDeleteMeshMesh {
    return new AppMeshResponsesDeleteMeshMesh(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteMeshMesh {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteMeshInput) {
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteMesh.mesh.meshName'),
        outputPath: 'mesh.meshName',
        parameters: {
          meshName: this.__input.meshName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteMesh.mesh.meshName', props);
    return resource.getResponseField('mesh.meshName') as unknown as string;
  }

  public get metadata(): AppMeshResponsesDeleteMeshMeshMetadata {
    return new AppMeshResponsesDeleteMeshMeshMetadata(this.__scope, this.__resources, this.__input);
  }

  public get spec(): AppMeshResponsesDeleteMeshMeshSpec {
    return new AppMeshResponsesDeleteMeshMeshSpec(this.__scope, this.__resources, this.__input);
  }

  public get status(): AppMeshResponsesDeleteMeshMeshStatus {
    return new AppMeshResponsesDeleteMeshMeshStatus(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteMeshMeshMetadata {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteMeshInput) {
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteMesh.mesh.metadata.arn'),
        outputPath: 'mesh.metadata.arn',
        parameters: {
          meshName: this.__input.meshName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteMesh.mesh.metadata.arn', props);
    return resource.getResponseField('mesh.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteMesh.mesh.metadata.createdAt'),
        outputPath: 'mesh.metadata.createdAt',
        parameters: {
          meshName: this.__input.meshName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteMesh.mesh.metadata.createdAt', props);
    return resource.getResponseField('mesh.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteMesh.mesh.metadata.lastUpdatedAt'),
        outputPath: 'mesh.metadata.lastUpdatedAt',
        parameters: {
          meshName: this.__input.meshName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteMesh.mesh.metadata.lastUpdatedAt', props);
    return resource.getResponseField('mesh.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteMesh.mesh.metadata.meshOwner'),
        outputPath: 'mesh.metadata.meshOwner',
        parameters: {
          meshName: this.__input.meshName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteMesh.mesh.metadata.meshOwner', props);
    return resource.getResponseField('mesh.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteMesh.mesh.metadata.resourceOwner'),
        outputPath: 'mesh.metadata.resourceOwner',
        parameters: {
          meshName: this.__input.meshName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteMesh.mesh.metadata.resourceOwner', props);
    return resource.getResponseField('mesh.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteMesh.mesh.metadata.uid'),
        outputPath: 'mesh.metadata.uid',
        parameters: {
          meshName: this.__input.meshName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteMesh.mesh.metadata.uid', props);
    return resource.getResponseField('mesh.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteMesh.mesh.metadata.version'),
        outputPath: 'mesh.metadata.version',
        parameters: {
          meshName: this.__input.meshName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteMesh.mesh.metadata.version', props);
    return resource.getResponseField('mesh.metadata.version') as unknown as number;
  }

}

export class AppMeshResponsesDeleteMeshMeshSpec {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteMeshInput) {
  }

  public get egressFilter(): AppMeshResponsesDeleteMeshMeshSpecEgressFilter {
    return new AppMeshResponsesDeleteMeshMeshSpecEgressFilter(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteMeshMeshSpecEgressFilter {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteMeshInput) {
  }

  public get type(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteMesh.mesh.spec.egressFilter.type'),
        outputPath: 'mesh.spec.egressFilter.type',
        parameters: {
          meshName: this.__input.meshName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteMesh.mesh.spec.egressFilter.type', props);
    return resource.getResponseField('mesh.spec.egressFilter.type') as unknown as string;
  }

}

export class AppMeshResponsesDeleteMeshMeshStatus {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteMeshInput) {
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteMesh.mesh.status.status'),
        outputPath: 'mesh.status.status',
        parameters: {
          meshName: this.__input.meshName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteMesh.mesh.status.status', props);
    return resource.getResponseField('mesh.status.status') as unknown as string;
  }

}

export class AppMeshResponsesDeleteRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get route(): AppMeshResponsesDeleteRouteRoute {
    return new AppMeshResponsesDeleteRouteRoute(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteRouteRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.meshName'),
        outputPath: 'route.meshName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.meshName', props);
    return resource.getResponseField('route.meshName') as unknown as string;
  }

  public get metadata(): AppMeshResponsesDeleteRouteRouteMetadata {
    return new AppMeshResponsesDeleteRouteRouteMetadata(this.__scope, this.__resources, this.__input);
  }

  public get routeName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.routeName'),
        outputPath: 'route.routeName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.routeName', props);
    return resource.getResponseField('route.routeName') as unknown as string;
  }

  public get spec(): AppMeshResponsesDeleteRouteRouteSpec {
    return new AppMeshResponsesDeleteRouteRouteSpec(this.__scope, this.__resources, this.__input);
  }

  public get status(): AppMeshResponsesDeleteRouteRouteStatus {
    return new AppMeshResponsesDeleteRouteRouteStatus(this.__scope, this.__resources, this.__input);
  }

  public get virtualRouterName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.virtualRouterName'),
        outputPath: 'route.virtualRouterName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.virtualRouterName', props);
    return resource.getResponseField('route.virtualRouterName') as unknown as string;
  }

}

export class AppMeshResponsesDeleteRouteRouteMetadata {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.metadata.arn'),
        outputPath: 'route.metadata.arn',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.metadata.arn', props);
    return resource.getResponseField('route.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.metadata.createdAt'),
        outputPath: 'route.metadata.createdAt',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.metadata.createdAt', props);
    return resource.getResponseField('route.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.metadata.lastUpdatedAt'),
        outputPath: 'route.metadata.lastUpdatedAt',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.metadata.lastUpdatedAt', props);
    return resource.getResponseField('route.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.metadata.meshOwner'),
        outputPath: 'route.metadata.meshOwner',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.metadata.meshOwner', props);
    return resource.getResponseField('route.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.metadata.resourceOwner'),
        outputPath: 'route.metadata.resourceOwner',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.metadata.resourceOwner', props);
    return resource.getResponseField('route.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.metadata.uid'),
        outputPath: 'route.metadata.uid',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.metadata.uid', props);
    return resource.getResponseField('route.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.metadata.version'),
        outputPath: 'route.metadata.version',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.metadata.version', props);
    return resource.getResponseField('route.metadata.version') as unknown as number;
  }

}

export class AppMeshResponsesDeleteRouteRouteSpec {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get grpcRoute(): AppMeshResponsesDeleteRouteRouteSpecGrpcRoute {
    return new AppMeshResponsesDeleteRouteRouteSpecGrpcRoute(this.__scope, this.__resources, this.__input);
  }

  public get http2Route(): AppMeshResponsesDeleteRouteRouteSpecHttp2Route {
    return new AppMeshResponsesDeleteRouteRouteSpecHttp2Route(this.__scope, this.__resources, this.__input);
  }

  public get httpRoute(): AppMeshResponsesDeleteRouteRouteSpecHttpRoute {
    return new AppMeshResponsesDeleteRouteRouteSpecHttpRoute(this.__scope, this.__resources, this.__input);
  }

  public get priority(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.priority'),
        outputPath: 'route.spec.priority',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.priority', props);
    return resource.getResponseField('route.spec.priority') as unknown as number;
  }

  public get tcpRoute(): AppMeshResponsesDeleteRouteRouteSpecTcpRoute {
    return new AppMeshResponsesDeleteRouteRouteSpecTcpRoute(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteRouteRouteSpecGrpcRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get action(): AppMeshResponsesDeleteRouteRouteSpecGrpcRouteAction {
    return new AppMeshResponsesDeleteRouteRouteSpecGrpcRouteAction(this.__scope, this.__resources, this.__input);
  }

  public get match(): AppMeshResponsesDeleteRouteRouteSpecGrpcRouteMatch {
    return new AppMeshResponsesDeleteRouteRouteSpecGrpcRouteMatch(this.__scope, this.__resources, this.__input);
  }

  public get retryPolicy(): AppMeshResponsesDeleteRouteRouteSpecGrpcRouteRetryPolicy {
    return new AppMeshResponsesDeleteRouteRouteSpecGrpcRouteRetryPolicy(this.__scope, this.__resources, this.__input);
  }

  public get timeout(): AppMeshResponsesDeleteRouteRouteSpecGrpcRouteTimeout {
    return new AppMeshResponsesDeleteRouteRouteSpecGrpcRouteTimeout(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteRouteRouteSpecGrpcRouteAction {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.grpcRoute.action.weightedTargets'),
        outputPath: 'route.spec.grpcRoute.action.weightedTargets',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.grpcRoute.action.weightedTargets', props);
    return resource.getResponseField('route.spec.grpcRoute.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshResponsesDeleteRouteRouteSpecGrpcRouteMatch {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get metadata(): shapes.AppMeshGrpcRouteMetadata[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.grpcRoute.match.metadata'),
        outputPath: 'route.spec.grpcRoute.match.metadata',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.grpcRoute.match.metadata', props);
    return resource.getResponseField('route.spec.grpcRoute.match.metadata') as unknown as shapes.AppMeshGrpcRouteMetadata[];
  }

  public get methodName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.grpcRoute.match.methodName'),
        outputPath: 'route.spec.grpcRoute.match.methodName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.grpcRoute.match.methodName', props);
    return resource.getResponseField('route.spec.grpcRoute.match.methodName') as unknown as string;
  }

  public get serviceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.grpcRoute.match.serviceName'),
        outputPath: 'route.spec.grpcRoute.match.serviceName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.grpcRoute.match.serviceName', props);
    return resource.getResponseField('route.spec.grpcRoute.match.serviceName') as unknown as string;
  }

}

export class AppMeshResponsesDeleteRouteRouteSpecGrpcRouteRetryPolicy {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get grpcRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.grpcRoute.retryPolicy.grpcRetryEvents'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.grpcRetryEvents',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.grpcRoute.retryPolicy.grpcRetryEvents', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.grpcRetryEvents') as unknown as string[];
  }

  public get httpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.grpcRoute.retryPolicy.httpRetryEvents'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.httpRetryEvents',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.grpcRoute.retryPolicy.httpRetryEvents', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.httpRetryEvents') as unknown as string[];
  }

  public get maxRetries(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.grpcRoute.retryPolicy.maxRetries'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.maxRetries',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.grpcRoute.retryPolicy.maxRetries', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.maxRetries') as unknown as number;
  }

  public get perRetryTimeout(): AppMeshResponsesDeleteRouteRouteSpecGrpcRouteRetryPolicyPerRetryTimeout {
    return new AppMeshResponsesDeleteRouteRouteSpecGrpcRouteRetryPolicyPerRetryTimeout(this.__scope, this.__resources, this.__input);
  }

  public get tcpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.grpcRoute.retryPolicy.tcpRetryEvents'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.tcpRetryEvents',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.grpcRoute.retryPolicy.tcpRetryEvents', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.tcpRetryEvents') as unknown as string[];
  }

}

export class AppMeshResponsesDeleteRouteRouteSpecGrpcRouteRetryPolicyPerRetryTimeout {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.value'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.perRetryTimeout.value',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.value', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.perRetryTimeout.value') as unknown as number;
  }

}

export class AppMeshResponsesDeleteRouteRouteSpecGrpcRouteTimeout {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get idle(): AppMeshResponsesDeleteRouteRouteSpecGrpcRouteTimeoutIdle {
    return new AppMeshResponsesDeleteRouteRouteSpecGrpcRouteTimeoutIdle(this.__scope, this.__resources, this.__input);
  }

  public get perRequest(): AppMeshResponsesDeleteRouteRouteSpecGrpcRouteTimeoutPerRequest {
    return new AppMeshResponsesDeleteRouteRouteSpecGrpcRouteTimeoutPerRequest(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteRouteRouteSpecGrpcRouteTimeoutIdle {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.grpcRoute.timeout.idle.unit'),
        outputPath: 'route.spec.grpcRoute.timeout.idle.unit',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.grpcRoute.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.grpcRoute.timeout.idle.value'),
        outputPath: 'route.spec.grpcRoute.timeout.idle.value',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.grpcRoute.timeout.idle.value', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshResponsesDeleteRouteRouteSpecGrpcRouteTimeoutPerRequest {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.grpcRoute.timeout.perRequest.unit'),
        outputPath: 'route.spec.grpcRoute.timeout.perRequest.unit',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.grpcRoute.timeout.perRequest.unit', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.perRequest.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.grpcRoute.timeout.perRequest.value'),
        outputPath: 'route.spec.grpcRoute.timeout.perRequest.value',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.grpcRoute.timeout.perRequest.value', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.perRequest.value') as unknown as number;
  }

}

export class AppMeshResponsesDeleteRouteRouteSpecHttp2Route {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get action(): AppMeshResponsesDeleteRouteRouteSpecHttp2RouteAction {
    return new AppMeshResponsesDeleteRouteRouteSpecHttp2RouteAction(this.__scope, this.__resources, this.__input);
  }

  public get match(): AppMeshResponsesDeleteRouteRouteSpecHttp2RouteMatch {
    return new AppMeshResponsesDeleteRouteRouteSpecHttp2RouteMatch(this.__scope, this.__resources, this.__input);
  }

  public get retryPolicy(): AppMeshResponsesDeleteRouteRouteSpecHttp2RouteRetryPolicy {
    return new AppMeshResponsesDeleteRouteRouteSpecHttp2RouteRetryPolicy(this.__scope, this.__resources, this.__input);
  }

  public get timeout(): AppMeshResponsesDeleteRouteRouteSpecHttp2RouteTimeout {
    return new AppMeshResponsesDeleteRouteRouteSpecHttp2RouteTimeout(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteRouteRouteSpecHttp2RouteAction {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.http2Route.action.weightedTargets'),
        outputPath: 'route.spec.http2Route.action.weightedTargets',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.http2Route.action.weightedTargets', props);
    return resource.getResponseField('route.spec.http2Route.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshResponsesDeleteRouteRouteSpecHttp2RouteMatch {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get headers(): shapes.AppMeshHttpRouteHeader[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.http2Route.match.headers'),
        outputPath: 'route.spec.http2Route.match.headers',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.http2Route.match.headers', props);
    return resource.getResponseField('route.spec.http2Route.match.headers') as unknown as shapes.AppMeshHttpRouteHeader[];
  }

  public get method(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.http2Route.match.method'),
        outputPath: 'route.spec.http2Route.match.method',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.http2Route.match.method', props);
    return resource.getResponseField('route.spec.http2Route.match.method') as unknown as string;
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.http2Route.match.prefix'),
        outputPath: 'route.spec.http2Route.match.prefix',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.http2Route.match.prefix', props);
    return resource.getResponseField('route.spec.http2Route.match.prefix') as unknown as string;
  }

  public get scheme(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.http2Route.match.scheme'),
        outputPath: 'route.spec.http2Route.match.scheme',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.http2Route.match.scheme', props);
    return resource.getResponseField('route.spec.http2Route.match.scheme') as unknown as string;
  }

}

export class AppMeshResponsesDeleteRouteRouteSpecHttp2RouteRetryPolicy {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get httpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.http2Route.retryPolicy.httpRetryEvents'),
        outputPath: 'route.spec.http2Route.retryPolicy.httpRetryEvents',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.http2Route.retryPolicy.httpRetryEvents', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.httpRetryEvents') as unknown as string[];
  }

  public get maxRetries(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.http2Route.retryPolicy.maxRetries'),
        outputPath: 'route.spec.http2Route.retryPolicy.maxRetries',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.http2Route.retryPolicy.maxRetries', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.maxRetries') as unknown as number;
  }

  public get perRetryTimeout(): AppMeshResponsesDeleteRouteRouteSpecHttp2RouteRetryPolicyPerRetryTimeout {
    return new AppMeshResponsesDeleteRouteRouteSpecHttp2RouteRetryPolicyPerRetryTimeout(this.__scope, this.__resources, this.__input);
  }

  public get tcpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.http2Route.retryPolicy.tcpRetryEvents'),
        outputPath: 'route.spec.http2Route.retryPolicy.tcpRetryEvents',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.http2Route.retryPolicy.tcpRetryEvents', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.tcpRetryEvents') as unknown as string[];
  }

}

export class AppMeshResponsesDeleteRouteRouteSpecHttp2RouteRetryPolicyPerRetryTimeout {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.unit'),
        outputPath: 'route.spec.http2Route.retryPolicy.perRetryTimeout.unit',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.unit', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.perRetryTimeout.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.value'),
        outputPath: 'route.spec.http2Route.retryPolicy.perRetryTimeout.value',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.value', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.perRetryTimeout.value') as unknown as number;
  }

}

export class AppMeshResponsesDeleteRouteRouteSpecHttp2RouteTimeout {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get idle(): AppMeshResponsesDeleteRouteRouteSpecHttp2RouteTimeoutIdle {
    return new AppMeshResponsesDeleteRouteRouteSpecHttp2RouteTimeoutIdle(this.__scope, this.__resources, this.__input);
  }

  public get perRequest(): AppMeshResponsesDeleteRouteRouteSpecHttp2RouteTimeoutPerRequest {
    return new AppMeshResponsesDeleteRouteRouteSpecHttp2RouteTimeoutPerRequest(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteRouteRouteSpecHttp2RouteTimeoutIdle {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.http2Route.timeout.idle.unit'),
        outputPath: 'route.spec.http2Route.timeout.idle.unit',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.http2Route.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.http2Route.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.http2Route.timeout.idle.value'),
        outputPath: 'route.spec.http2Route.timeout.idle.value',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.http2Route.timeout.idle.value', props);
    return resource.getResponseField('route.spec.http2Route.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshResponsesDeleteRouteRouteSpecHttp2RouteTimeoutPerRequest {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.http2Route.timeout.perRequest.unit'),
        outputPath: 'route.spec.http2Route.timeout.perRequest.unit',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.http2Route.timeout.perRequest.unit', props);
    return resource.getResponseField('route.spec.http2Route.timeout.perRequest.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.http2Route.timeout.perRequest.value'),
        outputPath: 'route.spec.http2Route.timeout.perRequest.value',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.http2Route.timeout.perRequest.value', props);
    return resource.getResponseField('route.spec.http2Route.timeout.perRequest.value') as unknown as number;
  }

}

export class AppMeshResponsesDeleteRouteRouteSpecHttpRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get action(): AppMeshResponsesDeleteRouteRouteSpecHttpRouteAction {
    return new AppMeshResponsesDeleteRouteRouteSpecHttpRouteAction(this.__scope, this.__resources, this.__input);
  }

  public get match(): AppMeshResponsesDeleteRouteRouteSpecHttpRouteMatch {
    return new AppMeshResponsesDeleteRouteRouteSpecHttpRouteMatch(this.__scope, this.__resources, this.__input);
  }

  public get retryPolicy(): AppMeshResponsesDeleteRouteRouteSpecHttpRouteRetryPolicy {
    return new AppMeshResponsesDeleteRouteRouteSpecHttpRouteRetryPolicy(this.__scope, this.__resources, this.__input);
  }

  public get timeout(): AppMeshResponsesDeleteRouteRouteSpecHttpRouteTimeout {
    return new AppMeshResponsesDeleteRouteRouteSpecHttpRouteTimeout(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteRouteRouteSpecHttpRouteAction {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.httpRoute.action.weightedTargets'),
        outputPath: 'route.spec.httpRoute.action.weightedTargets',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.httpRoute.action.weightedTargets', props);
    return resource.getResponseField('route.spec.httpRoute.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshResponsesDeleteRouteRouteSpecHttpRouteMatch {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get headers(): shapes.AppMeshHttpRouteHeader[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.httpRoute.match.headers'),
        outputPath: 'route.spec.httpRoute.match.headers',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.httpRoute.match.headers', props);
    return resource.getResponseField('route.spec.httpRoute.match.headers') as unknown as shapes.AppMeshHttpRouteHeader[];
  }

  public get method(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.httpRoute.match.method'),
        outputPath: 'route.spec.httpRoute.match.method',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.httpRoute.match.method', props);
    return resource.getResponseField('route.spec.httpRoute.match.method') as unknown as string;
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.httpRoute.match.prefix'),
        outputPath: 'route.spec.httpRoute.match.prefix',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.httpRoute.match.prefix', props);
    return resource.getResponseField('route.spec.httpRoute.match.prefix') as unknown as string;
  }

  public get scheme(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.httpRoute.match.scheme'),
        outputPath: 'route.spec.httpRoute.match.scheme',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.httpRoute.match.scheme', props);
    return resource.getResponseField('route.spec.httpRoute.match.scheme') as unknown as string;
  }

}

export class AppMeshResponsesDeleteRouteRouteSpecHttpRouteRetryPolicy {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get httpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.httpRoute.retryPolicy.httpRetryEvents'),
        outputPath: 'route.spec.httpRoute.retryPolicy.httpRetryEvents',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.httpRoute.retryPolicy.httpRetryEvents', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.httpRetryEvents') as unknown as string[];
  }

  public get maxRetries(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.httpRoute.retryPolicy.maxRetries'),
        outputPath: 'route.spec.httpRoute.retryPolicy.maxRetries',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.httpRoute.retryPolicy.maxRetries', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.maxRetries') as unknown as number;
  }

  public get perRetryTimeout(): AppMeshResponsesDeleteRouteRouteSpecHttpRouteRetryPolicyPerRetryTimeout {
    return new AppMeshResponsesDeleteRouteRouteSpecHttpRouteRetryPolicyPerRetryTimeout(this.__scope, this.__resources, this.__input);
  }

  public get tcpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.httpRoute.retryPolicy.tcpRetryEvents'),
        outputPath: 'route.spec.httpRoute.retryPolicy.tcpRetryEvents',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.httpRoute.retryPolicy.tcpRetryEvents', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.tcpRetryEvents') as unknown as string[];
  }

}

export class AppMeshResponsesDeleteRouteRouteSpecHttpRouteRetryPolicyPerRetryTimeout {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.unit'),
        outputPath: 'route.spec.httpRoute.retryPolicy.perRetryTimeout.unit',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.unit', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.perRetryTimeout.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.value'),
        outputPath: 'route.spec.httpRoute.retryPolicy.perRetryTimeout.value',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.value', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.perRetryTimeout.value') as unknown as number;
  }

}

export class AppMeshResponsesDeleteRouteRouteSpecHttpRouteTimeout {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get idle(): AppMeshResponsesDeleteRouteRouteSpecHttpRouteTimeoutIdle {
    return new AppMeshResponsesDeleteRouteRouteSpecHttpRouteTimeoutIdle(this.__scope, this.__resources, this.__input);
  }

  public get perRequest(): AppMeshResponsesDeleteRouteRouteSpecHttpRouteTimeoutPerRequest {
    return new AppMeshResponsesDeleteRouteRouteSpecHttpRouteTimeoutPerRequest(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteRouteRouteSpecHttpRouteTimeoutIdle {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.httpRoute.timeout.idle.unit'),
        outputPath: 'route.spec.httpRoute.timeout.idle.unit',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.httpRoute.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.httpRoute.timeout.idle.value'),
        outputPath: 'route.spec.httpRoute.timeout.idle.value',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.httpRoute.timeout.idle.value', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshResponsesDeleteRouteRouteSpecHttpRouteTimeoutPerRequest {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.httpRoute.timeout.perRequest.unit'),
        outputPath: 'route.spec.httpRoute.timeout.perRequest.unit',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.httpRoute.timeout.perRequest.unit', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.perRequest.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.httpRoute.timeout.perRequest.value'),
        outputPath: 'route.spec.httpRoute.timeout.perRequest.value',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.httpRoute.timeout.perRequest.value', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.perRequest.value') as unknown as number;
  }

}

export class AppMeshResponsesDeleteRouteRouteSpecTcpRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get action(): AppMeshResponsesDeleteRouteRouteSpecTcpRouteAction {
    return new AppMeshResponsesDeleteRouteRouteSpecTcpRouteAction(this.__scope, this.__resources, this.__input);
  }

  public get timeout(): AppMeshResponsesDeleteRouteRouteSpecTcpRouteTimeout {
    return new AppMeshResponsesDeleteRouteRouteSpecTcpRouteTimeout(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteRouteRouteSpecTcpRouteAction {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.tcpRoute.action.weightedTargets'),
        outputPath: 'route.spec.tcpRoute.action.weightedTargets',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.tcpRoute.action.weightedTargets', props);
    return resource.getResponseField('route.spec.tcpRoute.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshResponsesDeleteRouteRouteSpecTcpRouteTimeout {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get idle(): AppMeshResponsesDeleteRouteRouteSpecTcpRouteTimeoutIdle {
    return new AppMeshResponsesDeleteRouteRouteSpecTcpRouteTimeoutIdle(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteRouteRouteSpecTcpRouteTimeoutIdle {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.tcpRoute.timeout.idle.unit'),
        outputPath: 'route.spec.tcpRoute.timeout.idle.unit',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.tcpRoute.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.tcpRoute.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.spec.tcpRoute.timeout.idle.value'),
        outputPath: 'route.spec.tcpRoute.timeout.idle.value',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.spec.tcpRoute.timeout.idle.value', props);
    return resource.getResponseField('route.spec.tcpRoute.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshResponsesDeleteRouteRouteStatus {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteRouteInput) {
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteRoute.route.status.status'),
        outputPath: 'route.status.status',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteRoute.route.status.status', props);
    return resource.getResponseField('route.status.status') as unknown as string;
  }

}

export class AppMeshResponsesDeleteVirtualGateway {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualGatewayInput) {
  }

  public get virtualGateway(): AppMeshResponsesDeleteVirtualGatewayVirtualGateway {
    return new AppMeshResponsesDeleteVirtualGatewayVirtualGateway(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteVirtualGatewayVirtualGateway {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualGatewayInput) {
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.meshName'),
        outputPath: 'virtualGateway.meshName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualGateway.virtualGateway.meshName', props);
    return resource.getResponseField('virtualGateway.meshName') as unknown as string;
  }

  public get metadata(): AppMeshResponsesDeleteVirtualGatewayVirtualGatewayMetadata {
    return new AppMeshResponsesDeleteVirtualGatewayVirtualGatewayMetadata(this.__scope, this.__resources, this.__input);
  }

  public get spec(): AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpec {
    return new AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpec(this.__scope, this.__resources, this.__input);
  }

  public get status(): AppMeshResponsesDeleteVirtualGatewayVirtualGatewayStatus {
    return new AppMeshResponsesDeleteVirtualGatewayVirtualGatewayStatus(this.__scope, this.__resources, this.__input);
  }

  public get virtualGatewayName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.virtualGatewayName'),
        outputPath: 'virtualGateway.virtualGatewayName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualGateway.virtualGateway.virtualGatewayName', props);
    return resource.getResponseField('virtualGateway.virtualGatewayName') as unknown as string;
  }

}

export class AppMeshResponsesDeleteVirtualGatewayVirtualGatewayMetadata {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualGatewayInput) {
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.metadata.arn'),
        outputPath: 'virtualGateway.metadata.arn',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualGateway.virtualGateway.metadata.arn', props);
    return resource.getResponseField('virtualGateway.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.metadata.createdAt'),
        outputPath: 'virtualGateway.metadata.createdAt',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualGateway.virtualGateway.metadata.createdAt', props);
    return resource.getResponseField('virtualGateway.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.metadata.lastUpdatedAt'),
        outputPath: 'virtualGateway.metadata.lastUpdatedAt',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualGateway.virtualGateway.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualGateway.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.metadata.meshOwner'),
        outputPath: 'virtualGateway.metadata.meshOwner',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualGateway.virtualGateway.metadata.meshOwner', props);
    return resource.getResponseField('virtualGateway.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.metadata.resourceOwner'),
        outputPath: 'virtualGateway.metadata.resourceOwner',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualGateway.virtualGateway.metadata.resourceOwner', props);
    return resource.getResponseField('virtualGateway.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.metadata.uid'),
        outputPath: 'virtualGateway.metadata.uid',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualGateway.virtualGateway.metadata.uid', props);
    return resource.getResponseField('virtualGateway.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.metadata.version'),
        outputPath: 'virtualGateway.metadata.version',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualGateway.virtualGateway.metadata.version', props);
    return resource.getResponseField('virtualGateway.metadata.version') as unknown as number;
  }

}

export class AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpec {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualGatewayInput) {
  }

  public get backendDefaults(): AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpecBackendDefaults {
    return new AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpecBackendDefaults(this.__scope, this.__resources, this.__input);
  }

  public get listeners(): shapes.AppMeshVirtualGatewayListener[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.spec.listeners'),
        outputPath: 'virtualGateway.spec.listeners',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualGateway.virtualGateway.spec.listeners', props);
    return resource.getResponseField('virtualGateway.spec.listeners') as unknown as shapes.AppMeshVirtualGatewayListener[];
  }

  public get logging(): AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpecLogging {
    return new AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpecLogging(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpecBackendDefaults {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualGatewayInput) {
  }

  public get clientPolicy(): AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicy {
    return new AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicy(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicy {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualGatewayInput) {
  }

  public get tls(): AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTls {
    return new AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTls(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTls {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualGatewayInput) {
  }

  public get enforce(): boolean {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce') as unknown as boolean;
  }

  public get ports(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.ports'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.ports',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.ports', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.ports') as unknown as number[];
  }

  public get validation(): AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation {
    return new AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualGatewayInput) {
  }

  public get trust(): AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust {
    return new AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualGatewayInput) {
  }

  public get acm(): AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
    return new AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm(this.__scope, this.__resources, this.__input);
  }

  public get file(): AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile {
    return new AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualGatewayInput) {
  }

  public get certificateAuthorityArns(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns') as unknown as string[];
  }

}

export class AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualGatewayInput) {
  }

  public get certificateChain(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain') as unknown as string;
  }

}

export class AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpecLogging {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualGatewayInput) {
  }

  public get accessLog(): AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpecLoggingAccessLog {
    return new AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpecLoggingAccessLog(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpecLoggingAccessLog {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualGatewayInput) {
  }

  public get file(): AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpecLoggingAccessLogFile {
    return new AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpecLoggingAccessLogFile(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteVirtualGatewayVirtualGatewaySpecLoggingAccessLogFile {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualGatewayInput) {
  }

  public get path(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.spec.logging.accessLog.file.path'),
        outputPath: 'virtualGateway.spec.logging.accessLog.file.path',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualGateway.virtualGateway.spec.logging.accessLog.file.path', props);
    return resource.getResponseField('virtualGateway.spec.logging.accessLog.file.path') as unknown as string;
  }

}

export class AppMeshResponsesDeleteVirtualGatewayVirtualGatewayStatus {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualGatewayInput) {
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualGateway.virtualGateway.status.status'),
        outputPath: 'virtualGateway.status.status',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualGateway.virtualGateway.status.status', props);
    return resource.getResponseField('virtualGateway.status.status') as unknown as string;
  }

}

export class AppMeshResponsesDeleteVirtualNode {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualNodeInput) {
  }

  public get virtualNode(): AppMeshResponsesDeleteVirtualNodeVirtualNode {
    return new AppMeshResponsesDeleteVirtualNodeVirtualNode(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteVirtualNodeVirtualNode {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualNodeInput) {
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.meshName'),
        outputPath: 'virtualNode.meshName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualNode.virtualNode.meshName', props);
    return resource.getResponseField('virtualNode.meshName') as unknown as string;
  }

  public get metadata(): AppMeshResponsesDeleteVirtualNodeVirtualNodeMetadata {
    return new AppMeshResponsesDeleteVirtualNodeVirtualNodeMetadata(this.__scope, this.__resources, this.__input);
  }

  public get spec(): AppMeshResponsesDeleteVirtualNodeVirtualNodeSpec {
    return new AppMeshResponsesDeleteVirtualNodeVirtualNodeSpec(this.__scope, this.__resources, this.__input);
  }

  public get status(): AppMeshResponsesDeleteVirtualNodeVirtualNodeStatus {
    return new AppMeshResponsesDeleteVirtualNodeVirtualNodeStatus(this.__scope, this.__resources, this.__input);
  }

  public get virtualNodeName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.virtualNodeName'),
        outputPath: 'virtualNode.virtualNodeName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualNode.virtualNode.virtualNodeName', props);
    return resource.getResponseField('virtualNode.virtualNodeName') as unknown as string;
  }

}

export class AppMeshResponsesDeleteVirtualNodeVirtualNodeMetadata {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualNodeInput) {
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.metadata.arn'),
        outputPath: 'virtualNode.metadata.arn',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualNode.virtualNode.metadata.arn', props);
    return resource.getResponseField('virtualNode.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.metadata.createdAt'),
        outputPath: 'virtualNode.metadata.createdAt',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualNode.virtualNode.metadata.createdAt', props);
    return resource.getResponseField('virtualNode.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.metadata.lastUpdatedAt'),
        outputPath: 'virtualNode.metadata.lastUpdatedAt',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualNode.virtualNode.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualNode.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.metadata.meshOwner'),
        outputPath: 'virtualNode.metadata.meshOwner',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualNode.virtualNode.metadata.meshOwner', props);
    return resource.getResponseField('virtualNode.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.metadata.resourceOwner'),
        outputPath: 'virtualNode.metadata.resourceOwner',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualNode.virtualNode.metadata.resourceOwner', props);
    return resource.getResponseField('virtualNode.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.metadata.uid'),
        outputPath: 'virtualNode.metadata.uid',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualNode.virtualNode.metadata.uid', props);
    return resource.getResponseField('virtualNode.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.metadata.version'),
        outputPath: 'virtualNode.metadata.version',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualNode.virtualNode.metadata.version', props);
    return resource.getResponseField('virtualNode.metadata.version') as unknown as number;
  }

}

export class AppMeshResponsesDeleteVirtualNodeVirtualNodeSpec {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualNodeInput) {
  }

  public get backendDefaults(): AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecBackendDefaults {
    return new AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecBackendDefaults(this.__scope, this.__resources, this.__input);
  }

  public get backends(): shapes.AppMeshBackend[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.spec.backends'),
        outputPath: 'virtualNode.spec.backends',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualNode.virtualNode.spec.backends', props);
    return resource.getResponseField('virtualNode.spec.backends') as unknown as shapes.AppMeshBackend[];
  }

  public get listeners(): shapes.AppMeshListener[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.spec.listeners'),
        outputPath: 'virtualNode.spec.listeners',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualNode.virtualNode.spec.listeners', props);
    return resource.getResponseField('virtualNode.spec.listeners') as unknown as shapes.AppMeshListener[];
  }

  public get logging(): AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecLogging {
    return new AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecLogging(this.__scope, this.__resources, this.__input);
  }

  public get serviceDiscovery(): AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecServiceDiscovery {
    return new AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecServiceDiscovery(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecBackendDefaults {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualNodeInput) {
  }

  public get clientPolicy(): AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicy {
    return new AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicy(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicy {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualNodeInput) {
  }

  public get tls(): AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTls {
    return new AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTls(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTls {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualNodeInput) {
  }

  public get enforce(): boolean {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.enforce'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.enforce',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.enforce', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.enforce') as unknown as boolean;
  }

  public get ports(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.ports'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.ports',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.ports', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.ports') as unknown as number[];
  }

  public get validation(): AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidation {
    return new AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidation(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidation {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualNodeInput) {
  }

  public get trust(): AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust {
    return new AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualNodeInput) {
  }

  public get acm(): AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
    return new AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm(this.__scope, this.__resources, this.__input);
  }

  public get file(): AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile {
    return new AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualNodeInput) {
  }

  public get certificateAuthorityArns(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns') as unknown as string[];
  }

}

export class AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualNodeInput) {
  }

  public get certificateChain(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain') as unknown as string;
  }

}

export class AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecLogging {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualNodeInput) {
  }

  public get accessLog(): AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecLoggingAccessLog {
    return new AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecLoggingAccessLog(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecLoggingAccessLog {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualNodeInput) {
  }

  public get file(): AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecLoggingAccessLogFile {
    return new AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecLoggingAccessLogFile(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecLoggingAccessLogFile {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualNodeInput) {
  }

  public get path(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.spec.logging.accessLog.file.path'),
        outputPath: 'virtualNode.spec.logging.accessLog.file.path',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualNode.virtualNode.spec.logging.accessLog.file.path', props);
    return resource.getResponseField('virtualNode.spec.logging.accessLog.file.path') as unknown as string;
  }

}

export class AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecServiceDiscovery {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualNodeInput) {
  }

  public get awsCloudMap(): AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecServiceDiscoveryAwsCloudMap {
    return new AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecServiceDiscoveryAwsCloudMap(this.__scope, this.__resources, this.__input);
  }

  public get dns(): AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecServiceDiscoveryDns {
    return new AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecServiceDiscoveryDns(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecServiceDiscoveryAwsCloudMap {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualNodeInput) {
  }

  public get attributes(): shapes.AppMeshAwsCloudMapInstanceAttribute[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.attributes'),
        outputPath: 'virtualNode.spec.serviceDiscovery.awsCloudMap.attributes',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.attributes', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.awsCloudMap.attributes') as unknown as shapes.AppMeshAwsCloudMapInstanceAttribute[];
  }

  public get namespaceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName'),
        outputPath: 'virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName') as unknown as string;
  }

  public get serviceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName'),
        outputPath: 'virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName') as unknown as string;
  }

}

export class AppMeshResponsesDeleteVirtualNodeVirtualNodeSpecServiceDiscoveryDns {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualNodeInput) {
  }

  public get hostname(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.spec.serviceDiscovery.dns.hostname'),
        outputPath: 'virtualNode.spec.serviceDiscovery.dns.hostname',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualNode.virtualNode.spec.serviceDiscovery.dns.hostname', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.dns.hostname') as unknown as string;
  }

}

export class AppMeshResponsesDeleteVirtualNodeVirtualNodeStatus {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualNodeInput) {
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualNode.virtualNode.status.status'),
        outputPath: 'virtualNode.status.status',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualNode.virtualNode.status.status', props);
    return resource.getResponseField('virtualNode.status.status') as unknown as string;
  }

}

export class AppMeshResponsesDeleteVirtualRouter {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualRouterInput) {
  }

  public get virtualRouter(): AppMeshResponsesDeleteVirtualRouterVirtualRouter {
    return new AppMeshResponsesDeleteVirtualRouterVirtualRouter(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteVirtualRouterVirtualRouter {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualRouterInput) {
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualRouter.virtualRouter.meshName'),
        outputPath: 'virtualRouter.meshName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualRouter.virtualRouter.meshName', props);
    return resource.getResponseField('virtualRouter.meshName') as unknown as string;
  }

  public get metadata(): AppMeshResponsesDeleteVirtualRouterVirtualRouterMetadata {
    return new AppMeshResponsesDeleteVirtualRouterVirtualRouterMetadata(this.__scope, this.__resources, this.__input);
  }

  public get spec(): AppMeshResponsesDeleteVirtualRouterVirtualRouterSpec {
    return new AppMeshResponsesDeleteVirtualRouterVirtualRouterSpec(this.__scope, this.__resources, this.__input);
  }

  public get status(): AppMeshResponsesDeleteVirtualRouterVirtualRouterStatus {
    return new AppMeshResponsesDeleteVirtualRouterVirtualRouterStatus(this.__scope, this.__resources, this.__input);
  }

  public get virtualRouterName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualRouter.virtualRouter.virtualRouterName'),
        outputPath: 'virtualRouter.virtualRouterName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualRouter.virtualRouter.virtualRouterName', props);
    return resource.getResponseField('virtualRouter.virtualRouterName') as unknown as string;
  }

}

export class AppMeshResponsesDeleteVirtualRouterVirtualRouterMetadata {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualRouterInput) {
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualRouter.virtualRouter.metadata.arn'),
        outputPath: 'virtualRouter.metadata.arn',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualRouter.virtualRouter.metadata.arn', props);
    return resource.getResponseField('virtualRouter.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualRouter.virtualRouter.metadata.createdAt'),
        outputPath: 'virtualRouter.metadata.createdAt',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualRouter.virtualRouter.metadata.createdAt', props);
    return resource.getResponseField('virtualRouter.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualRouter.virtualRouter.metadata.lastUpdatedAt'),
        outputPath: 'virtualRouter.metadata.lastUpdatedAt',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualRouter.virtualRouter.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualRouter.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualRouter.virtualRouter.metadata.meshOwner'),
        outputPath: 'virtualRouter.metadata.meshOwner',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualRouter.virtualRouter.metadata.meshOwner', props);
    return resource.getResponseField('virtualRouter.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualRouter.virtualRouter.metadata.resourceOwner'),
        outputPath: 'virtualRouter.metadata.resourceOwner',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualRouter.virtualRouter.metadata.resourceOwner', props);
    return resource.getResponseField('virtualRouter.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualRouter.virtualRouter.metadata.uid'),
        outputPath: 'virtualRouter.metadata.uid',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualRouter.virtualRouter.metadata.uid', props);
    return resource.getResponseField('virtualRouter.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualRouter.virtualRouter.metadata.version'),
        outputPath: 'virtualRouter.metadata.version',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualRouter.virtualRouter.metadata.version', props);
    return resource.getResponseField('virtualRouter.metadata.version') as unknown as number;
  }

}

export class AppMeshResponsesDeleteVirtualRouterVirtualRouterSpec {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualRouterInput) {
  }

  public get listeners(): shapes.AppMeshVirtualRouterListener[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualRouter.virtualRouter.spec.listeners'),
        outputPath: 'virtualRouter.spec.listeners',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualRouter.virtualRouter.spec.listeners', props);
    return resource.getResponseField('virtualRouter.spec.listeners') as unknown as shapes.AppMeshVirtualRouterListener[];
  }

}

export class AppMeshResponsesDeleteVirtualRouterVirtualRouterStatus {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualRouterInput) {
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualRouter.virtualRouter.status.status'),
        outputPath: 'virtualRouter.status.status',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualRouter.virtualRouter.status.status', props);
    return resource.getResponseField('virtualRouter.status.status') as unknown as string;
  }

}

export class AppMeshResponsesDeleteVirtualService {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualServiceInput) {
  }

  public get virtualService(): AppMeshResponsesDeleteVirtualServiceVirtualService {
    return new AppMeshResponsesDeleteVirtualServiceVirtualService(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteVirtualServiceVirtualService {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualServiceInput) {
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualService.virtualService.meshName'),
        outputPath: 'virtualService.meshName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualService.virtualService.meshName', props);
    return resource.getResponseField('virtualService.meshName') as unknown as string;
  }

  public get metadata(): AppMeshResponsesDeleteVirtualServiceVirtualServiceMetadata {
    return new AppMeshResponsesDeleteVirtualServiceVirtualServiceMetadata(this.__scope, this.__resources, this.__input);
  }

  public get spec(): AppMeshResponsesDeleteVirtualServiceVirtualServiceSpec {
    return new AppMeshResponsesDeleteVirtualServiceVirtualServiceSpec(this.__scope, this.__resources, this.__input);
  }

  public get status(): AppMeshResponsesDeleteVirtualServiceVirtualServiceStatus {
    return new AppMeshResponsesDeleteVirtualServiceVirtualServiceStatus(this.__scope, this.__resources, this.__input);
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualService.virtualService.virtualServiceName'),
        outputPath: 'virtualService.virtualServiceName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualService.virtualService.virtualServiceName', props);
    return resource.getResponseField('virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshResponsesDeleteVirtualServiceVirtualServiceMetadata {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualServiceInput) {
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualService.virtualService.metadata.arn'),
        outputPath: 'virtualService.metadata.arn',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualService.virtualService.metadata.arn', props);
    return resource.getResponseField('virtualService.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualService.virtualService.metadata.createdAt'),
        outputPath: 'virtualService.metadata.createdAt',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualService.virtualService.metadata.createdAt', props);
    return resource.getResponseField('virtualService.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualService.virtualService.metadata.lastUpdatedAt'),
        outputPath: 'virtualService.metadata.lastUpdatedAt',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualService.virtualService.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualService.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualService.virtualService.metadata.meshOwner'),
        outputPath: 'virtualService.metadata.meshOwner',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualService.virtualService.metadata.meshOwner', props);
    return resource.getResponseField('virtualService.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualService.virtualService.metadata.resourceOwner'),
        outputPath: 'virtualService.metadata.resourceOwner',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualService.virtualService.metadata.resourceOwner', props);
    return resource.getResponseField('virtualService.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualService.virtualService.metadata.uid'),
        outputPath: 'virtualService.metadata.uid',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualService.virtualService.metadata.uid', props);
    return resource.getResponseField('virtualService.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualService.virtualService.metadata.version'),
        outputPath: 'virtualService.metadata.version',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualService.virtualService.metadata.version', props);
    return resource.getResponseField('virtualService.metadata.version') as unknown as number;
  }

}

export class AppMeshResponsesDeleteVirtualServiceVirtualServiceSpec {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualServiceInput) {
  }

  public get provider(): AppMeshResponsesDeleteVirtualServiceVirtualServiceSpecProvider {
    return new AppMeshResponsesDeleteVirtualServiceVirtualServiceSpecProvider(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteVirtualServiceVirtualServiceSpecProvider {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualServiceInput) {
  }

  public get virtualNode(): AppMeshResponsesDeleteVirtualServiceVirtualServiceSpecProviderVirtualNode {
    return new AppMeshResponsesDeleteVirtualServiceVirtualServiceSpecProviderVirtualNode(this.__scope, this.__resources, this.__input);
  }

  public get virtualRouter(): AppMeshResponsesDeleteVirtualServiceVirtualServiceSpecProviderVirtualRouter {
    return new AppMeshResponsesDeleteVirtualServiceVirtualServiceSpecProviderVirtualRouter(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDeleteVirtualServiceVirtualServiceSpecProviderVirtualNode {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualServiceInput) {
  }

  public get virtualNodeName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualService.virtualService.spec.provider.virtualNode.virtualNodeName'),
        outputPath: 'virtualService.spec.provider.virtualNode.virtualNodeName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualService.virtualService.spec.provider.virtualNode.virtualNodeName', props);
    return resource.getResponseField('virtualService.spec.provider.virtualNode.virtualNodeName') as unknown as string;
  }

}

export class AppMeshResponsesDeleteVirtualServiceVirtualServiceSpecProviderVirtualRouter {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualServiceInput) {
  }

  public get virtualRouterName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualService.virtualService.spec.provider.virtualRouter.virtualRouterName'),
        outputPath: 'virtualService.spec.provider.virtualRouter.virtualRouterName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualService.virtualService.spec.provider.virtualRouter.virtualRouterName', props);
    return resource.getResponseField('virtualService.spec.provider.virtualRouter.virtualRouterName') as unknown as string;
  }

}

export class AppMeshResponsesDeleteVirtualServiceVirtualServiceStatus {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDeleteVirtualServiceInput) {
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DeleteVirtualService.virtualService.status.status'),
        outputPath: 'virtualService.status.status',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DeleteVirtualService.virtualService.status.status', props);
    return resource.getResponseField('virtualService.status.status') as unknown as string;
  }

}

export class AppMeshResponsesDescribeGatewayRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeGatewayRouteInput) {
  }

  public get gatewayRoute(): AppMeshResponsesDescribeGatewayRouteGatewayRoute {
    return new AppMeshResponsesDescribeGatewayRouteGatewayRoute(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeGatewayRouteGatewayRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeGatewayRouteInput) {
  }

  public get gatewayRouteName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.gatewayRouteName'),
        outputPath: 'gatewayRoute.gatewayRouteName',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeGatewayRoute.gatewayRoute.gatewayRouteName', props);
    return resource.getResponseField('gatewayRoute.gatewayRouteName') as unknown as string;
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.meshName'),
        outputPath: 'gatewayRoute.meshName',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeGatewayRoute.gatewayRoute.meshName', props);
    return resource.getResponseField('gatewayRoute.meshName') as unknown as string;
  }

  public get metadata(): AppMeshResponsesDescribeGatewayRouteGatewayRouteMetadata {
    return new AppMeshResponsesDescribeGatewayRouteGatewayRouteMetadata(this.__scope, this.__resources, this.__input);
  }

  public get spec(): AppMeshResponsesDescribeGatewayRouteGatewayRouteSpec {
    return new AppMeshResponsesDescribeGatewayRouteGatewayRouteSpec(this.__scope, this.__resources, this.__input);
  }

  public get status(): AppMeshResponsesDescribeGatewayRouteGatewayRouteStatus {
    return new AppMeshResponsesDescribeGatewayRouteGatewayRouteStatus(this.__scope, this.__resources, this.__input);
  }

  public get virtualGatewayName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.virtualGatewayName'),
        outputPath: 'gatewayRoute.virtualGatewayName',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeGatewayRoute.gatewayRoute.virtualGatewayName', props);
    return resource.getResponseField('gatewayRoute.virtualGatewayName') as unknown as string;
  }

}

export class AppMeshResponsesDescribeGatewayRouteGatewayRouteMetadata {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeGatewayRouteInput) {
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.metadata.arn'),
        outputPath: 'gatewayRoute.metadata.arn',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeGatewayRoute.gatewayRoute.metadata.arn', props);
    return resource.getResponseField('gatewayRoute.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.metadata.createdAt'),
        outputPath: 'gatewayRoute.metadata.createdAt',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeGatewayRoute.gatewayRoute.metadata.createdAt', props);
    return resource.getResponseField('gatewayRoute.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.metadata.lastUpdatedAt'),
        outputPath: 'gatewayRoute.metadata.lastUpdatedAt',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeGatewayRoute.gatewayRoute.metadata.lastUpdatedAt', props);
    return resource.getResponseField('gatewayRoute.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.metadata.meshOwner'),
        outputPath: 'gatewayRoute.metadata.meshOwner',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeGatewayRoute.gatewayRoute.metadata.meshOwner', props);
    return resource.getResponseField('gatewayRoute.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.metadata.resourceOwner'),
        outputPath: 'gatewayRoute.metadata.resourceOwner',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeGatewayRoute.gatewayRoute.metadata.resourceOwner', props);
    return resource.getResponseField('gatewayRoute.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.metadata.uid'),
        outputPath: 'gatewayRoute.metadata.uid',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeGatewayRoute.gatewayRoute.metadata.uid', props);
    return resource.getResponseField('gatewayRoute.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.metadata.version'),
        outputPath: 'gatewayRoute.metadata.version',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeGatewayRoute.gatewayRoute.metadata.version', props);
    return resource.getResponseField('gatewayRoute.metadata.version') as unknown as number;
  }

}

export class AppMeshResponsesDescribeGatewayRouteGatewayRouteSpec {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeGatewayRouteInput) {
  }

  public get grpcRoute(): AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecGrpcRoute {
    return new AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecGrpcRoute(this.__scope, this.__resources, this.__input);
  }

  public get http2Route(): AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecHttp2Route {
    return new AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecHttp2Route(this.__scope, this.__resources, this.__input);
  }

  public get httpRoute(): AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecHttpRoute {
    return new AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecHttpRoute(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecGrpcRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeGatewayRouteInput) {
  }

  public get action(): AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecGrpcRouteAction {
    return new AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecGrpcRouteAction(this.__scope, this.__resources, this.__input);
  }

  public get match(): AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecGrpcRouteMatch {
    return new AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecGrpcRouteMatch(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecGrpcRouteAction {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeGatewayRouteInput) {
  }

  public get target(): AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecGrpcRouteActionTarget {
    return new AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecGrpcRouteActionTarget(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecGrpcRouteActionTarget {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeGatewayRouteInput) {
  }

  public get virtualService(): AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecGrpcRouteActionTargetVirtualService {
    return new AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecGrpcRouteActionTargetVirtualService(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecGrpcRouteActionTargetVirtualService {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeGatewayRouteInput) {
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName'),
        outputPath: 'gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeGatewayRoute.gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName', props);
    return resource.getResponseField('gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecGrpcRouteMatch {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeGatewayRouteInput) {
  }

  public get serviceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.spec.grpcRoute.match.serviceName'),
        outputPath: 'gatewayRoute.spec.grpcRoute.match.serviceName',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeGatewayRoute.gatewayRoute.spec.grpcRoute.match.serviceName', props);
    return resource.getResponseField('gatewayRoute.spec.grpcRoute.match.serviceName') as unknown as string;
  }

}

export class AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecHttp2Route {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeGatewayRouteInput) {
  }

  public get action(): AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecHttp2RouteAction {
    return new AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecHttp2RouteAction(this.__scope, this.__resources, this.__input);
  }

  public get match(): AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecHttp2RouteMatch {
    return new AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecHttp2RouteMatch(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecHttp2RouteAction {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeGatewayRouteInput) {
  }

  public get target(): AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecHttp2RouteActionTarget {
    return new AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecHttp2RouteActionTarget(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecHttp2RouteActionTarget {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeGatewayRouteInput) {
  }

  public get virtualService(): AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecHttp2RouteActionTargetVirtualService {
    return new AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecHttp2RouteActionTargetVirtualService(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecHttp2RouteActionTargetVirtualService {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeGatewayRouteInput) {
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName'),
        outputPath: 'gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeGatewayRoute.gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName', props);
    return resource.getResponseField('gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecHttp2RouteMatch {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeGatewayRouteInput) {
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.spec.http2Route.match.prefix'),
        outputPath: 'gatewayRoute.spec.http2Route.match.prefix',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeGatewayRoute.gatewayRoute.spec.http2Route.match.prefix', props);
    return resource.getResponseField('gatewayRoute.spec.http2Route.match.prefix') as unknown as string;
  }

}

export class AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecHttpRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeGatewayRouteInput) {
  }

  public get action(): AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecHttpRouteAction {
    return new AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecHttpRouteAction(this.__scope, this.__resources, this.__input);
  }

  public get match(): AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecHttpRouteMatch {
    return new AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecHttpRouteMatch(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecHttpRouteAction {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeGatewayRouteInput) {
  }

  public get target(): AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecHttpRouteActionTarget {
    return new AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecHttpRouteActionTarget(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecHttpRouteActionTarget {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeGatewayRouteInput) {
  }

  public get virtualService(): AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecHttpRouteActionTargetVirtualService {
    return new AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecHttpRouteActionTargetVirtualService(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecHttpRouteActionTargetVirtualService {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeGatewayRouteInput) {
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName'),
        outputPath: 'gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeGatewayRoute.gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName', props);
    return resource.getResponseField('gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshResponsesDescribeGatewayRouteGatewayRouteSpecHttpRouteMatch {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeGatewayRouteInput) {
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.spec.httpRoute.match.prefix'),
        outputPath: 'gatewayRoute.spec.httpRoute.match.prefix',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeGatewayRoute.gatewayRoute.spec.httpRoute.match.prefix', props);
    return resource.getResponseField('gatewayRoute.spec.httpRoute.match.prefix') as unknown as string;
  }

}

export class AppMeshResponsesDescribeGatewayRouteGatewayRouteStatus {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeGatewayRouteInput) {
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeGatewayRoute.gatewayRoute.status.status'),
        outputPath: 'gatewayRoute.status.status',
        parameters: {
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeGatewayRoute.gatewayRoute.status.status', props);
    return resource.getResponseField('gatewayRoute.status.status') as unknown as string;
  }

}

export class AppMeshResponsesDescribeMesh {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeMeshInput) {
  }

  public get mesh(): AppMeshResponsesDescribeMeshMesh {
    return new AppMeshResponsesDescribeMeshMesh(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeMeshMesh {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeMeshInput) {
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeMesh.mesh.meshName'),
        outputPath: 'mesh.meshName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeMesh.mesh.meshName', props);
    return resource.getResponseField('mesh.meshName') as unknown as string;
  }

  public get metadata(): AppMeshResponsesDescribeMeshMeshMetadata {
    return new AppMeshResponsesDescribeMeshMeshMetadata(this.__scope, this.__resources, this.__input);
  }

  public get spec(): AppMeshResponsesDescribeMeshMeshSpec {
    return new AppMeshResponsesDescribeMeshMeshSpec(this.__scope, this.__resources, this.__input);
  }

  public get status(): AppMeshResponsesDescribeMeshMeshStatus {
    return new AppMeshResponsesDescribeMeshMeshStatus(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeMeshMeshMetadata {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeMeshInput) {
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeMesh.mesh.metadata.arn'),
        outputPath: 'mesh.metadata.arn',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeMesh.mesh.metadata.arn', props);
    return resource.getResponseField('mesh.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeMesh.mesh.metadata.createdAt'),
        outputPath: 'mesh.metadata.createdAt',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeMesh.mesh.metadata.createdAt', props);
    return resource.getResponseField('mesh.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeMesh.mesh.metadata.lastUpdatedAt'),
        outputPath: 'mesh.metadata.lastUpdatedAt',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeMesh.mesh.metadata.lastUpdatedAt', props);
    return resource.getResponseField('mesh.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeMesh.mesh.metadata.meshOwner'),
        outputPath: 'mesh.metadata.meshOwner',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeMesh.mesh.metadata.meshOwner', props);
    return resource.getResponseField('mesh.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeMesh.mesh.metadata.resourceOwner'),
        outputPath: 'mesh.metadata.resourceOwner',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeMesh.mesh.metadata.resourceOwner', props);
    return resource.getResponseField('mesh.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeMesh.mesh.metadata.uid'),
        outputPath: 'mesh.metadata.uid',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeMesh.mesh.metadata.uid', props);
    return resource.getResponseField('mesh.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeMesh.mesh.metadata.version'),
        outputPath: 'mesh.metadata.version',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeMesh.mesh.metadata.version', props);
    return resource.getResponseField('mesh.metadata.version') as unknown as number;
  }

}

export class AppMeshResponsesDescribeMeshMeshSpec {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeMeshInput) {
  }

  public get egressFilter(): AppMeshResponsesDescribeMeshMeshSpecEgressFilter {
    return new AppMeshResponsesDescribeMeshMeshSpecEgressFilter(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeMeshMeshSpecEgressFilter {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeMeshInput) {
  }

  public get type(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeMesh.mesh.spec.egressFilter.type'),
        outputPath: 'mesh.spec.egressFilter.type',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeMesh.mesh.spec.egressFilter.type', props);
    return resource.getResponseField('mesh.spec.egressFilter.type') as unknown as string;
  }

}

export class AppMeshResponsesDescribeMeshMeshStatus {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeMeshInput) {
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeMesh.mesh.status.status'),
        outputPath: 'mesh.status.status',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeMesh.mesh.status.status', props);
    return resource.getResponseField('mesh.status.status') as unknown as string;
  }

}

export class AppMeshResponsesDescribeRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get route(): AppMeshResponsesDescribeRouteRoute {
    return new AppMeshResponsesDescribeRouteRoute(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeRouteRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.meshName'),
        outputPath: 'route.meshName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.meshName', props);
    return resource.getResponseField('route.meshName') as unknown as string;
  }

  public get metadata(): AppMeshResponsesDescribeRouteRouteMetadata {
    return new AppMeshResponsesDescribeRouteRouteMetadata(this.__scope, this.__resources, this.__input);
  }

  public get routeName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.routeName'),
        outputPath: 'route.routeName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.routeName', props);
    return resource.getResponseField('route.routeName') as unknown as string;
  }

  public get spec(): AppMeshResponsesDescribeRouteRouteSpec {
    return new AppMeshResponsesDescribeRouteRouteSpec(this.__scope, this.__resources, this.__input);
  }

  public get status(): AppMeshResponsesDescribeRouteRouteStatus {
    return new AppMeshResponsesDescribeRouteRouteStatus(this.__scope, this.__resources, this.__input);
  }

  public get virtualRouterName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.virtualRouterName'),
        outputPath: 'route.virtualRouterName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.virtualRouterName', props);
    return resource.getResponseField('route.virtualRouterName') as unknown as string;
  }

}

export class AppMeshResponsesDescribeRouteRouteMetadata {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.metadata.arn'),
        outputPath: 'route.metadata.arn',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.metadata.arn', props);
    return resource.getResponseField('route.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.metadata.createdAt'),
        outputPath: 'route.metadata.createdAt',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.metadata.createdAt', props);
    return resource.getResponseField('route.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.metadata.lastUpdatedAt'),
        outputPath: 'route.metadata.lastUpdatedAt',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.metadata.lastUpdatedAt', props);
    return resource.getResponseField('route.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.metadata.meshOwner'),
        outputPath: 'route.metadata.meshOwner',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.metadata.meshOwner', props);
    return resource.getResponseField('route.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.metadata.resourceOwner'),
        outputPath: 'route.metadata.resourceOwner',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.metadata.resourceOwner', props);
    return resource.getResponseField('route.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.metadata.uid'),
        outputPath: 'route.metadata.uid',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.metadata.uid', props);
    return resource.getResponseField('route.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.metadata.version'),
        outputPath: 'route.metadata.version',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.metadata.version', props);
    return resource.getResponseField('route.metadata.version') as unknown as number;
  }

}

export class AppMeshResponsesDescribeRouteRouteSpec {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get grpcRoute(): AppMeshResponsesDescribeRouteRouteSpecGrpcRoute {
    return new AppMeshResponsesDescribeRouteRouteSpecGrpcRoute(this.__scope, this.__resources, this.__input);
  }

  public get http2Route(): AppMeshResponsesDescribeRouteRouteSpecHttp2Route {
    return new AppMeshResponsesDescribeRouteRouteSpecHttp2Route(this.__scope, this.__resources, this.__input);
  }

  public get httpRoute(): AppMeshResponsesDescribeRouteRouteSpecHttpRoute {
    return new AppMeshResponsesDescribeRouteRouteSpecHttpRoute(this.__scope, this.__resources, this.__input);
  }

  public get priority(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.priority'),
        outputPath: 'route.spec.priority',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.priority', props);
    return resource.getResponseField('route.spec.priority') as unknown as number;
  }

  public get tcpRoute(): AppMeshResponsesDescribeRouteRouteSpecTcpRoute {
    return new AppMeshResponsesDescribeRouteRouteSpecTcpRoute(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeRouteRouteSpecGrpcRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get action(): AppMeshResponsesDescribeRouteRouteSpecGrpcRouteAction {
    return new AppMeshResponsesDescribeRouteRouteSpecGrpcRouteAction(this.__scope, this.__resources, this.__input);
  }

  public get match(): AppMeshResponsesDescribeRouteRouteSpecGrpcRouteMatch {
    return new AppMeshResponsesDescribeRouteRouteSpecGrpcRouteMatch(this.__scope, this.__resources, this.__input);
  }

  public get retryPolicy(): AppMeshResponsesDescribeRouteRouteSpecGrpcRouteRetryPolicy {
    return new AppMeshResponsesDescribeRouteRouteSpecGrpcRouteRetryPolicy(this.__scope, this.__resources, this.__input);
  }

  public get timeout(): AppMeshResponsesDescribeRouteRouteSpecGrpcRouteTimeout {
    return new AppMeshResponsesDescribeRouteRouteSpecGrpcRouteTimeout(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeRouteRouteSpecGrpcRouteAction {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.grpcRoute.action.weightedTargets'),
        outputPath: 'route.spec.grpcRoute.action.weightedTargets',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.grpcRoute.action.weightedTargets', props);
    return resource.getResponseField('route.spec.grpcRoute.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshResponsesDescribeRouteRouteSpecGrpcRouteMatch {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get metadata(): shapes.AppMeshGrpcRouteMetadata[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.grpcRoute.match.metadata'),
        outputPath: 'route.spec.grpcRoute.match.metadata',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.grpcRoute.match.metadata', props);
    return resource.getResponseField('route.spec.grpcRoute.match.metadata') as unknown as shapes.AppMeshGrpcRouteMetadata[];
  }

  public get methodName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.grpcRoute.match.methodName'),
        outputPath: 'route.spec.grpcRoute.match.methodName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.grpcRoute.match.methodName', props);
    return resource.getResponseField('route.spec.grpcRoute.match.methodName') as unknown as string;
  }

  public get serviceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.grpcRoute.match.serviceName'),
        outputPath: 'route.spec.grpcRoute.match.serviceName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.grpcRoute.match.serviceName', props);
    return resource.getResponseField('route.spec.grpcRoute.match.serviceName') as unknown as string;
  }

}

export class AppMeshResponsesDescribeRouteRouteSpecGrpcRouteRetryPolicy {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get grpcRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.grpcRoute.retryPolicy.grpcRetryEvents'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.grpcRetryEvents',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.grpcRoute.retryPolicy.grpcRetryEvents', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.grpcRetryEvents') as unknown as string[];
  }

  public get httpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.grpcRoute.retryPolicy.httpRetryEvents'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.httpRetryEvents',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.grpcRoute.retryPolicy.httpRetryEvents', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.httpRetryEvents') as unknown as string[];
  }

  public get maxRetries(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.grpcRoute.retryPolicy.maxRetries'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.maxRetries',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.grpcRoute.retryPolicy.maxRetries', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.maxRetries') as unknown as number;
  }

  public get perRetryTimeout(): AppMeshResponsesDescribeRouteRouteSpecGrpcRouteRetryPolicyPerRetryTimeout {
    return new AppMeshResponsesDescribeRouteRouteSpecGrpcRouteRetryPolicyPerRetryTimeout(this.__scope, this.__resources, this.__input);
  }

  public get tcpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.grpcRoute.retryPolicy.tcpRetryEvents'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.tcpRetryEvents',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.grpcRoute.retryPolicy.tcpRetryEvents', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.tcpRetryEvents') as unknown as string[];
  }

}

export class AppMeshResponsesDescribeRouteRouteSpecGrpcRouteRetryPolicyPerRetryTimeout {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.value'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.perRetryTimeout.value',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.value', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.perRetryTimeout.value') as unknown as number;
  }

}

export class AppMeshResponsesDescribeRouteRouteSpecGrpcRouteTimeout {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get idle(): AppMeshResponsesDescribeRouteRouteSpecGrpcRouteTimeoutIdle {
    return new AppMeshResponsesDescribeRouteRouteSpecGrpcRouteTimeoutIdle(this.__scope, this.__resources, this.__input);
  }

  public get perRequest(): AppMeshResponsesDescribeRouteRouteSpecGrpcRouteTimeoutPerRequest {
    return new AppMeshResponsesDescribeRouteRouteSpecGrpcRouteTimeoutPerRequest(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeRouteRouteSpecGrpcRouteTimeoutIdle {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.grpcRoute.timeout.idle.unit'),
        outputPath: 'route.spec.grpcRoute.timeout.idle.unit',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.grpcRoute.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.grpcRoute.timeout.idle.value'),
        outputPath: 'route.spec.grpcRoute.timeout.idle.value',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.grpcRoute.timeout.idle.value', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshResponsesDescribeRouteRouteSpecGrpcRouteTimeoutPerRequest {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.grpcRoute.timeout.perRequest.unit'),
        outputPath: 'route.spec.grpcRoute.timeout.perRequest.unit',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.grpcRoute.timeout.perRequest.unit', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.perRequest.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.grpcRoute.timeout.perRequest.value'),
        outputPath: 'route.spec.grpcRoute.timeout.perRequest.value',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.grpcRoute.timeout.perRequest.value', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.perRequest.value') as unknown as number;
  }

}

export class AppMeshResponsesDescribeRouteRouteSpecHttp2Route {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get action(): AppMeshResponsesDescribeRouteRouteSpecHttp2RouteAction {
    return new AppMeshResponsesDescribeRouteRouteSpecHttp2RouteAction(this.__scope, this.__resources, this.__input);
  }

  public get match(): AppMeshResponsesDescribeRouteRouteSpecHttp2RouteMatch {
    return new AppMeshResponsesDescribeRouteRouteSpecHttp2RouteMatch(this.__scope, this.__resources, this.__input);
  }

  public get retryPolicy(): AppMeshResponsesDescribeRouteRouteSpecHttp2RouteRetryPolicy {
    return new AppMeshResponsesDescribeRouteRouteSpecHttp2RouteRetryPolicy(this.__scope, this.__resources, this.__input);
  }

  public get timeout(): AppMeshResponsesDescribeRouteRouteSpecHttp2RouteTimeout {
    return new AppMeshResponsesDescribeRouteRouteSpecHttp2RouteTimeout(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeRouteRouteSpecHttp2RouteAction {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.http2Route.action.weightedTargets'),
        outputPath: 'route.spec.http2Route.action.weightedTargets',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.http2Route.action.weightedTargets', props);
    return resource.getResponseField('route.spec.http2Route.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshResponsesDescribeRouteRouteSpecHttp2RouteMatch {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get headers(): shapes.AppMeshHttpRouteHeader[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.http2Route.match.headers'),
        outputPath: 'route.spec.http2Route.match.headers',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.http2Route.match.headers', props);
    return resource.getResponseField('route.spec.http2Route.match.headers') as unknown as shapes.AppMeshHttpRouteHeader[];
  }

  public get method(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.http2Route.match.method'),
        outputPath: 'route.spec.http2Route.match.method',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.http2Route.match.method', props);
    return resource.getResponseField('route.spec.http2Route.match.method') as unknown as string;
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.http2Route.match.prefix'),
        outputPath: 'route.spec.http2Route.match.prefix',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.http2Route.match.prefix', props);
    return resource.getResponseField('route.spec.http2Route.match.prefix') as unknown as string;
  }

  public get scheme(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.http2Route.match.scheme'),
        outputPath: 'route.spec.http2Route.match.scheme',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.http2Route.match.scheme', props);
    return resource.getResponseField('route.spec.http2Route.match.scheme') as unknown as string;
  }

}

export class AppMeshResponsesDescribeRouteRouteSpecHttp2RouteRetryPolicy {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get httpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.http2Route.retryPolicy.httpRetryEvents'),
        outputPath: 'route.spec.http2Route.retryPolicy.httpRetryEvents',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.http2Route.retryPolicy.httpRetryEvents', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.httpRetryEvents') as unknown as string[];
  }

  public get maxRetries(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.http2Route.retryPolicy.maxRetries'),
        outputPath: 'route.spec.http2Route.retryPolicy.maxRetries',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.http2Route.retryPolicy.maxRetries', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.maxRetries') as unknown as number;
  }

  public get perRetryTimeout(): AppMeshResponsesDescribeRouteRouteSpecHttp2RouteRetryPolicyPerRetryTimeout {
    return new AppMeshResponsesDescribeRouteRouteSpecHttp2RouteRetryPolicyPerRetryTimeout(this.__scope, this.__resources, this.__input);
  }

  public get tcpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.http2Route.retryPolicy.tcpRetryEvents'),
        outputPath: 'route.spec.http2Route.retryPolicy.tcpRetryEvents',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.http2Route.retryPolicy.tcpRetryEvents', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.tcpRetryEvents') as unknown as string[];
  }

}

export class AppMeshResponsesDescribeRouteRouteSpecHttp2RouteRetryPolicyPerRetryTimeout {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.unit'),
        outputPath: 'route.spec.http2Route.retryPolicy.perRetryTimeout.unit',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.unit', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.perRetryTimeout.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.value'),
        outputPath: 'route.spec.http2Route.retryPolicy.perRetryTimeout.value',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.value', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.perRetryTimeout.value') as unknown as number;
  }

}

export class AppMeshResponsesDescribeRouteRouteSpecHttp2RouteTimeout {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get idle(): AppMeshResponsesDescribeRouteRouteSpecHttp2RouteTimeoutIdle {
    return new AppMeshResponsesDescribeRouteRouteSpecHttp2RouteTimeoutIdle(this.__scope, this.__resources, this.__input);
  }

  public get perRequest(): AppMeshResponsesDescribeRouteRouteSpecHttp2RouteTimeoutPerRequest {
    return new AppMeshResponsesDescribeRouteRouteSpecHttp2RouteTimeoutPerRequest(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeRouteRouteSpecHttp2RouteTimeoutIdle {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.http2Route.timeout.idle.unit'),
        outputPath: 'route.spec.http2Route.timeout.idle.unit',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.http2Route.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.http2Route.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.http2Route.timeout.idle.value'),
        outputPath: 'route.spec.http2Route.timeout.idle.value',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.http2Route.timeout.idle.value', props);
    return resource.getResponseField('route.spec.http2Route.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshResponsesDescribeRouteRouteSpecHttp2RouteTimeoutPerRequest {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.http2Route.timeout.perRequest.unit'),
        outputPath: 'route.spec.http2Route.timeout.perRequest.unit',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.http2Route.timeout.perRequest.unit', props);
    return resource.getResponseField('route.spec.http2Route.timeout.perRequest.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.http2Route.timeout.perRequest.value'),
        outputPath: 'route.spec.http2Route.timeout.perRequest.value',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.http2Route.timeout.perRequest.value', props);
    return resource.getResponseField('route.spec.http2Route.timeout.perRequest.value') as unknown as number;
  }

}

export class AppMeshResponsesDescribeRouteRouteSpecHttpRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get action(): AppMeshResponsesDescribeRouteRouteSpecHttpRouteAction {
    return new AppMeshResponsesDescribeRouteRouteSpecHttpRouteAction(this.__scope, this.__resources, this.__input);
  }

  public get match(): AppMeshResponsesDescribeRouteRouteSpecHttpRouteMatch {
    return new AppMeshResponsesDescribeRouteRouteSpecHttpRouteMatch(this.__scope, this.__resources, this.__input);
  }

  public get retryPolicy(): AppMeshResponsesDescribeRouteRouteSpecHttpRouteRetryPolicy {
    return new AppMeshResponsesDescribeRouteRouteSpecHttpRouteRetryPolicy(this.__scope, this.__resources, this.__input);
  }

  public get timeout(): AppMeshResponsesDescribeRouteRouteSpecHttpRouteTimeout {
    return new AppMeshResponsesDescribeRouteRouteSpecHttpRouteTimeout(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeRouteRouteSpecHttpRouteAction {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.httpRoute.action.weightedTargets'),
        outputPath: 'route.spec.httpRoute.action.weightedTargets',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.httpRoute.action.weightedTargets', props);
    return resource.getResponseField('route.spec.httpRoute.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshResponsesDescribeRouteRouteSpecHttpRouteMatch {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get headers(): shapes.AppMeshHttpRouteHeader[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.httpRoute.match.headers'),
        outputPath: 'route.spec.httpRoute.match.headers',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.httpRoute.match.headers', props);
    return resource.getResponseField('route.spec.httpRoute.match.headers') as unknown as shapes.AppMeshHttpRouteHeader[];
  }

  public get method(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.httpRoute.match.method'),
        outputPath: 'route.spec.httpRoute.match.method',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.httpRoute.match.method', props);
    return resource.getResponseField('route.spec.httpRoute.match.method') as unknown as string;
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.httpRoute.match.prefix'),
        outputPath: 'route.spec.httpRoute.match.prefix',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.httpRoute.match.prefix', props);
    return resource.getResponseField('route.spec.httpRoute.match.prefix') as unknown as string;
  }

  public get scheme(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.httpRoute.match.scheme'),
        outputPath: 'route.spec.httpRoute.match.scheme',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.httpRoute.match.scheme', props);
    return resource.getResponseField('route.spec.httpRoute.match.scheme') as unknown as string;
  }

}

export class AppMeshResponsesDescribeRouteRouteSpecHttpRouteRetryPolicy {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get httpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.httpRoute.retryPolicy.httpRetryEvents'),
        outputPath: 'route.spec.httpRoute.retryPolicy.httpRetryEvents',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.httpRoute.retryPolicy.httpRetryEvents', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.httpRetryEvents') as unknown as string[];
  }

  public get maxRetries(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.httpRoute.retryPolicy.maxRetries'),
        outputPath: 'route.spec.httpRoute.retryPolicy.maxRetries',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.httpRoute.retryPolicy.maxRetries', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.maxRetries') as unknown as number;
  }

  public get perRetryTimeout(): AppMeshResponsesDescribeRouteRouteSpecHttpRouteRetryPolicyPerRetryTimeout {
    return new AppMeshResponsesDescribeRouteRouteSpecHttpRouteRetryPolicyPerRetryTimeout(this.__scope, this.__resources, this.__input);
  }

  public get tcpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.httpRoute.retryPolicy.tcpRetryEvents'),
        outputPath: 'route.spec.httpRoute.retryPolicy.tcpRetryEvents',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.httpRoute.retryPolicy.tcpRetryEvents', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.tcpRetryEvents') as unknown as string[];
  }

}

export class AppMeshResponsesDescribeRouteRouteSpecHttpRouteRetryPolicyPerRetryTimeout {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.unit'),
        outputPath: 'route.spec.httpRoute.retryPolicy.perRetryTimeout.unit',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.unit', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.perRetryTimeout.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.value'),
        outputPath: 'route.spec.httpRoute.retryPolicy.perRetryTimeout.value',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.value', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.perRetryTimeout.value') as unknown as number;
  }

}

export class AppMeshResponsesDescribeRouteRouteSpecHttpRouteTimeout {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get idle(): AppMeshResponsesDescribeRouteRouteSpecHttpRouteTimeoutIdle {
    return new AppMeshResponsesDescribeRouteRouteSpecHttpRouteTimeoutIdle(this.__scope, this.__resources, this.__input);
  }

  public get perRequest(): AppMeshResponsesDescribeRouteRouteSpecHttpRouteTimeoutPerRequest {
    return new AppMeshResponsesDescribeRouteRouteSpecHttpRouteTimeoutPerRequest(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeRouteRouteSpecHttpRouteTimeoutIdle {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.httpRoute.timeout.idle.unit'),
        outputPath: 'route.spec.httpRoute.timeout.idle.unit',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.httpRoute.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.httpRoute.timeout.idle.value'),
        outputPath: 'route.spec.httpRoute.timeout.idle.value',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.httpRoute.timeout.idle.value', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshResponsesDescribeRouteRouteSpecHttpRouteTimeoutPerRequest {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.httpRoute.timeout.perRequest.unit'),
        outputPath: 'route.spec.httpRoute.timeout.perRequest.unit',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.httpRoute.timeout.perRequest.unit', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.perRequest.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.httpRoute.timeout.perRequest.value'),
        outputPath: 'route.spec.httpRoute.timeout.perRequest.value',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.httpRoute.timeout.perRequest.value', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.perRequest.value') as unknown as number;
  }

}

export class AppMeshResponsesDescribeRouteRouteSpecTcpRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get action(): AppMeshResponsesDescribeRouteRouteSpecTcpRouteAction {
    return new AppMeshResponsesDescribeRouteRouteSpecTcpRouteAction(this.__scope, this.__resources, this.__input);
  }

  public get timeout(): AppMeshResponsesDescribeRouteRouteSpecTcpRouteTimeout {
    return new AppMeshResponsesDescribeRouteRouteSpecTcpRouteTimeout(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeRouteRouteSpecTcpRouteAction {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.tcpRoute.action.weightedTargets'),
        outputPath: 'route.spec.tcpRoute.action.weightedTargets',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.tcpRoute.action.weightedTargets', props);
    return resource.getResponseField('route.spec.tcpRoute.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshResponsesDescribeRouteRouteSpecTcpRouteTimeout {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get idle(): AppMeshResponsesDescribeRouteRouteSpecTcpRouteTimeoutIdle {
    return new AppMeshResponsesDescribeRouteRouteSpecTcpRouteTimeoutIdle(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeRouteRouteSpecTcpRouteTimeoutIdle {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.tcpRoute.timeout.idle.unit'),
        outputPath: 'route.spec.tcpRoute.timeout.idle.unit',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.tcpRoute.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.tcpRoute.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.spec.tcpRoute.timeout.idle.value'),
        outputPath: 'route.spec.tcpRoute.timeout.idle.value',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.spec.tcpRoute.timeout.idle.value', props);
    return resource.getResponseField('route.spec.tcpRoute.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshResponsesDescribeRouteRouteStatus {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeRouteInput) {
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeRoute.route.status.status'),
        outputPath: 'route.status.status',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeRoute.route.status.status', props);
    return resource.getResponseField('route.status.status') as unknown as string;
  }

}

export class AppMeshResponsesDescribeVirtualGateway {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualGatewayInput) {
  }

  public get virtualGateway(): AppMeshResponsesDescribeVirtualGatewayVirtualGateway {
    return new AppMeshResponsesDescribeVirtualGatewayVirtualGateway(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeVirtualGatewayVirtualGateway {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualGatewayInput) {
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.meshName'),
        outputPath: 'virtualGateway.meshName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualGateway.virtualGateway.meshName', props);
    return resource.getResponseField('virtualGateway.meshName') as unknown as string;
  }

  public get metadata(): AppMeshResponsesDescribeVirtualGatewayVirtualGatewayMetadata {
    return new AppMeshResponsesDescribeVirtualGatewayVirtualGatewayMetadata(this.__scope, this.__resources, this.__input);
  }

  public get spec(): AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpec {
    return new AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpec(this.__scope, this.__resources, this.__input);
  }

  public get status(): AppMeshResponsesDescribeVirtualGatewayVirtualGatewayStatus {
    return new AppMeshResponsesDescribeVirtualGatewayVirtualGatewayStatus(this.__scope, this.__resources, this.__input);
  }

  public get virtualGatewayName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.virtualGatewayName'),
        outputPath: 'virtualGateway.virtualGatewayName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualGateway.virtualGateway.virtualGatewayName', props);
    return resource.getResponseField('virtualGateway.virtualGatewayName') as unknown as string;
  }

}

export class AppMeshResponsesDescribeVirtualGatewayVirtualGatewayMetadata {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualGatewayInput) {
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.metadata.arn'),
        outputPath: 'virtualGateway.metadata.arn',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualGateway.virtualGateway.metadata.arn', props);
    return resource.getResponseField('virtualGateway.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.metadata.createdAt'),
        outputPath: 'virtualGateway.metadata.createdAt',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualGateway.virtualGateway.metadata.createdAt', props);
    return resource.getResponseField('virtualGateway.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.metadata.lastUpdatedAt'),
        outputPath: 'virtualGateway.metadata.lastUpdatedAt',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualGateway.virtualGateway.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualGateway.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.metadata.meshOwner'),
        outputPath: 'virtualGateway.metadata.meshOwner',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualGateway.virtualGateway.metadata.meshOwner', props);
    return resource.getResponseField('virtualGateway.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.metadata.resourceOwner'),
        outputPath: 'virtualGateway.metadata.resourceOwner',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualGateway.virtualGateway.metadata.resourceOwner', props);
    return resource.getResponseField('virtualGateway.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.metadata.uid'),
        outputPath: 'virtualGateway.metadata.uid',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualGateway.virtualGateway.metadata.uid', props);
    return resource.getResponseField('virtualGateway.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.metadata.version'),
        outputPath: 'virtualGateway.metadata.version',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualGateway.virtualGateway.metadata.version', props);
    return resource.getResponseField('virtualGateway.metadata.version') as unknown as number;
  }

}

export class AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpec {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualGatewayInput) {
  }

  public get backendDefaults(): AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpecBackendDefaults {
    return new AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpecBackendDefaults(this.__scope, this.__resources, this.__input);
  }

  public get listeners(): shapes.AppMeshVirtualGatewayListener[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.spec.listeners'),
        outputPath: 'virtualGateway.spec.listeners',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualGateway.virtualGateway.spec.listeners', props);
    return resource.getResponseField('virtualGateway.spec.listeners') as unknown as shapes.AppMeshVirtualGatewayListener[];
  }

  public get logging(): AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpecLogging {
    return new AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpecLogging(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpecBackendDefaults {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualGatewayInput) {
  }

  public get clientPolicy(): AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicy {
    return new AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicy(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicy {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualGatewayInput) {
  }

  public get tls(): AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTls {
    return new AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTls(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTls {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualGatewayInput) {
  }

  public get enforce(): boolean {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce') as unknown as boolean;
  }

  public get ports(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.ports'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.ports',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.ports', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.ports') as unknown as number[];
  }

  public get validation(): AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation {
    return new AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualGatewayInput) {
  }

  public get trust(): AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust {
    return new AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualGatewayInput) {
  }

  public get acm(): AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
    return new AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm(this.__scope, this.__resources, this.__input);
  }

  public get file(): AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile {
    return new AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualGatewayInput) {
  }

  public get certificateAuthorityArns(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns') as unknown as string[];
  }

}

export class AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualGatewayInput) {
  }

  public get certificateChain(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain') as unknown as string;
  }

}

export class AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpecLogging {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualGatewayInput) {
  }

  public get accessLog(): AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpecLoggingAccessLog {
    return new AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpecLoggingAccessLog(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpecLoggingAccessLog {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualGatewayInput) {
  }

  public get file(): AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpecLoggingAccessLogFile {
    return new AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpecLoggingAccessLogFile(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeVirtualGatewayVirtualGatewaySpecLoggingAccessLogFile {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualGatewayInput) {
  }

  public get path(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.spec.logging.accessLog.file.path'),
        outputPath: 'virtualGateway.spec.logging.accessLog.file.path',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualGateway.virtualGateway.spec.logging.accessLog.file.path', props);
    return resource.getResponseField('virtualGateway.spec.logging.accessLog.file.path') as unknown as string;
  }

}

export class AppMeshResponsesDescribeVirtualGatewayVirtualGatewayStatus {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualGatewayInput) {
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualGateway.virtualGateway.status.status'),
        outputPath: 'virtualGateway.status.status',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualGateway.virtualGateway.status.status', props);
    return resource.getResponseField('virtualGateway.status.status') as unknown as string;
  }

}

export class AppMeshResponsesDescribeVirtualNode {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualNodeInput) {
  }

  public get virtualNode(): AppMeshResponsesDescribeVirtualNodeVirtualNode {
    return new AppMeshResponsesDescribeVirtualNodeVirtualNode(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeVirtualNodeVirtualNode {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualNodeInput) {
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.meshName'),
        outputPath: 'virtualNode.meshName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualNode.virtualNode.meshName', props);
    return resource.getResponseField('virtualNode.meshName') as unknown as string;
  }

  public get metadata(): AppMeshResponsesDescribeVirtualNodeVirtualNodeMetadata {
    return new AppMeshResponsesDescribeVirtualNodeVirtualNodeMetadata(this.__scope, this.__resources, this.__input);
  }

  public get spec(): AppMeshResponsesDescribeVirtualNodeVirtualNodeSpec {
    return new AppMeshResponsesDescribeVirtualNodeVirtualNodeSpec(this.__scope, this.__resources, this.__input);
  }

  public get status(): AppMeshResponsesDescribeVirtualNodeVirtualNodeStatus {
    return new AppMeshResponsesDescribeVirtualNodeVirtualNodeStatus(this.__scope, this.__resources, this.__input);
  }

  public get virtualNodeName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.virtualNodeName'),
        outputPath: 'virtualNode.virtualNodeName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualNode.virtualNode.virtualNodeName', props);
    return resource.getResponseField('virtualNode.virtualNodeName') as unknown as string;
  }

}

export class AppMeshResponsesDescribeVirtualNodeVirtualNodeMetadata {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualNodeInput) {
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.metadata.arn'),
        outputPath: 'virtualNode.metadata.arn',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualNode.virtualNode.metadata.arn', props);
    return resource.getResponseField('virtualNode.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.metadata.createdAt'),
        outputPath: 'virtualNode.metadata.createdAt',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualNode.virtualNode.metadata.createdAt', props);
    return resource.getResponseField('virtualNode.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.metadata.lastUpdatedAt'),
        outputPath: 'virtualNode.metadata.lastUpdatedAt',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualNode.virtualNode.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualNode.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.metadata.meshOwner'),
        outputPath: 'virtualNode.metadata.meshOwner',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualNode.virtualNode.metadata.meshOwner', props);
    return resource.getResponseField('virtualNode.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.metadata.resourceOwner'),
        outputPath: 'virtualNode.metadata.resourceOwner',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualNode.virtualNode.metadata.resourceOwner', props);
    return resource.getResponseField('virtualNode.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.metadata.uid'),
        outputPath: 'virtualNode.metadata.uid',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualNode.virtualNode.metadata.uid', props);
    return resource.getResponseField('virtualNode.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.metadata.version'),
        outputPath: 'virtualNode.metadata.version',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualNode.virtualNode.metadata.version', props);
    return resource.getResponseField('virtualNode.metadata.version') as unknown as number;
  }

}

export class AppMeshResponsesDescribeVirtualNodeVirtualNodeSpec {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualNodeInput) {
  }

  public get backendDefaults(): AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecBackendDefaults {
    return new AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecBackendDefaults(this.__scope, this.__resources, this.__input);
  }

  public get backends(): shapes.AppMeshBackend[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.spec.backends'),
        outputPath: 'virtualNode.spec.backends',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualNode.virtualNode.spec.backends', props);
    return resource.getResponseField('virtualNode.spec.backends') as unknown as shapes.AppMeshBackend[];
  }

  public get listeners(): shapes.AppMeshListener[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.spec.listeners'),
        outputPath: 'virtualNode.spec.listeners',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualNode.virtualNode.spec.listeners', props);
    return resource.getResponseField('virtualNode.spec.listeners') as unknown as shapes.AppMeshListener[];
  }

  public get logging(): AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecLogging {
    return new AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecLogging(this.__scope, this.__resources, this.__input);
  }

  public get serviceDiscovery(): AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecServiceDiscovery {
    return new AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecServiceDiscovery(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecBackendDefaults {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualNodeInput) {
  }

  public get clientPolicy(): AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicy {
    return new AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicy(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicy {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualNodeInput) {
  }

  public get tls(): AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTls {
    return new AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTls(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTls {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualNodeInput) {
  }

  public get enforce(): boolean {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.enforce'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.enforce',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.enforce', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.enforce') as unknown as boolean;
  }

  public get ports(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.ports'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.ports',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.ports', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.ports') as unknown as number[];
  }

  public get validation(): AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidation {
    return new AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidation(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidation {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualNodeInput) {
  }

  public get trust(): AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust {
    return new AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualNodeInput) {
  }

  public get acm(): AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
    return new AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm(this.__scope, this.__resources, this.__input);
  }

  public get file(): AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile {
    return new AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualNodeInput) {
  }

  public get certificateAuthorityArns(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns') as unknown as string[];
  }

}

export class AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualNodeInput) {
  }

  public get certificateChain(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain') as unknown as string;
  }

}

export class AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecLogging {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualNodeInput) {
  }

  public get accessLog(): AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecLoggingAccessLog {
    return new AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecLoggingAccessLog(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecLoggingAccessLog {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualNodeInput) {
  }

  public get file(): AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecLoggingAccessLogFile {
    return new AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecLoggingAccessLogFile(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecLoggingAccessLogFile {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualNodeInput) {
  }

  public get path(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.spec.logging.accessLog.file.path'),
        outputPath: 'virtualNode.spec.logging.accessLog.file.path',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualNode.virtualNode.spec.logging.accessLog.file.path', props);
    return resource.getResponseField('virtualNode.spec.logging.accessLog.file.path') as unknown as string;
  }

}

export class AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecServiceDiscovery {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualNodeInput) {
  }

  public get awsCloudMap(): AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecServiceDiscoveryAwsCloudMap {
    return new AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecServiceDiscoveryAwsCloudMap(this.__scope, this.__resources, this.__input);
  }

  public get dns(): AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecServiceDiscoveryDns {
    return new AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecServiceDiscoveryDns(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecServiceDiscoveryAwsCloudMap {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualNodeInput) {
  }

  public get attributes(): shapes.AppMeshAwsCloudMapInstanceAttribute[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.attributes'),
        outputPath: 'virtualNode.spec.serviceDiscovery.awsCloudMap.attributes',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.attributes', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.awsCloudMap.attributes') as unknown as shapes.AppMeshAwsCloudMapInstanceAttribute[];
  }

  public get namespaceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName'),
        outputPath: 'virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName') as unknown as string;
  }

  public get serviceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName'),
        outputPath: 'virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName') as unknown as string;
  }

}

export class AppMeshResponsesDescribeVirtualNodeVirtualNodeSpecServiceDiscoveryDns {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualNodeInput) {
  }

  public get hostname(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.spec.serviceDiscovery.dns.hostname'),
        outputPath: 'virtualNode.spec.serviceDiscovery.dns.hostname',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualNode.virtualNode.spec.serviceDiscovery.dns.hostname', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.dns.hostname') as unknown as string;
  }

}

export class AppMeshResponsesDescribeVirtualNodeVirtualNodeStatus {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualNodeInput) {
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualNode.virtualNode.status.status'),
        outputPath: 'virtualNode.status.status',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualNode.virtualNode.status.status', props);
    return resource.getResponseField('virtualNode.status.status') as unknown as string;
  }

}

export class AppMeshResponsesDescribeVirtualRouter {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualRouterInput) {
  }

  public get virtualRouter(): AppMeshResponsesDescribeVirtualRouterVirtualRouter {
    return new AppMeshResponsesDescribeVirtualRouterVirtualRouter(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeVirtualRouterVirtualRouter {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualRouterInput) {
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualRouter.virtualRouter.meshName'),
        outputPath: 'virtualRouter.meshName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualRouter.virtualRouter.meshName', props);
    return resource.getResponseField('virtualRouter.meshName') as unknown as string;
  }

  public get metadata(): AppMeshResponsesDescribeVirtualRouterVirtualRouterMetadata {
    return new AppMeshResponsesDescribeVirtualRouterVirtualRouterMetadata(this.__scope, this.__resources, this.__input);
  }

  public get spec(): AppMeshResponsesDescribeVirtualRouterVirtualRouterSpec {
    return new AppMeshResponsesDescribeVirtualRouterVirtualRouterSpec(this.__scope, this.__resources, this.__input);
  }

  public get status(): AppMeshResponsesDescribeVirtualRouterVirtualRouterStatus {
    return new AppMeshResponsesDescribeVirtualRouterVirtualRouterStatus(this.__scope, this.__resources, this.__input);
  }

  public get virtualRouterName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualRouter.virtualRouter.virtualRouterName'),
        outputPath: 'virtualRouter.virtualRouterName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualRouter.virtualRouter.virtualRouterName', props);
    return resource.getResponseField('virtualRouter.virtualRouterName') as unknown as string;
  }

}

export class AppMeshResponsesDescribeVirtualRouterVirtualRouterMetadata {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualRouterInput) {
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualRouter.virtualRouter.metadata.arn'),
        outputPath: 'virtualRouter.metadata.arn',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualRouter.virtualRouter.metadata.arn', props);
    return resource.getResponseField('virtualRouter.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualRouter.virtualRouter.metadata.createdAt'),
        outputPath: 'virtualRouter.metadata.createdAt',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualRouter.virtualRouter.metadata.createdAt', props);
    return resource.getResponseField('virtualRouter.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualRouter.virtualRouter.metadata.lastUpdatedAt'),
        outputPath: 'virtualRouter.metadata.lastUpdatedAt',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualRouter.virtualRouter.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualRouter.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualRouter.virtualRouter.metadata.meshOwner'),
        outputPath: 'virtualRouter.metadata.meshOwner',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualRouter.virtualRouter.metadata.meshOwner', props);
    return resource.getResponseField('virtualRouter.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualRouter.virtualRouter.metadata.resourceOwner'),
        outputPath: 'virtualRouter.metadata.resourceOwner',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualRouter.virtualRouter.metadata.resourceOwner', props);
    return resource.getResponseField('virtualRouter.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualRouter.virtualRouter.metadata.uid'),
        outputPath: 'virtualRouter.metadata.uid',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualRouter.virtualRouter.metadata.uid', props);
    return resource.getResponseField('virtualRouter.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualRouter.virtualRouter.metadata.version'),
        outputPath: 'virtualRouter.metadata.version',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualRouter.virtualRouter.metadata.version', props);
    return resource.getResponseField('virtualRouter.metadata.version') as unknown as number;
  }

}

export class AppMeshResponsesDescribeVirtualRouterVirtualRouterSpec {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualRouterInput) {
  }

  public get listeners(): shapes.AppMeshVirtualRouterListener[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualRouter.virtualRouter.spec.listeners'),
        outputPath: 'virtualRouter.spec.listeners',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualRouter.virtualRouter.spec.listeners', props);
    return resource.getResponseField('virtualRouter.spec.listeners') as unknown as shapes.AppMeshVirtualRouterListener[];
  }

}

export class AppMeshResponsesDescribeVirtualRouterVirtualRouterStatus {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualRouterInput) {
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualRouter.virtualRouter.status.status'),
        outputPath: 'virtualRouter.status.status',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualRouter.virtualRouter.status.status', props);
    return resource.getResponseField('virtualRouter.status.status') as unknown as string;
  }

}

export class AppMeshResponsesDescribeVirtualService {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualServiceInput) {
  }

  public get virtualService(): AppMeshResponsesDescribeVirtualServiceVirtualService {
    return new AppMeshResponsesDescribeVirtualServiceVirtualService(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeVirtualServiceVirtualService {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualServiceInput) {
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualService.virtualService.meshName'),
        outputPath: 'virtualService.meshName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualService.virtualService.meshName', props);
    return resource.getResponseField('virtualService.meshName') as unknown as string;
  }

  public get metadata(): AppMeshResponsesDescribeVirtualServiceVirtualServiceMetadata {
    return new AppMeshResponsesDescribeVirtualServiceVirtualServiceMetadata(this.__scope, this.__resources, this.__input);
  }

  public get spec(): AppMeshResponsesDescribeVirtualServiceVirtualServiceSpec {
    return new AppMeshResponsesDescribeVirtualServiceVirtualServiceSpec(this.__scope, this.__resources, this.__input);
  }

  public get status(): AppMeshResponsesDescribeVirtualServiceVirtualServiceStatus {
    return new AppMeshResponsesDescribeVirtualServiceVirtualServiceStatus(this.__scope, this.__resources, this.__input);
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualService.virtualService.virtualServiceName'),
        outputPath: 'virtualService.virtualServiceName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualService.virtualService.virtualServiceName', props);
    return resource.getResponseField('virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshResponsesDescribeVirtualServiceVirtualServiceMetadata {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualServiceInput) {
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualService.virtualService.metadata.arn'),
        outputPath: 'virtualService.metadata.arn',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualService.virtualService.metadata.arn', props);
    return resource.getResponseField('virtualService.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualService.virtualService.metadata.createdAt'),
        outputPath: 'virtualService.metadata.createdAt',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualService.virtualService.metadata.createdAt', props);
    return resource.getResponseField('virtualService.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualService.virtualService.metadata.lastUpdatedAt'),
        outputPath: 'virtualService.metadata.lastUpdatedAt',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualService.virtualService.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualService.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualService.virtualService.metadata.meshOwner'),
        outputPath: 'virtualService.metadata.meshOwner',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualService.virtualService.metadata.meshOwner', props);
    return resource.getResponseField('virtualService.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualService.virtualService.metadata.resourceOwner'),
        outputPath: 'virtualService.metadata.resourceOwner',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualService.virtualService.metadata.resourceOwner', props);
    return resource.getResponseField('virtualService.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualService.virtualService.metadata.uid'),
        outputPath: 'virtualService.metadata.uid',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualService.virtualService.metadata.uid', props);
    return resource.getResponseField('virtualService.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualService.virtualService.metadata.version'),
        outputPath: 'virtualService.metadata.version',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualService.virtualService.metadata.version', props);
    return resource.getResponseField('virtualService.metadata.version') as unknown as number;
  }

}

export class AppMeshResponsesDescribeVirtualServiceVirtualServiceSpec {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualServiceInput) {
  }

  public get provider(): AppMeshResponsesDescribeVirtualServiceVirtualServiceSpecProvider {
    return new AppMeshResponsesDescribeVirtualServiceVirtualServiceSpecProvider(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeVirtualServiceVirtualServiceSpecProvider {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualServiceInput) {
  }

  public get virtualNode(): AppMeshResponsesDescribeVirtualServiceVirtualServiceSpecProviderVirtualNode {
    return new AppMeshResponsesDescribeVirtualServiceVirtualServiceSpecProviderVirtualNode(this.__scope, this.__resources, this.__input);
  }

  public get virtualRouter(): AppMeshResponsesDescribeVirtualServiceVirtualServiceSpecProviderVirtualRouter {
    return new AppMeshResponsesDescribeVirtualServiceVirtualServiceSpecProviderVirtualRouter(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesDescribeVirtualServiceVirtualServiceSpecProviderVirtualNode {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualServiceInput) {
  }

  public get virtualNodeName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualService.virtualService.spec.provider.virtualNode.virtualNodeName'),
        outputPath: 'virtualService.spec.provider.virtualNode.virtualNodeName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualService.virtualService.spec.provider.virtualNode.virtualNodeName', props);
    return resource.getResponseField('virtualService.spec.provider.virtualNode.virtualNodeName') as unknown as string;
  }

}

export class AppMeshResponsesDescribeVirtualServiceVirtualServiceSpecProviderVirtualRouter {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualServiceInput) {
  }

  public get virtualRouterName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualService.virtualService.spec.provider.virtualRouter.virtualRouterName'),
        outputPath: 'virtualService.spec.provider.virtualRouter.virtualRouterName',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualService.virtualService.spec.provider.virtualRouter.virtualRouterName', props);
    return resource.getResponseField('virtualService.spec.provider.virtualRouter.virtualRouterName') as unknown as string;
  }

}

export class AppMeshResponsesDescribeVirtualServiceVirtualServiceStatus {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshDescribeVirtualServiceInput) {
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.DescribeVirtualService.virtualService.status.status'),
        outputPath: 'virtualService.status.status',
        parameters: {
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'DescribeVirtualService.virtualService.status.status', props);
    return resource.getResponseField('virtualService.status.status') as unknown as string;
  }

}

export class AppMeshResponsesListGatewayRoutes {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshListGatewayRoutesInput) {
  }

  public get gatewayRoutes(): shapes.AppMeshGatewayRouteRef[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listGatewayRoutes',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListGatewayRoutes.gatewayRoutes'),
        outputPath: 'gatewayRoutes',
        parameters: {
          limit: this.__input.limit,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          nextToken: this.__input.nextToken,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'ListGatewayRoutes.gatewayRoutes', props);
    return resource.getResponseField('gatewayRoutes') as unknown as shapes.AppMeshGatewayRouteRef[];
  }

  public get nextToken(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listGatewayRoutes',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListGatewayRoutes.nextToken'),
        outputPath: 'nextToken',
        parameters: {
          limit: this.__input.limit,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          nextToken: this.__input.nextToken,
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'ListGatewayRoutes.nextToken', props);
    return resource.getResponseField('nextToken') as unknown as string;
  }

}

export class AppMeshResponsesListMeshes {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshListMeshesInput) {
  }

  public get meshes(): shapes.AppMeshMeshRef[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listMeshes',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListMeshes.meshes'),
        outputPath: 'meshes',
        parameters: {
          limit: this.__input.limit,
          nextToken: this.__input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'ListMeshes.meshes', props);
    return resource.getResponseField('meshes') as unknown as shapes.AppMeshMeshRef[];
  }

  public get nextToken(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listMeshes',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListMeshes.nextToken'),
        outputPath: 'nextToken',
        parameters: {
          limit: this.__input.limit,
          nextToken: this.__input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'ListMeshes.nextToken', props);
    return resource.getResponseField('nextToken') as unknown as string;
  }

}

export class AppMeshResponsesListRoutes {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshListRoutesInput) {
  }

  public get nextToken(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listRoutes',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListRoutes.nextToken'),
        outputPath: 'nextToken',
        parameters: {
          limit: this.__input.limit,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          nextToken: this.__input.nextToken,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'ListRoutes.nextToken', props);
    return resource.getResponseField('nextToken') as unknown as string;
  }

  public get routes(): shapes.AppMeshRouteRef[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listRoutes',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListRoutes.routes'),
        outputPath: 'routes',
        parameters: {
          limit: this.__input.limit,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          nextToken: this.__input.nextToken,
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'ListRoutes.routes', props);
    return resource.getResponseField('routes') as unknown as shapes.AppMeshRouteRef[];
  }

}

export class AppMeshResponsesListTagsForResource {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshListTagsForResourceInput) {
  }

  public get nextToken(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listTagsForResource',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListTagsForResource.nextToken'),
        outputPath: 'nextToken',
        parameters: {
          limit: this.__input.limit,
          nextToken: this.__input.nextToken,
          resourceArn: this.__input.resourceArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'ListTagsForResource.nextToken', props);
    return resource.getResponseField('nextToken') as unknown as string;
  }

  public get tags(): shapes.AppMeshTagRef[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listTagsForResource',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListTagsForResource.tags'),
        outputPath: 'tags',
        parameters: {
          limit: this.__input.limit,
          nextToken: this.__input.nextToken,
          resourceArn: this.__input.resourceArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'ListTagsForResource.tags', props);
    return resource.getResponseField('tags') as unknown as shapes.AppMeshTagRef[];
  }

}

export class AppMeshResponsesListVirtualGateways {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshListVirtualGatewaysInput) {
  }

  public get nextToken(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listVirtualGateways',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListVirtualGateways.nextToken'),
        outputPath: 'nextToken',
        parameters: {
          limit: this.__input.limit,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          nextToken: this.__input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'ListVirtualGateways.nextToken', props);
    return resource.getResponseField('nextToken') as unknown as string;
  }

  public get virtualGateways(): shapes.AppMeshVirtualGatewayRef[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listVirtualGateways',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListVirtualGateways.virtualGateways'),
        outputPath: 'virtualGateways',
        parameters: {
          limit: this.__input.limit,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          nextToken: this.__input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'ListVirtualGateways.virtualGateways', props);
    return resource.getResponseField('virtualGateways') as unknown as shapes.AppMeshVirtualGatewayRef[];
  }

}

export class AppMeshResponsesListVirtualNodes {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshListVirtualNodesInput) {
  }

  public get nextToken(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listVirtualNodes',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListVirtualNodes.nextToken'),
        outputPath: 'nextToken',
        parameters: {
          limit: this.__input.limit,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          nextToken: this.__input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'ListVirtualNodes.nextToken', props);
    return resource.getResponseField('nextToken') as unknown as string;
  }

  public get virtualNodes(): shapes.AppMeshVirtualNodeRef[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listVirtualNodes',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListVirtualNodes.virtualNodes'),
        outputPath: 'virtualNodes',
        parameters: {
          limit: this.__input.limit,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          nextToken: this.__input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'ListVirtualNodes.virtualNodes', props);
    return resource.getResponseField('virtualNodes') as unknown as shapes.AppMeshVirtualNodeRef[];
  }

}

export class AppMeshResponsesListVirtualRouters {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshListVirtualRoutersInput) {
  }

  public get nextToken(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listVirtualRouters',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListVirtualRouters.nextToken'),
        outputPath: 'nextToken',
        parameters: {
          limit: this.__input.limit,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          nextToken: this.__input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'ListVirtualRouters.nextToken', props);
    return resource.getResponseField('nextToken') as unknown as string;
  }

  public get virtualRouters(): shapes.AppMeshVirtualRouterRef[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listVirtualRouters',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListVirtualRouters.virtualRouters'),
        outputPath: 'virtualRouters',
        parameters: {
          limit: this.__input.limit,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          nextToken: this.__input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'ListVirtualRouters.virtualRouters', props);
    return resource.getResponseField('virtualRouters') as unknown as shapes.AppMeshVirtualRouterRef[];
  }

}

export class AppMeshResponsesListVirtualServices {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshListVirtualServicesInput) {
  }

  public get nextToken(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listVirtualServices',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListVirtualServices.nextToken'),
        outputPath: 'nextToken',
        parameters: {
          limit: this.__input.limit,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          nextToken: this.__input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'ListVirtualServices.nextToken', props);
    return resource.getResponseField('nextToken') as unknown as string;
  }

  public get virtualServices(): shapes.AppMeshVirtualServiceRef[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listVirtualServices',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.ListVirtualServices.virtualServices'),
        outputPath: 'virtualServices',
        parameters: {
          limit: this.__input.limit,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          nextToken: this.__input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'ListVirtualServices.virtualServices', props);
    return resource.getResponseField('virtualServices') as unknown as shapes.AppMeshVirtualServiceRef[];
  }

}

export class AppMeshResponsesUpdateGatewayRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateGatewayRouteInput) {
  }

  public get gatewayRoute(): AppMeshResponsesUpdateGatewayRouteGatewayRoute {
    return new AppMeshResponsesUpdateGatewayRouteGatewayRoute(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateGatewayRouteGatewayRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateGatewayRouteInput) {
  }

  public get gatewayRouteName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.gatewayRouteName'),
        outputPath: 'gatewayRoute.gatewayRouteName',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateGatewayRoute.gatewayRoute.gatewayRouteName', props);
    return resource.getResponseField('gatewayRoute.gatewayRouteName') as unknown as string;
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.meshName'),
        outputPath: 'gatewayRoute.meshName',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateGatewayRoute.gatewayRoute.meshName', props);
    return resource.getResponseField('gatewayRoute.meshName') as unknown as string;
  }

  public get metadata(): AppMeshResponsesUpdateGatewayRouteGatewayRouteMetadata {
    return new AppMeshResponsesUpdateGatewayRouteGatewayRouteMetadata(this.__scope, this.__resources, this.__input);
  }

  public get spec(): AppMeshResponsesUpdateGatewayRouteGatewayRouteSpec {
    return new AppMeshResponsesUpdateGatewayRouteGatewayRouteSpec(this.__scope, this.__resources, this.__input);
  }

  public get status(): AppMeshResponsesUpdateGatewayRouteGatewayRouteStatus {
    return new AppMeshResponsesUpdateGatewayRouteGatewayRouteStatus(this.__scope, this.__resources, this.__input);
  }

  public get virtualGatewayName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.virtualGatewayName'),
        outputPath: 'gatewayRoute.virtualGatewayName',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateGatewayRoute.gatewayRoute.virtualGatewayName', props);
    return resource.getResponseField('gatewayRoute.virtualGatewayName') as unknown as string;
  }

}

export class AppMeshResponsesUpdateGatewayRouteGatewayRouteMetadata {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateGatewayRouteInput) {
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.metadata.arn'),
        outputPath: 'gatewayRoute.metadata.arn',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateGatewayRoute.gatewayRoute.metadata.arn', props);
    return resource.getResponseField('gatewayRoute.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.metadata.createdAt'),
        outputPath: 'gatewayRoute.metadata.createdAt',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateGatewayRoute.gatewayRoute.metadata.createdAt', props);
    return resource.getResponseField('gatewayRoute.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.metadata.lastUpdatedAt'),
        outputPath: 'gatewayRoute.metadata.lastUpdatedAt',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateGatewayRoute.gatewayRoute.metadata.lastUpdatedAt', props);
    return resource.getResponseField('gatewayRoute.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.metadata.meshOwner'),
        outputPath: 'gatewayRoute.metadata.meshOwner',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateGatewayRoute.gatewayRoute.metadata.meshOwner', props);
    return resource.getResponseField('gatewayRoute.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.metadata.resourceOwner'),
        outputPath: 'gatewayRoute.metadata.resourceOwner',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateGatewayRoute.gatewayRoute.metadata.resourceOwner', props);
    return resource.getResponseField('gatewayRoute.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.metadata.uid'),
        outputPath: 'gatewayRoute.metadata.uid',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateGatewayRoute.gatewayRoute.metadata.uid', props);
    return resource.getResponseField('gatewayRoute.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.metadata.version'),
        outputPath: 'gatewayRoute.metadata.version',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateGatewayRoute.gatewayRoute.metadata.version', props);
    return resource.getResponseField('gatewayRoute.metadata.version') as unknown as number;
  }

}

export class AppMeshResponsesUpdateGatewayRouteGatewayRouteSpec {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateGatewayRouteInput) {
  }

  public get grpcRoute(): AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecGrpcRoute {
    return new AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecGrpcRoute(this.__scope, this.__resources, this.__input);
  }

  public get http2Route(): AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecHttp2Route {
    return new AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecHttp2Route(this.__scope, this.__resources, this.__input);
  }

  public get httpRoute(): AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecHttpRoute {
    return new AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecHttpRoute(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecGrpcRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateGatewayRouteInput) {
  }

  public get action(): AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecGrpcRouteAction {
    return new AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecGrpcRouteAction(this.__scope, this.__resources, this.__input);
  }

  public get match(): AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecGrpcRouteMatch {
    return new AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecGrpcRouteMatch(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecGrpcRouteAction {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateGatewayRouteInput) {
  }

  public get target(): AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecGrpcRouteActionTarget {
    return new AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecGrpcRouteActionTarget(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecGrpcRouteActionTarget {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateGatewayRouteInput) {
  }

  public get virtualService(): AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecGrpcRouteActionTargetVirtualService {
    return new AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecGrpcRouteActionTargetVirtualService(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecGrpcRouteActionTargetVirtualService {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateGatewayRouteInput) {
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName'),
        outputPath: 'gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateGatewayRoute.gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName', props);
    return resource.getResponseField('gatewayRoute.spec.grpcRoute.action.target.virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecGrpcRouteMatch {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateGatewayRouteInput) {
  }

  public get serviceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.spec.grpcRoute.match.serviceName'),
        outputPath: 'gatewayRoute.spec.grpcRoute.match.serviceName',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateGatewayRoute.gatewayRoute.spec.grpcRoute.match.serviceName', props);
    return resource.getResponseField('gatewayRoute.spec.grpcRoute.match.serviceName') as unknown as string;
  }

}

export class AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecHttp2Route {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateGatewayRouteInput) {
  }

  public get action(): AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecHttp2RouteAction {
    return new AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecHttp2RouteAction(this.__scope, this.__resources, this.__input);
  }

  public get match(): AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecHttp2RouteMatch {
    return new AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecHttp2RouteMatch(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecHttp2RouteAction {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateGatewayRouteInput) {
  }

  public get target(): AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecHttp2RouteActionTarget {
    return new AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecHttp2RouteActionTarget(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecHttp2RouteActionTarget {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateGatewayRouteInput) {
  }

  public get virtualService(): AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecHttp2RouteActionTargetVirtualService {
    return new AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecHttp2RouteActionTargetVirtualService(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecHttp2RouteActionTargetVirtualService {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateGatewayRouteInput) {
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName'),
        outputPath: 'gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateGatewayRoute.gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName', props);
    return resource.getResponseField('gatewayRoute.spec.http2Route.action.target.virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecHttp2RouteMatch {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateGatewayRouteInput) {
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.spec.http2Route.match.prefix'),
        outputPath: 'gatewayRoute.spec.http2Route.match.prefix',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateGatewayRoute.gatewayRoute.spec.http2Route.match.prefix', props);
    return resource.getResponseField('gatewayRoute.spec.http2Route.match.prefix') as unknown as string;
  }

}

export class AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecHttpRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateGatewayRouteInput) {
  }

  public get action(): AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecHttpRouteAction {
    return new AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecHttpRouteAction(this.__scope, this.__resources, this.__input);
  }

  public get match(): AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecHttpRouteMatch {
    return new AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecHttpRouteMatch(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecHttpRouteAction {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateGatewayRouteInput) {
  }

  public get target(): AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecHttpRouteActionTarget {
    return new AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecHttpRouteActionTarget(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecHttpRouteActionTarget {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateGatewayRouteInput) {
  }

  public get virtualService(): AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecHttpRouteActionTargetVirtualService {
    return new AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecHttpRouteActionTargetVirtualService(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecHttpRouteActionTargetVirtualService {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateGatewayRouteInput) {
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName'),
        outputPath: 'gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateGatewayRoute.gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName', props);
    return resource.getResponseField('gatewayRoute.spec.httpRoute.action.target.virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshResponsesUpdateGatewayRouteGatewayRouteSpecHttpRouteMatch {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateGatewayRouteInput) {
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.spec.httpRoute.match.prefix'),
        outputPath: 'gatewayRoute.spec.httpRoute.match.prefix',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateGatewayRoute.gatewayRoute.spec.httpRoute.match.prefix', props);
    return resource.getResponseField('gatewayRoute.spec.httpRoute.match.prefix') as unknown as string;
  }

}

export class AppMeshResponsesUpdateGatewayRouteGatewayRouteStatus {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateGatewayRouteInput) {
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateGatewayRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateGatewayRoute.gatewayRoute.status.status'),
        outputPath: 'gatewayRoute.status.status',
        parameters: {
          clientToken: this.__input.clientToken,
          gatewayRouteName: this.__input.gatewayRouteName,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            grpcRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.grpcRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
            },
            http2Route: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.http2Route?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.http2Route?.match.prefix,
              },
            },
            httpRoute: {
              action: {
                target: {
                  virtualService: {
                    virtualServiceName: this.__input.spec.httpRoute?.action.target.virtualService.virtualServiceName,
                  },
                },
              },
              match: {
                prefix: this.__input.spec.httpRoute?.match.prefix,
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateGatewayRoute.gatewayRoute.status.status', props);
    return resource.getResponseField('gatewayRoute.status.status') as unknown as string;
  }

}

export class AppMeshResponsesUpdateMesh {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateMeshInput) {
  }

  public get mesh(): AppMeshResponsesUpdateMeshMesh {
    return new AppMeshResponsesUpdateMeshMesh(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateMeshMesh {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateMeshInput) {
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateMesh.mesh.meshName'),
        outputPath: 'mesh.meshName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          spec: {
            egressFilter: {
              type: this.__input.spec?.egressFilter?.type,
            },
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateMesh.mesh.meshName', props);
    return resource.getResponseField('mesh.meshName') as unknown as string;
  }

  public get metadata(): AppMeshResponsesUpdateMeshMeshMetadata {
    return new AppMeshResponsesUpdateMeshMeshMetadata(this.__scope, this.__resources, this.__input);
  }

  public get spec(): AppMeshResponsesUpdateMeshMeshSpec {
    return new AppMeshResponsesUpdateMeshMeshSpec(this.__scope, this.__resources, this.__input);
  }

  public get status(): AppMeshResponsesUpdateMeshMeshStatus {
    return new AppMeshResponsesUpdateMeshMeshStatus(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateMeshMeshMetadata {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateMeshInput) {
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateMesh.mesh.metadata.arn'),
        outputPath: 'mesh.metadata.arn',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          spec: {
            egressFilter: {
              type: this.__input.spec?.egressFilter?.type,
            },
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateMesh.mesh.metadata.arn', props);
    return resource.getResponseField('mesh.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateMesh.mesh.metadata.createdAt'),
        outputPath: 'mesh.metadata.createdAt',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          spec: {
            egressFilter: {
              type: this.__input.spec?.egressFilter?.type,
            },
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateMesh.mesh.metadata.createdAt', props);
    return resource.getResponseField('mesh.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateMesh.mesh.metadata.lastUpdatedAt'),
        outputPath: 'mesh.metadata.lastUpdatedAt',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          spec: {
            egressFilter: {
              type: this.__input.spec?.egressFilter?.type,
            },
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateMesh.mesh.metadata.lastUpdatedAt', props);
    return resource.getResponseField('mesh.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateMesh.mesh.metadata.meshOwner'),
        outputPath: 'mesh.metadata.meshOwner',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          spec: {
            egressFilter: {
              type: this.__input.spec?.egressFilter?.type,
            },
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateMesh.mesh.metadata.meshOwner', props);
    return resource.getResponseField('mesh.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateMesh.mesh.metadata.resourceOwner'),
        outputPath: 'mesh.metadata.resourceOwner',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          spec: {
            egressFilter: {
              type: this.__input.spec?.egressFilter?.type,
            },
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateMesh.mesh.metadata.resourceOwner', props);
    return resource.getResponseField('mesh.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateMesh.mesh.metadata.uid'),
        outputPath: 'mesh.metadata.uid',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          spec: {
            egressFilter: {
              type: this.__input.spec?.egressFilter?.type,
            },
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateMesh.mesh.metadata.uid', props);
    return resource.getResponseField('mesh.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateMesh.mesh.metadata.version'),
        outputPath: 'mesh.metadata.version',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          spec: {
            egressFilter: {
              type: this.__input.spec?.egressFilter?.type,
            },
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateMesh.mesh.metadata.version', props);
    return resource.getResponseField('mesh.metadata.version') as unknown as number;
  }

}

export class AppMeshResponsesUpdateMeshMeshSpec {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateMeshInput) {
  }

  public get egressFilter(): AppMeshResponsesUpdateMeshMeshSpecEgressFilter {
    return new AppMeshResponsesUpdateMeshMeshSpecEgressFilter(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateMeshMeshSpecEgressFilter {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateMeshInput) {
  }

  public get type(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateMesh.mesh.spec.egressFilter.type'),
        outputPath: 'mesh.spec.egressFilter.type',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          spec: {
            egressFilter: {
              type: this.__input.spec?.egressFilter?.type,
            },
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateMesh.mesh.spec.egressFilter.type', props);
    return resource.getResponseField('mesh.spec.egressFilter.type') as unknown as string;
  }

}

export class AppMeshResponsesUpdateMeshMeshStatus {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateMeshInput) {
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMesh',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateMesh.mesh.status.status'),
        outputPath: 'mesh.status.status',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          spec: {
            egressFilter: {
              type: this.__input.spec?.egressFilter?.type,
            },
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateMesh.mesh.status.status', props);
    return resource.getResponseField('mesh.status.status') as unknown as string;
  }

}

export class AppMeshResponsesUpdateRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get route(): AppMeshResponsesUpdateRouteRoute {
    return new AppMeshResponsesUpdateRouteRoute(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateRouteRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.meshName'),
        outputPath: 'route.meshName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.meshName', props);
    return resource.getResponseField('route.meshName') as unknown as string;
  }

  public get metadata(): AppMeshResponsesUpdateRouteRouteMetadata {
    return new AppMeshResponsesUpdateRouteRouteMetadata(this.__scope, this.__resources, this.__input);
  }

  public get routeName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.routeName'),
        outputPath: 'route.routeName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.routeName', props);
    return resource.getResponseField('route.routeName') as unknown as string;
  }

  public get spec(): AppMeshResponsesUpdateRouteRouteSpec {
    return new AppMeshResponsesUpdateRouteRouteSpec(this.__scope, this.__resources, this.__input);
  }

  public get status(): AppMeshResponsesUpdateRouteRouteStatus {
    return new AppMeshResponsesUpdateRouteRouteStatus(this.__scope, this.__resources, this.__input);
  }

  public get virtualRouterName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.virtualRouterName'),
        outputPath: 'route.virtualRouterName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.virtualRouterName', props);
    return resource.getResponseField('route.virtualRouterName') as unknown as string;
  }

}

export class AppMeshResponsesUpdateRouteRouteMetadata {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.metadata.arn'),
        outputPath: 'route.metadata.arn',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.metadata.arn', props);
    return resource.getResponseField('route.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.metadata.createdAt'),
        outputPath: 'route.metadata.createdAt',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.metadata.createdAt', props);
    return resource.getResponseField('route.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.metadata.lastUpdatedAt'),
        outputPath: 'route.metadata.lastUpdatedAt',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.metadata.lastUpdatedAt', props);
    return resource.getResponseField('route.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.metadata.meshOwner'),
        outputPath: 'route.metadata.meshOwner',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.metadata.meshOwner', props);
    return resource.getResponseField('route.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.metadata.resourceOwner'),
        outputPath: 'route.metadata.resourceOwner',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.metadata.resourceOwner', props);
    return resource.getResponseField('route.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.metadata.uid'),
        outputPath: 'route.metadata.uid',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.metadata.uid', props);
    return resource.getResponseField('route.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.metadata.version'),
        outputPath: 'route.metadata.version',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.metadata.version', props);
    return resource.getResponseField('route.metadata.version') as unknown as number;
  }

}

export class AppMeshResponsesUpdateRouteRouteSpec {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get grpcRoute(): AppMeshResponsesUpdateRouteRouteSpecGrpcRoute {
    return new AppMeshResponsesUpdateRouteRouteSpecGrpcRoute(this.__scope, this.__resources, this.__input);
  }

  public get http2Route(): AppMeshResponsesUpdateRouteRouteSpecHttp2Route {
    return new AppMeshResponsesUpdateRouteRouteSpecHttp2Route(this.__scope, this.__resources, this.__input);
  }

  public get httpRoute(): AppMeshResponsesUpdateRouteRouteSpecHttpRoute {
    return new AppMeshResponsesUpdateRouteRouteSpecHttpRoute(this.__scope, this.__resources, this.__input);
  }

  public get priority(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.priority'),
        outputPath: 'route.spec.priority',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.priority', props);
    return resource.getResponseField('route.spec.priority') as unknown as number;
  }

  public get tcpRoute(): AppMeshResponsesUpdateRouteRouteSpecTcpRoute {
    return new AppMeshResponsesUpdateRouteRouteSpecTcpRoute(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateRouteRouteSpecGrpcRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get action(): AppMeshResponsesUpdateRouteRouteSpecGrpcRouteAction {
    return new AppMeshResponsesUpdateRouteRouteSpecGrpcRouteAction(this.__scope, this.__resources, this.__input);
  }

  public get match(): AppMeshResponsesUpdateRouteRouteSpecGrpcRouteMatch {
    return new AppMeshResponsesUpdateRouteRouteSpecGrpcRouteMatch(this.__scope, this.__resources, this.__input);
  }

  public get retryPolicy(): AppMeshResponsesUpdateRouteRouteSpecGrpcRouteRetryPolicy {
    return new AppMeshResponsesUpdateRouteRouteSpecGrpcRouteRetryPolicy(this.__scope, this.__resources, this.__input);
  }

  public get timeout(): AppMeshResponsesUpdateRouteRouteSpecGrpcRouteTimeout {
    return new AppMeshResponsesUpdateRouteRouteSpecGrpcRouteTimeout(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateRouteRouteSpecGrpcRouteAction {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.grpcRoute.action.weightedTargets'),
        outputPath: 'route.spec.grpcRoute.action.weightedTargets',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.grpcRoute.action.weightedTargets', props);
    return resource.getResponseField('route.spec.grpcRoute.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshResponsesUpdateRouteRouteSpecGrpcRouteMatch {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get metadata(): shapes.AppMeshGrpcRouteMetadata[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.grpcRoute.match.metadata'),
        outputPath: 'route.spec.grpcRoute.match.metadata',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.grpcRoute.match.metadata', props);
    return resource.getResponseField('route.spec.grpcRoute.match.metadata') as unknown as shapes.AppMeshGrpcRouteMetadata[];
  }

  public get methodName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.grpcRoute.match.methodName'),
        outputPath: 'route.spec.grpcRoute.match.methodName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.grpcRoute.match.methodName', props);
    return resource.getResponseField('route.spec.grpcRoute.match.methodName') as unknown as string;
  }

  public get serviceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.grpcRoute.match.serviceName'),
        outputPath: 'route.spec.grpcRoute.match.serviceName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.grpcRoute.match.serviceName', props);
    return resource.getResponseField('route.spec.grpcRoute.match.serviceName') as unknown as string;
  }

}

export class AppMeshResponsesUpdateRouteRouteSpecGrpcRouteRetryPolicy {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get grpcRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.grpcRoute.retryPolicy.grpcRetryEvents'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.grpcRetryEvents',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.grpcRoute.retryPolicy.grpcRetryEvents', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.grpcRetryEvents') as unknown as string[];
  }

  public get httpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.grpcRoute.retryPolicy.httpRetryEvents'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.httpRetryEvents',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.grpcRoute.retryPolicy.httpRetryEvents', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.httpRetryEvents') as unknown as string[];
  }

  public get maxRetries(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.grpcRoute.retryPolicy.maxRetries'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.maxRetries',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.grpcRoute.retryPolicy.maxRetries', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.maxRetries') as unknown as number;
  }

  public get perRetryTimeout(): AppMeshResponsesUpdateRouteRouteSpecGrpcRouteRetryPolicyPerRetryTimeout {
    return new AppMeshResponsesUpdateRouteRouteSpecGrpcRouteRetryPolicyPerRetryTimeout(this.__scope, this.__resources, this.__input);
  }

  public get tcpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.grpcRoute.retryPolicy.tcpRetryEvents'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.tcpRetryEvents',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.grpcRoute.retryPolicy.tcpRetryEvents', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.tcpRetryEvents') as unknown as string[];
  }

}

export class AppMeshResponsesUpdateRouteRouteSpecGrpcRouteRetryPolicyPerRetryTimeout {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.perRetryTimeout.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.value'),
        outputPath: 'route.spec.grpcRoute.retryPolicy.perRetryTimeout.value',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.grpcRoute.retryPolicy.perRetryTimeout.value', props);
    return resource.getResponseField('route.spec.grpcRoute.retryPolicy.perRetryTimeout.value') as unknown as number;
  }

}

export class AppMeshResponsesUpdateRouteRouteSpecGrpcRouteTimeout {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get idle(): AppMeshResponsesUpdateRouteRouteSpecGrpcRouteTimeoutIdle {
    return new AppMeshResponsesUpdateRouteRouteSpecGrpcRouteTimeoutIdle(this.__scope, this.__resources, this.__input);
  }

  public get perRequest(): AppMeshResponsesUpdateRouteRouteSpecGrpcRouteTimeoutPerRequest {
    return new AppMeshResponsesUpdateRouteRouteSpecGrpcRouteTimeoutPerRequest(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateRouteRouteSpecGrpcRouteTimeoutIdle {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.grpcRoute.timeout.idle.unit'),
        outputPath: 'route.spec.grpcRoute.timeout.idle.unit',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.grpcRoute.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.grpcRoute.timeout.idle.value'),
        outputPath: 'route.spec.grpcRoute.timeout.idle.value',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.grpcRoute.timeout.idle.value', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshResponsesUpdateRouteRouteSpecGrpcRouteTimeoutPerRequest {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.grpcRoute.timeout.perRequest.unit'),
        outputPath: 'route.spec.grpcRoute.timeout.perRequest.unit',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.grpcRoute.timeout.perRequest.unit', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.perRequest.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.grpcRoute.timeout.perRequest.value'),
        outputPath: 'route.spec.grpcRoute.timeout.perRequest.value',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.grpcRoute.timeout.perRequest.value', props);
    return resource.getResponseField('route.spec.grpcRoute.timeout.perRequest.value') as unknown as number;
  }

}

export class AppMeshResponsesUpdateRouteRouteSpecHttp2Route {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get action(): AppMeshResponsesUpdateRouteRouteSpecHttp2RouteAction {
    return new AppMeshResponsesUpdateRouteRouteSpecHttp2RouteAction(this.__scope, this.__resources, this.__input);
  }

  public get match(): AppMeshResponsesUpdateRouteRouteSpecHttp2RouteMatch {
    return new AppMeshResponsesUpdateRouteRouteSpecHttp2RouteMatch(this.__scope, this.__resources, this.__input);
  }

  public get retryPolicy(): AppMeshResponsesUpdateRouteRouteSpecHttp2RouteRetryPolicy {
    return new AppMeshResponsesUpdateRouteRouteSpecHttp2RouteRetryPolicy(this.__scope, this.__resources, this.__input);
  }

  public get timeout(): AppMeshResponsesUpdateRouteRouteSpecHttp2RouteTimeout {
    return new AppMeshResponsesUpdateRouteRouteSpecHttp2RouteTimeout(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateRouteRouteSpecHttp2RouteAction {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.http2Route.action.weightedTargets'),
        outputPath: 'route.spec.http2Route.action.weightedTargets',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.http2Route.action.weightedTargets', props);
    return resource.getResponseField('route.spec.http2Route.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshResponsesUpdateRouteRouteSpecHttp2RouteMatch {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get headers(): shapes.AppMeshHttpRouteHeader[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.http2Route.match.headers'),
        outputPath: 'route.spec.http2Route.match.headers',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.http2Route.match.headers', props);
    return resource.getResponseField('route.spec.http2Route.match.headers') as unknown as shapes.AppMeshHttpRouteHeader[];
  }

  public get method(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.http2Route.match.method'),
        outputPath: 'route.spec.http2Route.match.method',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.http2Route.match.method', props);
    return resource.getResponseField('route.spec.http2Route.match.method') as unknown as string;
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.http2Route.match.prefix'),
        outputPath: 'route.spec.http2Route.match.prefix',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.http2Route.match.prefix', props);
    return resource.getResponseField('route.spec.http2Route.match.prefix') as unknown as string;
  }

  public get scheme(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.http2Route.match.scheme'),
        outputPath: 'route.spec.http2Route.match.scheme',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.http2Route.match.scheme', props);
    return resource.getResponseField('route.spec.http2Route.match.scheme') as unknown as string;
  }

}

export class AppMeshResponsesUpdateRouteRouteSpecHttp2RouteRetryPolicy {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get httpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.http2Route.retryPolicy.httpRetryEvents'),
        outputPath: 'route.spec.http2Route.retryPolicy.httpRetryEvents',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.http2Route.retryPolicy.httpRetryEvents', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.httpRetryEvents') as unknown as string[];
  }

  public get maxRetries(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.http2Route.retryPolicy.maxRetries'),
        outputPath: 'route.spec.http2Route.retryPolicy.maxRetries',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.http2Route.retryPolicy.maxRetries', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.maxRetries') as unknown as number;
  }

  public get perRetryTimeout(): AppMeshResponsesUpdateRouteRouteSpecHttp2RouteRetryPolicyPerRetryTimeout {
    return new AppMeshResponsesUpdateRouteRouteSpecHttp2RouteRetryPolicyPerRetryTimeout(this.__scope, this.__resources, this.__input);
  }

  public get tcpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.http2Route.retryPolicy.tcpRetryEvents'),
        outputPath: 'route.spec.http2Route.retryPolicy.tcpRetryEvents',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.http2Route.retryPolicy.tcpRetryEvents', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.tcpRetryEvents') as unknown as string[];
  }

}

export class AppMeshResponsesUpdateRouteRouteSpecHttp2RouteRetryPolicyPerRetryTimeout {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.unit'),
        outputPath: 'route.spec.http2Route.retryPolicy.perRetryTimeout.unit',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.unit', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.perRetryTimeout.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.value'),
        outputPath: 'route.spec.http2Route.retryPolicy.perRetryTimeout.value',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.http2Route.retryPolicy.perRetryTimeout.value', props);
    return resource.getResponseField('route.spec.http2Route.retryPolicy.perRetryTimeout.value') as unknown as number;
  }

}

export class AppMeshResponsesUpdateRouteRouteSpecHttp2RouteTimeout {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get idle(): AppMeshResponsesUpdateRouteRouteSpecHttp2RouteTimeoutIdle {
    return new AppMeshResponsesUpdateRouteRouteSpecHttp2RouteTimeoutIdle(this.__scope, this.__resources, this.__input);
  }

  public get perRequest(): AppMeshResponsesUpdateRouteRouteSpecHttp2RouteTimeoutPerRequest {
    return new AppMeshResponsesUpdateRouteRouteSpecHttp2RouteTimeoutPerRequest(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateRouteRouteSpecHttp2RouteTimeoutIdle {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.http2Route.timeout.idle.unit'),
        outputPath: 'route.spec.http2Route.timeout.idle.unit',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.http2Route.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.http2Route.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.http2Route.timeout.idle.value'),
        outputPath: 'route.spec.http2Route.timeout.idle.value',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.http2Route.timeout.idle.value', props);
    return resource.getResponseField('route.spec.http2Route.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshResponsesUpdateRouteRouteSpecHttp2RouteTimeoutPerRequest {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.http2Route.timeout.perRequest.unit'),
        outputPath: 'route.spec.http2Route.timeout.perRequest.unit',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.http2Route.timeout.perRequest.unit', props);
    return resource.getResponseField('route.spec.http2Route.timeout.perRequest.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.http2Route.timeout.perRequest.value'),
        outputPath: 'route.spec.http2Route.timeout.perRequest.value',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.http2Route.timeout.perRequest.value', props);
    return resource.getResponseField('route.spec.http2Route.timeout.perRequest.value') as unknown as number;
  }

}

export class AppMeshResponsesUpdateRouteRouteSpecHttpRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get action(): AppMeshResponsesUpdateRouteRouteSpecHttpRouteAction {
    return new AppMeshResponsesUpdateRouteRouteSpecHttpRouteAction(this.__scope, this.__resources, this.__input);
  }

  public get match(): AppMeshResponsesUpdateRouteRouteSpecHttpRouteMatch {
    return new AppMeshResponsesUpdateRouteRouteSpecHttpRouteMatch(this.__scope, this.__resources, this.__input);
  }

  public get retryPolicy(): AppMeshResponsesUpdateRouteRouteSpecHttpRouteRetryPolicy {
    return new AppMeshResponsesUpdateRouteRouteSpecHttpRouteRetryPolicy(this.__scope, this.__resources, this.__input);
  }

  public get timeout(): AppMeshResponsesUpdateRouteRouteSpecHttpRouteTimeout {
    return new AppMeshResponsesUpdateRouteRouteSpecHttpRouteTimeout(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateRouteRouteSpecHttpRouteAction {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.httpRoute.action.weightedTargets'),
        outputPath: 'route.spec.httpRoute.action.weightedTargets',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.httpRoute.action.weightedTargets', props);
    return resource.getResponseField('route.spec.httpRoute.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshResponsesUpdateRouteRouteSpecHttpRouteMatch {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get headers(): shapes.AppMeshHttpRouteHeader[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.httpRoute.match.headers'),
        outputPath: 'route.spec.httpRoute.match.headers',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.httpRoute.match.headers', props);
    return resource.getResponseField('route.spec.httpRoute.match.headers') as unknown as shapes.AppMeshHttpRouteHeader[];
  }

  public get method(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.httpRoute.match.method'),
        outputPath: 'route.spec.httpRoute.match.method',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.httpRoute.match.method', props);
    return resource.getResponseField('route.spec.httpRoute.match.method') as unknown as string;
  }

  public get prefix(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.httpRoute.match.prefix'),
        outputPath: 'route.spec.httpRoute.match.prefix',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.httpRoute.match.prefix', props);
    return resource.getResponseField('route.spec.httpRoute.match.prefix') as unknown as string;
  }

  public get scheme(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.httpRoute.match.scheme'),
        outputPath: 'route.spec.httpRoute.match.scheme',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.httpRoute.match.scheme', props);
    return resource.getResponseField('route.spec.httpRoute.match.scheme') as unknown as string;
  }

}

export class AppMeshResponsesUpdateRouteRouteSpecHttpRouteRetryPolicy {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get httpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.httpRoute.retryPolicy.httpRetryEvents'),
        outputPath: 'route.spec.httpRoute.retryPolicy.httpRetryEvents',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.httpRoute.retryPolicy.httpRetryEvents', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.httpRetryEvents') as unknown as string[];
  }

  public get maxRetries(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.httpRoute.retryPolicy.maxRetries'),
        outputPath: 'route.spec.httpRoute.retryPolicy.maxRetries',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.httpRoute.retryPolicy.maxRetries', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.maxRetries') as unknown as number;
  }

  public get perRetryTimeout(): AppMeshResponsesUpdateRouteRouteSpecHttpRouteRetryPolicyPerRetryTimeout {
    return new AppMeshResponsesUpdateRouteRouteSpecHttpRouteRetryPolicyPerRetryTimeout(this.__scope, this.__resources, this.__input);
  }

  public get tcpRetryEvents(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.httpRoute.retryPolicy.tcpRetryEvents'),
        outputPath: 'route.spec.httpRoute.retryPolicy.tcpRetryEvents',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.httpRoute.retryPolicy.tcpRetryEvents', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.tcpRetryEvents') as unknown as string[];
  }

}

export class AppMeshResponsesUpdateRouteRouteSpecHttpRouteRetryPolicyPerRetryTimeout {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.unit'),
        outputPath: 'route.spec.httpRoute.retryPolicy.perRetryTimeout.unit',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.unit', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.perRetryTimeout.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.value'),
        outputPath: 'route.spec.httpRoute.retryPolicy.perRetryTimeout.value',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.httpRoute.retryPolicy.perRetryTimeout.value', props);
    return resource.getResponseField('route.spec.httpRoute.retryPolicy.perRetryTimeout.value') as unknown as number;
  }

}

export class AppMeshResponsesUpdateRouteRouteSpecHttpRouteTimeout {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get idle(): AppMeshResponsesUpdateRouteRouteSpecHttpRouteTimeoutIdle {
    return new AppMeshResponsesUpdateRouteRouteSpecHttpRouteTimeoutIdle(this.__scope, this.__resources, this.__input);
  }

  public get perRequest(): AppMeshResponsesUpdateRouteRouteSpecHttpRouteTimeoutPerRequest {
    return new AppMeshResponsesUpdateRouteRouteSpecHttpRouteTimeoutPerRequest(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateRouteRouteSpecHttpRouteTimeoutIdle {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.httpRoute.timeout.idle.unit'),
        outputPath: 'route.spec.httpRoute.timeout.idle.unit',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.httpRoute.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.httpRoute.timeout.idle.value'),
        outputPath: 'route.spec.httpRoute.timeout.idle.value',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.httpRoute.timeout.idle.value', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshResponsesUpdateRouteRouteSpecHttpRouteTimeoutPerRequest {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.httpRoute.timeout.perRequest.unit'),
        outputPath: 'route.spec.httpRoute.timeout.perRequest.unit',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.httpRoute.timeout.perRequest.unit', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.perRequest.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.httpRoute.timeout.perRequest.value'),
        outputPath: 'route.spec.httpRoute.timeout.perRequest.value',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.httpRoute.timeout.perRequest.value', props);
    return resource.getResponseField('route.spec.httpRoute.timeout.perRequest.value') as unknown as number;
  }

}

export class AppMeshResponsesUpdateRouteRouteSpecTcpRoute {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get action(): AppMeshResponsesUpdateRouteRouteSpecTcpRouteAction {
    return new AppMeshResponsesUpdateRouteRouteSpecTcpRouteAction(this.__scope, this.__resources, this.__input);
  }

  public get timeout(): AppMeshResponsesUpdateRouteRouteSpecTcpRouteTimeout {
    return new AppMeshResponsesUpdateRouteRouteSpecTcpRouteTimeout(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateRouteRouteSpecTcpRouteAction {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get weightedTargets(): shapes.AppMeshWeightedTarget[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.tcpRoute.action.weightedTargets'),
        outputPath: 'route.spec.tcpRoute.action.weightedTargets',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.tcpRoute.action.weightedTargets', props);
    return resource.getResponseField('route.spec.tcpRoute.action.weightedTargets') as unknown as shapes.AppMeshWeightedTarget[];
  }

}

export class AppMeshResponsesUpdateRouteRouteSpecTcpRouteTimeout {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get idle(): AppMeshResponsesUpdateRouteRouteSpecTcpRouteTimeoutIdle {
    return new AppMeshResponsesUpdateRouteRouteSpecTcpRouteTimeoutIdle(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateRouteRouteSpecTcpRouteTimeoutIdle {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get unit(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.tcpRoute.timeout.idle.unit'),
        outputPath: 'route.spec.tcpRoute.timeout.idle.unit',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.tcpRoute.timeout.idle.unit', props);
    return resource.getResponseField('route.spec.tcpRoute.timeout.idle.unit') as unknown as string;
  }

  public get value(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.spec.tcpRoute.timeout.idle.value'),
        outputPath: 'route.spec.tcpRoute.timeout.idle.value',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.spec.tcpRoute.timeout.idle.value', props);
    return resource.getResponseField('route.spec.tcpRoute.timeout.idle.value') as unknown as number;
  }

}

export class AppMeshResponsesUpdateRouteRouteStatus {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateRouteInput) {
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateRoute',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateRoute.route.status.status'),
        outputPath: 'route.status.status',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          routeName: this.__input.routeName,
          spec: {
            grpcRoute: {
              action: {
                weightedTargets: this.__input.spec.grpcRoute?.action.weightedTargets,
              },
              match: {
                metadata: this.__input.spec.grpcRoute?.match.metadata,
                methodName: this.__input.spec.grpcRoute?.match.methodName,
                serviceName: this.__input.spec.grpcRoute?.match.serviceName,
              },
              retryPolicy: {
                grpcRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.grpcRetryEvents,
                httpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.grpcRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.grpcRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.grpcRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.grpcRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.grpcRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.grpcRoute?.timeout?.perRequest?.value,
                },
              },
            },
            http2Route: {
              action: {
                weightedTargets: this.__input.spec.http2Route?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.http2Route?.match.headers,
                method: this.__input.spec.http2Route?.match.method,
                prefix: this.__input.spec.http2Route?.match.prefix,
                scheme: this.__input.spec.http2Route?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.http2Route?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.http2Route?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.http2Route?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.http2Route?.timeout?.idle?.unit,
                  value: this.__input.spec.http2Route?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.http2Route?.timeout?.perRequest?.unit,
                  value: this.__input.spec.http2Route?.timeout?.perRequest?.value,
                },
              },
            },
            httpRoute: {
              action: {
                weightedTargets: this.__input.spec.httpRoute?.action.weightedTargets,
              },
              match: {
                headers: this.__input.spec.httpRoute?.match.headers,
                method: this.__input.spec.httpRoute?.match.method,
                prefix: this.__input.spec.httpRoute?.match.prefix,
                scheme: this.__input.spec.httpRoute?.match.scheme,
              },
              retryPolicy: {
                httpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.httpRetryEvents,
                maxRetries: this.__input.spec.httpRoute?.retryPolicy?.maxRetries,
                perRetryTimeout: {
                  unit: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.unit,
                  value: this.__input.spec.httpRoute?.retryPolicy?.perRetryTimeout.value,
                },
                tcpRetryEvents: this.__input.spec.httpRoute?.retryPolicy?.tcpRetryEvents,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.httpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.idle?.value,
                },
                perRequest: {
                  unit: this.__input.spec.httpRoute?.timeout?.perRequest?.unit,
                  value: this.__input.spec.httpRoute?.timeout?.perRequest?.value,
                },
              },
            },
            priority: this.__input.spec.priority,
            tcpRoute: {
              action: {
                weightedTargets: this.__input.spec.tcpRoute?.action.weightedTargets,
              },
              timeout: {
                idle: {
                  unit: this.__input.spec.tcpRoute?.timeout?.idle?.unit,
                  value: this.__input.spec.tcpRoute?.timeout?.idle?.value,
                },
              },
            },
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateRoute.route.status.status', props);
    return resource.getResponseField('route.status.status') as unknown as string;
  }

}

export class AppMeshResponsesUpdateVirtualGateway {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualGatewayInput) {
  }

  public get virtualGateway(): AppMeshResponsesUpdateVirtualGatewayVirtualGateway {
    return new AppMeshResponsesUpdateVirtualGatewayVirtualGateway(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateVirtualGatewayVirtualGateway {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualGatewayInput) {
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.meshName'),
        outputPath: 'virtualGateway.meshName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualGateway.virtualGateway.meshName', props);
    return resource.getResponseField('virtualGateway.meshName') as unknown as string;
  }

  public get metadata(): AppMeshResponsesUpdateVirtualGatewayVirtualGatewayMetadata {
    return new AppMeshResponsesUpdateVirtualGatewayVirtualGatewayMetadata(this.__scope, this.__resources, this.__input);
  }

  public get spec(): AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpec {
    return new AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpec(this.__scope, this.__resources, this.__input);
  }

  public get status(): AppMeshResponsesUpdateVirtualGatewayVirtualGatewayStatus {
    return new AppMeshResponsesUpdateVirtualGatewayVirtualGatewayStatus(this.__scope, this.__resources, this.__input);
  }

  public get virtualGatewayName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.virtualGatewayName'),
        outputPath: 'virtualGateway.virtualGatewayName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualGateway.virtualGateway.virtualGatewayName', props);
    return resource.getResponseField('virtualGateway.virtualGatewayName') as unknown as string;
  }

}

export class AppMeshResponsesUpdateVirtualGatewayVirtualGatewayMetadata {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualGatewayInput) {
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.metadata.arn'),
        outputPath: 'virtualGateway.metadata.arn',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualGateway.virtualGateway.metadata.arn', props);
    return resource.getResponseField('virtualGateway.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.metadata.createdAt'),
        outputPath: 'virtualGateway.metadata.createdAt',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualGateway.virtualGateway.metadata.createdAt', props);
    return resource.getResponseField('virtualGateway.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.metadata.lastUpdatedAt'),
        outputPath: 'virtualGateway.metadata.lastUpdatedAt',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualGateway.virtualGateway.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualGateway.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.metadata.meshOwner'),
        outputPath: 'virtualGateway.metadata.meshOwner',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualGateway.virtualGateway.metadata.meshOwner', props);
    return resource.getResponseField('virtualGateway.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.metadata.resourceOwner'),
        outputPath: 'virtualGateway.metadata.resourceOwner',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualGateway.virtualGateway.metadata.resourceOwner', props);
    return resource.getResponseField('virtualGateway.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.metadata.uid'),
        outputPath: 'virtualGateway.metadata.uid',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualGateway.virtualGateway.metadata.uid', props);
    return resource.getResponseField('virtualGateway.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.metadata.version'),
        outputPath: 'virtualGateway.metadata.version',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualGateway.virtualGateway.metadata.version', props);
    return resource.getResponseField('virtualGateway.metadata.version') as unknown as number;
  }

}

export class AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpec {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualGatewayInput) {
  }

  public get backendDefaults(): AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpecBackendDefaults {
    return new AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpecBackendDefaults(this.__scope, this.__resources, this.__input);
  }

  public get listeners(): shapes.AppMeshVirtualGatewayListener[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.spec.listeners'),
        outputPath: 'virtualGateway.spec.listeners',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualGateway.virtualGateway.spec.listeners', props);
    return resource.getResponseField('virtualGateway.spec.listeners') as unknown as shapes.AppMeshVirtualGatewayListener[];
  }

  public get logging(): AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpecLogging {
    return new AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpecLogging(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpecBackendDefaults {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualGatewayInput) {
  }

  public get clientPolicy(): AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicy {
    return new AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicy(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicy {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualGatewayInput) {
  }

  public get tls(): AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTls {
    return new AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTls(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTls {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualGatewayInput) {
  }

  public get enforce(): boolean {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.enforce') as unknown as boolean;
  }

  public get ports(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.ports'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.ports',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.ports', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.ports') as unknown as number[];
  }

  public get validation(): AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation {
    return new AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualGatewayInput) {
  }

  public get trust(): AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust {
    return new AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualGatewayInput) {
  }

  public get acm(): AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
    return new AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm(this.__scope, this.__resources, this.__input);
  }

  public get file(): AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile {
    return new AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualGatewayInput) {
  }

  public get certificateAuthorityArns(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns') as unknown as string[];
  }

}

export class AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualGatewayInput) {
  }

  public get certificateChain(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain'),
        outputPath: 'virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualGateway.virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain', props);
    return resource.getResponseField('virtualGateway.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain') as unknown as string;
  }

}

export class AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpecLogging {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualGatewayInput) {
  }

  public get accessLog(): AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpecLoggingAccessLog {
    return new AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpecLoggingAccessLog(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpecLoggingAccessLog {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualGatewayInput) {
  }

  public get file(): AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpecLoggingAccessLogFile {
    return new AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpecLoggingAccessLogFile(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateVirtualGatewayVirtualGatewaySpecLoggingAccessLogFile {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualGatewayInput) {
  }

  public get path(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.spec.logging.accessLog.file.path'),
        outputPath: 'virtualGateway.spec.logging.accessLog.file.path',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualGateway.virtualGateway.spec.logging.accessLog.file.path', props);
    return resource.getResponseField('virtualGateway.spec.logging.accessLog.file.path') as unknown as string;
  }

}

export class AppMeshResponsesUpdateVirtualGatewayVirtualGatewayStatus {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualGatewayInput) {
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualGateway',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualGateway.virtualGateway.status.status'),
        outputPath: 'virtualGateway.status.status',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
          },
          virtualGatewayName: this.__input.virtualGatewayName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualGateway.virtualGateway.status.status', props);
    return resource.getResponseField('virtualGateway.status.status') as unknown as string;
  }

}

export class AppMeshResponsesUpdateVirtualNode {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualNodeInput) {
  }

  public get virtualNode(): AppMeshResponsesUpdateVirtualNodeVirtualNode {
    return new AppMeshResponsesUpdateVirtualNodeVirtualNode(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateVirtualNodeVirtualNode {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualNodeInput) {
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.meshName'),
        outputPath: 'virtualNode.meshName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualNode.virtualNode.meshName', props);
    return resource.getResponseField('virtualNode.meshName') as unknown as string;
  }

  public get metadata(): AppMeshResponsesUpdateVirtualNodeVirtualNodeMetadata {
    return new AppMeshResponsesUpdateVirtualNodeVirtualNodeMetadata(this.__scope, this.__resources, this.__input);
  }

  public get spec(): AppMeshResponsesUpdateVirtualNodeVirtualNodeSpec {
    return new AppMeshResponsesUpdateVirtualNodeVirtualNodeSpec(this.__scope, this.__resources, this.__input);
  }

  public get status(): AppMeshResponsesUpdateVirtualNodeVirtualNodeStatus {
    return new AppMeshResponsesUpdateVirtualNodeVirtualNodeStatus(this.__scope, this.__resources, this.__input);
  }

  public get virtualNodeName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.virtualNodeName'),
        outputPath: 'virtualNode.virtualNodeName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualNode.virtualNode.virtualNodeName', props);
    return resource.getResponseField('virtualNode.virtualNodeName') as unknown as string;
  }

}

export class AppMeshResponsesUpdateVirtualNodeVirtualNodeMetadata {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualNodeInput) {
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.metadata.arn'),
        outputPath: 'virtualNode.metadata.arn',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualNode.virtualNode.metadata.arn', props);
    return resource.getResponseField('virtualNode.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.metadata.createdAt'),
        outputPath: 'virtualNode.metadata.createdAt',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualNode.virtualNode.metadata.createdAt', props);
    return resource.getResponseField('virtualNode.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.metadata.lastUpdatedAt'),
        outputPath: 'virtualNode.metadata.lastUpdatedAt',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualNode.virtualNode.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualNode.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.metadata.meshOwner'),
        outputPath: 'virtualNode.metadata.meshOwner',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualNode.virtualNode.metadata.meshOwner', props);
    return resource.getResponseField('virtualNode.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.metadata.resourceOwner'),
        outputPath: 'virtualNode.metadata.resourceOwner',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualNode.virtualNode.metadata.resourceOwner', props);
    return resource.getResponseField('virtualNode.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.metadata.uid'),
        outputPath: 'virtualNode.metadata.uid',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualNode.virtualNode.metadata.uid', props);
    return resource.getResponseField('virtualNode.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.metadata.version'),
        outputPath: 'virtualNode.metadata.version',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualNode.virtualNode.metadata.version', props);
    return resource.getResponseField('virtualNode.metadata.version') as unknown as number;
  }

}

export class AppMeshResponsesUpdateVirtualNodeVirtualNodeSpec {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualNodeInput) {
  }

  public get backendDefaults(): AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecBackendDefaults {
    return new AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecBackendDefaults(this.__scope, this.__resources, this.__input);
  }

  public get backends(): shapes.AppMeshBackend[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.spec.backends'),
        outputPath: 'virtualNode.spec.backends',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualNode.virtualNode.spec.backends', props);
    return resource.getResponseField('virtualNode.spec.backends') as unknown as shapes.AppMeshBackend[];
  }

  public get listeners(): shapes.AppMeshListener[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.spec.listeners'),
        outputPath: 'virtualNode.spec.listeners',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualNode.virtualNode.spec.listeners', props);
    return resource.getResponseField('virtualNode.spec.listeners') as unknown as shapes.AppMeshListener[];
  }

  public get logging(): AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecLogging {
    return new AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecLogging(this.__scope, this.__resources, this.__input);
  }

  public get serviceDiscovery(): AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecServiceDiscovery {
    return new AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecServiceDiscovery(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecBackendDefaults {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualNodeInput) {
  }

  public get clientPolicy(): AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicy {
    return new AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicy(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicy {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualNodeInput) {
  }

  public get tls(): AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTls {
    return new AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTls(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTls {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualNodeInput) {
  }

  public get enforce(): boolean {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.enforce'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.enforce',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.enforce', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.enforce') as unknown as boolean;
  }

  public get ports(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.ports'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.ports',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.ports', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.ports') as unknown as number[];
  }

  public get validation(): AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidation {
    return new AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidation(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidation {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualNodeInput) {
  }

  public get trust(): AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust {
    return new AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualNodeInput) {
  }

  public get acm(): AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
    return new AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm(this.__scope, this.__resources, this.__input);
  }

  public get file(): AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile {
    return new AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualNodeInput) {
  }

  public get certificateAuthorityArns(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.acm.certificateAuthorityArns') as unknown as string[];
  }

}

export class AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualNodeInput) {
  }

  public get certificateChain(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain'),
        outputPath: 'virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualNode.virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain', props);
    return resource.getResponseField('virtualNode.spec.backendDefaults.clientPolicy.tls.validation.trust.file.certificateChain') as unknown as string;
  }

}

export class AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecLogging {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualNodeInput) {
  }

  public get accessLog(): AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecLoggingAccessLog {
    return new AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecLoggingAccessLog(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecLoggingAccessLog {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualNodeInput) {
  }

  public get file(): AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecLoggingAccessLogFile {
    return new AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecLoggingAccessLogFile(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecLoggingAccessLogFile {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualNodeInput) {
  }

  public get path(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.spec.logging.accessLog.file.path'),
        outputPath: 'virtualNode.spec.logging.accessLog.file.path',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualNode.virtualNode.spec.logging.accessLog.file.path', props);
    return resource.getResponseField('virtualNode.spec.logging.accessLog.file.path') as unknown as string;
  }

}

export class AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecServiceDiscovery {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualNodeInput) {
  }

  public get awsCloudMap(): AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecServiceDiscoveryAwsCloudMap {
    return new AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecServiceDiscoveryAwsCloudMap(this.__scope, this.__resources, this.__input);
  }

  public get dns(): AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecServiceDiscoveryDns {
    return new AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecServiceDiscoveryDns(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecServiceDiscoveryAwsCloudMap {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualNodeInput) {
  }

  public get attributes(): shapes.AppMeshAwsCloudMapInstanceAttribute[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.attributes'),
        outputPath: 'virtualNode.spec.serviceDiscovery.awsCloudMap.attributes',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.attributes', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.awsCloudMap.attributes') as unknown as shapes.AppMeshAwsCloudMapInstanceAttribute[];
  }

  public get namespaceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName'),
        outputPath: 'virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.awsCloudMap.namespaceName') as unknown as string;
  }

  public get serviceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName'),
        outputPath: 'virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualNode.virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.awsCloudMap.serviceName') as unknown as string;
  }

}

export class AppMeshResponsesUpdateVirtualNodeVirtualNodeSpecServiceDiscoveryDns {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualNodeInput) {
  }

  public get hostname(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.spec.serviceDiscovery.dns.hostname'),
        outputPath: 'virtualNode.spec.serviceDiscovery.dns.hostname',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualNode.virtualNode.spec.serviceDiscovery.dns.hostname', props);
    return resource.getResponseField('virtualNode.spec.serviceDiscovery.dns.hostname') as unknown as string;
  }

}

export class AppMeshResponsesUpdateVirtualNodeVirtualNodeStatus {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualNodeInput) {
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualNode',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualNode.virtualNode.status.status'),
        outputPath: 'virtualNode.status.status',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            backendDefaults: {
              clientPolicy: {
                tls: {
                  enforce: this.__input.spec.backendDefaults?.clientPolicy?.tls?.enforce,
                  ports: this.__input.spec.backendDefaults?.clientPolicy?.tls?.ports,
                  validation: {
                    trust: {
                      acm: {
                        certificateAuthorityArns: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.acm?.certificateAuthorityArns,
                      },
                      file: {
                        certificateChain: this.__input.spec.backendDefaults?.clientPolicy?.tls?.validation.trust.file?.certificateChain,
                      },
                    },
                  },
                },
              },
            },
            backends: this.__input.spec.backends,
            listeners: this.__input.spec.listeners,
            logging: {
              accessLog: {
                file: {
                  path: this.__input.spec.logging?.accessLog?.file?.path,
                },
              },
            },
            serviceDiscovery: {
              awsCloudMap: {
                attributes: this.__input.spec.serviceDiscovery?.awsCloudMap?.attributes,
                namespaceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.namespaceName,
                serviceName: this.__input.spec.serviceDiscovery?.awsCloudMap?.serviceName,
              },
              dns: {
                hostname: this.__input.spec.serviceDiscovery?.dns?.hostname,
              },
            },
          },
          virtualNodeName: this.__input.virtualNodeName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualNode.virtualNode.status.status', props);
    return resource.getResponseField('virtualNode.status.status') as unknown as string;
  }

}

export class AppMeshResponsesUpdateVirtualRouter {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualRouterInput) {
  }

  public get virtualRouter(): AppMeshResponsesUpdateVirtualRouterVirtualRouter {
    return new AppMeshResponsesUpdateVirtualRouterVirtualRouter(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateVirtualRouterVirtualRouter {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualRouterInput) {
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualRouter.virtualRouter.meshName'),
        outputPath: 'virtualRouter.meshName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            listeners: this.__input.spec.listeners,
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualRouter.virtualRouter.meshName', props);
    return resource.getResponseField('virtualRouter.meshName') as unknown as string;
  }

  public get metadata(): AppMeshResponsesUpdateVirtualRouterVirtualRouterMetadata {
    return new AppMeshResponsesUpdateVirtualRouterVirtualRouterMetadata(this.__scope, this.__resources, this.__input);
  }

  public get spec(): AppMeshResponsesUpdateVirtualRouterVirtualRouterSpec {
    return new AppMeshResponsesUpdateVirtualRouterVirtualRouterSpec(this.__scope, this.__resources, this.__input);
  }

  public get status(): AppMeshResponsesUpdateVirtualRouterVirtualRouterStatus {
    return new AppMeshResponsesUpdateVirtualRouterVirtualRouterStatus(this.__scope, this.__resources, this.__input);
  }

  public get virtualRouterName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualRouter.virtualRouter.virtualRouterName'),
        outputPath: 'virtualRouter.virtualRouterName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            listeners: this.__input.spec.listeners,
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualRouter.virtualRouter.virtualRouterName', props);
    return resource.getResponseField('virtualRouter.virtualRouterName') as unknown as string;
  }

}

export class AppMeshResponsesUpdateVirtualRouterVirtualRouterMetadata {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualRouterInput) {
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualRouter.virtualRouter.metadata.arn'),
        outputPath: 'virtualRouter.metadata.arn',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            listeners: this.__input.spec.listeners,
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualRouter.virtualRouter.metadata.arn', props);
    return resource.getResponseField('virtualRouter.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualRouter.virtualRouter.metadata.createdAt'),
        outputPath: 'virtualRouter.metadata.createdAt',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            listeners: this.__input.spec.listeners,
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualRouter.virtualRouter.metadata.createdAt', props);
    return resource.getResponseField('virtualRouter.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualRouter.virtualRouter.metadata.lastUpdatedAt'),
        outputPath: 'virtualRouter.metadata.lastUpdatedAt',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            listeners: this.__input.spec.listeners,
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualRouter.virtualRouter.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualRouter.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualRouter.virtualRouter.metadata.meshOwner'),
        outputPath: 'virtualRouter.metadata.meshOwner',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            listeners: this.__input.spec.listeners,
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualRouter.virtualRouter.metadata.meshOwner', props);
    return resource.getResponseField('virtualRouter.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualRouter.virtualRouter.metadata.resourceOwner'),
        outputPath: 'virtualRouter.metadata.resourceOwner',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            listeners: this.__input.spec.listeners,
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualRouter.virtualRouter.metadata.resourceOwner', props);
    return resource.getResponseField('virtualRouter.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualRouter.virtualRouter.metadata.uid'),
        outputPath: 'virtualRouter.metadata.uid',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            listeners: this.__input.spec.listeners,
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualRouter.virtualRouter.metadata.uid', props);
    return resource.getResponseField('virtualRouter.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualRouter.virtualRouter.metadata.version'),
        outputPath: 'virtualRouter.metadata.version',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            listeners: this.__input.spec.listeners,
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualRouter.virtualRouter.metadata.version', props);
    return resource.getResponseField('virtualRouter.metadata.version') as unknown as number;
  }

}

export class AppMeshResponsesUpdateVirtualRouterVirtualRouterSpec {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualRouterInput) {
  }

  public get listeners(): shapes.AppMeshVirtualRouterListener[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualRouter.virtualRouter.spec.listeners'),
        outputPath: 'virtualRouter.spec.listeners',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            listeners: this.__input.spec.listeners,
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualRouter.virtualRouter.spec.listeners', props);
    return resource.getResponseField('virtualRouter.spec.listeners') as unknown as shapes.AppMeshVirtualRouterListener[];
  }

}

export class AppMeshResponsesUpdateVirtualRouterVirtualRouterStatus {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualRouterInput) {
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualRouter',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualRouter.virtualRouter.status.status'),
        outputPath: 'virtualRouter.status.status',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            listeners: this.__input.spec.listeners,
          },
          virtualRouterName: this.__input.virtualRouterName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualRouter.virtualRouter.status.status', props);
    return resource.getResponseField('virtualRouter.status.status') as unknown as string;
  }

}

export class AppMeshResponsesUpdateVirtualService {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualServiceInput) {
  }

  public get virtualService(): AppMeshResponsesUpdateVirtualServiceVirtualService {
    return new AppMeshResponsesUpdateVirtualServiceVirtualService(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateVirtualServiceVirtualService {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualServiceInput) {
  }

  public get meshName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualService.virtualService.meshName'),
        outputPath: 'virtualService.meshName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.__input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.__input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualService.virtualService.meshName', props);
    return resource.getResponseField('virtualService.meshName') as unknown as string;
  }

  public get metadata(): AppMeshResponsesUpdateVirtualServiceVirtualServiceMetadata {
    return new AppMeshResponsesUpdateVirtualServiceVirtualServiceMetadata(this.__scope, this.__resources, this.__input);
  }

  public get spec(): AppMeshResponsesUpdateVirtualServiceVirtualServiceSpec {
    return new AppMeshResponsesUpdateVirtualServiceVirtualServiceSpec(this.__scope, this.__resources, this.__input);
  }

  public get status(): AppMeshResponsesUpdateVirtualServiceVirtualServiceStatus {
    return new AppMeshResponsesUpdateVirtualServiceVirtualServiceStatus(this.__scope, this.__resources, this.__input);
  }

  public get virtualServiceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualService.virtualService.virtualServiceName'),
        outputPath: 'virtualService.virtualServiceName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.__input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.__input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualService.virtualService.virtualServiceName', props);
    return resource.getResponseField('virtualService.virtualServiceName') as unknown as string;
  }

}

export class AppMeshResponsesUpdateVirtualServiceVirtualServiceMetadata {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualServiceInput) {
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualService.virtualService.metadata.arn'),
        outputPath: 'virtualService.metadata.arn',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.__input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.__input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualService.virtualService.metadata.arn', props);
    return resource.getResponseField('virtualService.metadata.arn') as unknown as string;
  }

  public get createdAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualService.virtualService.metadata.createdAt'),
        outputPath: 'virtualService.metadata.createdAt',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.__input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.__input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualService.virtualService.metadata.createdAt', props);
    return resource.getResponseField('virtualService.metadata.createdAt') as unknown as string;
  }

  public get lastUpdatedAt(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualService.virtualService.metadata.lastUpdatedAt'),
        outputPath: 'virtualService.metadata.lastUpdatedAt',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.__input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.__input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualService.virtualService.metadata.lastUpdatedAt', props);
    return resource.getResponseField('virtualService.metadata.lastUpdatedAt') as unknown as string;
  }

  public get meshOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualService.virtualService.metadata.meshOwner'),
        outputPath: 'virtualService.metadata.meshOwner',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.__input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.__input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualService.virtualService.metadata.meshOwner', props);
    return resource.getResponseField('virtualService.metadata.meshOwner') as unknown as string;
  }

  public get resourceOwner(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualService.virtualService.metadata.resourceOwner'),
        outputPath: 'virtualService.metadata.resourceOwner',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.__input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.__input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualService.virtualService.metadata.resourceOwner', props);
    return resource.getResponseField('virtualService.metadata.resourceOwner') as unknown as string;
  }

  public get uid(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualService.virtualService.metadata.uid'),
        outputPath: 'virtualService.metadata.uid',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.__input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.__input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualService.virtualService.metadata.uid', props);
    return resource.getResponseField('virtualService.metadata.uid') as unknown as string;
  }

  public get version(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualService.virtualService.metadata.version'),
        outputPath: 'virtualService.metadata.version',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.__input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.__input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualService.virtualService.metadata.version', props);
    return resource.getResponseField('virtualService.metadata.version') as unknown as number;
  }

}

export class AppMeshResponsesUpdateVirtualServiceVirtualServiceSpec {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualServiceInput) {
  }

  public get provider(): AppMeshResponsesUpdateVirtualServiceVirtualServiceSpecProvider {
    return new AppMeshResponsesUpdateVirtualServiceVirtualServiceSpecProvider(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateVirtualServiceVirtualServiceSpecProvider {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualServiceInput) {
  }

  public get virtualNode(): AppMeshResponsesUpdateVirtualServiceVirtualServiceSpecProviderVirtualNode {
    return new AppMeshResponsesUpdateVirtualServiceVirtualServiceSpecProviderVirtualNode(this.__scope, this.__resources, this.__input);
  }

  public get virtualRouter(): AppMeshResponsesUpdateVirtualServiceVirtualServiceSpecProviderVirtualRouter {
    return new AppMeshResponsesUpdateVirtualServiceVirtualServiceSpecProviderVirtualRouter(this.__scope, this.__resources, this.__input);
  }

}

export class AppMeshResponsesUpdateVirtualServiceVirtualServiceSpecProviderVirtualNode {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualServiceInput) {
  }

  public get virtualNodeName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualService.virtualService.spec.provider.virtualNode.virtualNodeName'),
        outputPath: 'virtualService.spec.provider.virtualNode.virtualNodeName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.__input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.__input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualService.virtualService.spec.provider.virtualNode.virtualNodeName', props);
    return resource.getResponseField('virtualService.spec.provider.virtualNode.virtualNodeName') as unknown as string;
  }

}

export class AppMeshResponsesUpdateVirtualServiceVirtualServiceSpecProviderVirtualRouter {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualServiceInput) {
  }

  public get virtualRouterName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualService.virtualService.spec.provider.virtualRouter.virtualRouterName'),
        outputPath: 'virtualService.spec.provider.virtualRouter.virtualRouterName',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.__input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.__input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualService.virtualService.spec.provider.virtualRouter.virtualRouterName', props);
    return resource.getResponseField('virtualService.spec.provider.virtualRouter.virtualRouterName') as unknown as string;
  }

}

export class AppMeshResponsesUpdateVirtualServiceVirtualServiceStatus {

  constructor(private readonly __scope: cdk.Construct, private readonly __resources: string[], private readonly __input: shapes.AppMeshUpdateVirtualServiceInput) {
  }

  public get status(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateVirtualService',
        service: 'AppMesh',
        physicalResourceId: cr.PhysicalResourceId.of('AppMesh.UpdateVirtualService.virtualService.status.status'),
        outputPath: 'virtualService.status.status',
        parameters: {
          clientToken: this.__input.clientToken,
          meshName: this.__input.meshName,
          meshOwner: this.__input.meshOwner,
          spec: {
            provider: {
              virtualNode: {
                virtualNodeName: this.__input.spec.provider?.virtualNode?.virtualNodeName,
              },
              virtualRouter: {
                virtualRouterName: this.__input.spec.provider?.virtualRouter?.virtualRouterName,
              },
            },
          },
          virtualServiceName: this.__input.virtualServiceName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this.__scope, 'UpdateVirtualService.virtualService.status.status', props);
    return resource.getResponseField('virtualService.status.status') as unknown as string;
  }

}


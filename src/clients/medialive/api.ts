import * as cdk from '@aws-cdk/core';
import * as cr from '@aws-cdk/custom-resources';
import * as shapes from './shapes';

export class MediaLiveClient extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[]) {
    super(scope, id);
  }

  public acceptInputDeviceTransfer(input: shapes.MediaLiveAcceptInputDeviceTransferRequest): void {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'acceptInputDeviceTransfer',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.AcceptInputDeviceTransfer'),
        parameters: {
          InputDeviceId: input.inputDeviceId,
        },
      },
    };
    new cr.AwsCustomResource(this, 'AcceptInputDeviceTransfer', props);
  }

  public batchDelete(input: shapes.MediaLiveBatchDeleteRequest): MediaLiveBatchDelete {
    return new MediaLiveBatchDelete(this, 'BatchDelete', this.__resources, input);
  }

  public batchStart(input: shapes.MediaLiveBatchStartRequest): MediaLiveBatchStart {
    return new MediaLiveBatchStart(this, 'BatchStart', this.__resources, input);
  }

  public batchStop(input: shapes.MediaLiveBatchStopRequest): MediaLiveBatchStop {
    return new MediaLiveBatchStop(this, 'BatchStop', this.__resources, input);
  }

  public batchUpdateSchedule(input: shapes.MediaLiveBatchUpdateScheduleRequest): MediaLiveBatchUpdateSchedule {
    return new MediaLiveBatchUpdateSchedule(this, 'BatchUpdateSchedule', this.__resources, input);
  }

  public cancelInputDeviceTransfer(input: shapes.MediaLiveCancelInputDeviceTransferRequest): void {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'cancelInputDeviceTransfer',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CancelInputDeviceTransfer'),
        parameters: {
          InputDeviceId: input.inputDeviceId,
        },
      },
    };
    new cr.AwsCustomResource(this, 'CancelInputDeviceTransfer', props);
  }

  public createChannel(input: shapes.MediaLiveCreateChannelRequest): MediaLiveCreateChannel {
    return new MediaLiveCreateChannel(this, 'CreateChannel', this.__resources, input);
  }

  public createInput(input: shapes.MediaLiveCreateInputRequest): MediaLiveCreateInput {
    return new MediaLiveCreateInput(this, 'CreateInput', this.__resources, input);
  }

  public createInputSecurityGroup(input: shapes.MediaLiveCreateInputSecurityGroupRequest): MediaLiveCreateInputSecurityGroup {
    return new MediaLiveCreateInputSecurityGroup(this, 'CreateInputSecurityGroup', this.__resources, input);
  }

  public createMultiplex(input: shapes.MediaLiveCreateMultiplexRequest): MediaLiveCreateMultiplex {
    return new MediaLiveCreateMultiplex(this, 'CreateMultiplex', this.__resources, input);
  }

  public createMultiplexProgram(input: shapes.MediaLiveCreateMultiplexProgramRequest): MediaLiveCreateMultiplexProgram {
    return new MediaLiveCreateMultiplexProgram(this, 'CreateMultiplexProgram', this.__resources, input);
  }

  public createTags(input: shapes.MediaLiveCreateTagsRequest): void {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createTags',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateTags'),
        parameters: {
          ResourceArn: input.resourceArn,
          Tags: input.tags,
        },
      },
    };
    new cr.AwsCustomResource(this, 'CreateTags', props);
  }

  public deleteChannel(input: shapes.MediaLiveDeleteChannelRequest): MediaLiveDeleteChannel {
    return new MediaLiveDeleteChannel(this, 'DeleteChannel', this.__resources, input);
  }

  public deleteInput(input: shapes.MediaLiveDeleteInputRequest): void {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteInput'),
        parameters: {
          InputId: input.inputId,
        },
      },
    };
    new cr.AwsCustomResource(this, 'DeleteInput', props);
  }

  public deleteInputSecurityGroup(input: shapes.MediaLiveDeleteInputSecurityGroupRequest): void {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteInputSecurityGroup',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteInputSecurityGroup'),
        parameters: {
          InputSecurityGroupId: input.inputSecurityGroupId,
        },
      },
    };
    new cr.AwsCustomResource(this, 'DeleteInputSecurityGroup', props);
  }

  public deleteMultiplex(input: shapes.MediaLiveDeleteMultiplexRequest): MediaLiveDeleteMultiplex {
    return new MediaLiveDeleteMultiplex(this, 'DeleteMultiplex', this.__resources, input);
  }

  public deleteMultiplexProgram(input: shapes.MediaLiveDeleteMultiplexProgramRequest): MediaLiveDeleteMultiplexProgram {
    return new MediaLiveDeleteMultiplexProgram(this, 'DeleteMultiplexProgram', this.__resources, input);
  }

  public deleteReservation(input: shapes.MediaLiveDeleteReservationRequest): MediaLiveDeleteReservation {
    return new MediaLiveDeleteReservation(this, 'DeleteReservation', this.__resources, input);
  }

  public deleteSchedule(input: shapes.MediaLiveDeleteScheduleRequest): void {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteSchedule',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteSchedule'),
        parameters: {
          ChannelId: input.channelId,
        },
      },
    };
    new cr.AwsCustomResource(this, 'DeleteSchedule', props);
  }

  public deleteTags(input: shapes.MediaLiveDeleteTagsRequest): void {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteTags',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteTags'),
        parameters: {
          ResourceArn: input.resourceArn,
          TagKeys: input.tagKeys,
        },
      },
    };
    new cr.AwsCustomResource(this, 'DeleteTags', props);
  }

  public describeChannel(input: shapes.MediaLiveDescribeChannelRequest): MediaLiveDescribeChannel {
    return new MediaLiveDescribeChannel(this, 'DescribeChannel', this.__resources, input);
  }

  public describeInput(input: shapes.MediaLiveDescribeInputRequest): MediaLiveDescribeInput {
    return new MediaLiveDescribeInput(this, 'DescribeInput', this.__resources, input);
  }

  public describeInputDevice(input: shapes.MediaLiveDescribeInputDeviceRequest): MediaLiveDescribeInputDevice {
    return new MediaLiveDescribeInputDevice(this, 'DescribeInputDevice', this.__resources, input);
  }

  public describeInputDeviceThumbnail(input: shapes.MediaLiveDescribeInputDeviceThumbnailRequest): MediaLiveDescribeInputDeviceThumbnail {
    return new MediaLiveDescribeInputDeviceThumbnail(this, 'DescribeInputDeviceThumbnail', this.__resources, input);
  }

  public describeInputSecurityGroup(input: shapes.MediaLiveDescribeInputSecurityGroupRequest): MediaLiveDescribeInputSecurityGroup {
    return new MediaLiveDescribeInputSecurityGroup(this, 'DescribeInputSecurityGroup', this.__resources, input);
  }

  public describeMultiplex(input: shapes.MediaLiveDescribeMultiplexRequest): MediaLiveDescribeMultiplex {
    return new MediaLiveDescribeMultiplex(this, 'DescribeMultiplex', this.__resources, input);
  }

  public describeMultiplexProgram(input: shapes.MediaLiveDescribeMultiplexProgramRequest): MediaLiveDescribeMultiplexProgram {
    return new MediaLiveDescribeMultiplexProgram(this, 'DescribeMultiplexProgram', this.__resources, input);
  }

  public describeOffering(input: shapes.MediaLiveDescribeOfferingRequest): MediaLiveDescribeOffering {
    return new MediaLiveDescribeOffering(this, 'DescribeOffering', this.__resources, input);
  }

  public describeReservation(input: shapes.MediaLiveDescribeReservationRequest): MediaLiveDescribeReservation {
    return new MediaLiveDescribeReservation(this, 'DescribeReservation', this.__resources, input);
  }

  public describeSchedule(input: shapes.MediaLiveDescribeScheduleRequest): MediaLiveDescribeSchedule {
    return new MediaLiveDescribeSchedule(this, 'DescribeSchedule', this.__resources, input);
  }

  public listChannels(input: shapes.MediaLiveListChannelsRequest): MediaLiveListChannels {
    return new MediaLiveListChannels(this, 'ListChannels', this.__resources, input);
  }

  public listInputDeviceTransfers(input: shapes.MediaLiveListInputDeviceTransfersRequest): MediaLiveListInputDeviceTransfers {
    return new MediaLiveListInputDeviceTransfers(this, 'ListInputDeviceTransfers', this.__resources, input);
  }

  public listInputDevices(input: shapes.MediaLiveListInputDevicesRequest): MediaLiveListInputDevices {
    return new MediaLiveListInputDevices(this, 'ListInputDevices', this.__resources, input);
  }

  public listInputSecurityGroups(input: shapes.MediaLiveListInputSecurityGroupsRequest): MediaLiveListInputSecurityGroups {
    return new MediaLiveListInputSecurityGroups(this, 'ListInputSecurityGroups', this.__resources, input);
  }

  public listInputs(input: shapes.MediaLiveListInputsRequest): MediaLiveListInputs {
    return new MediaLiveListInputs(this, 'ListInputs', this.__resources, input);
  }

  public listMultiplexPrograms(input: shapes.MediaLiveListMultiplexProgramsRequest): MediaLiveListMultiplexPrograms {
    return new MediaLiveListMultiplexPrograms(this, 'ListMultiplexPrograms', this.__resources, input);
  }

  public listMultiplexes(input: shapes.MediaLiveListMultiplexesRequest): MediaLiveListMultiplexes {
    return new MediaLiveListMultiplexes(this, 'ListMultiplexes', this.__resources, input);
  }

  public listOfferings(input: shapes.MediaLiveListOfferingsRequest): MediaLiveListOfferings {
    return new MediaLiveListOfferings(this, 'ListOfferings', this.__resources, input);
  }

  public listReservations(input: shapes.MediaLiveListReservationsRequest): MediaLiveListReservations {
    return new MediaLiveListReservations(this, 'ListReservations', this.__resources, input);
  }

  public listTagsForResource(input: shapes.MediaLiveListTagsForResourceRequest): MediaLiveListTagsForResource {
    return new MediaLiveListTagsForResource(this, 'ListTagsForResource', this.__resources, input);
  }

  public purchaseOffering(input: shapes.MediaLivePurchaseOfferingRequest): MediaLivePurchaseOffering {
    return new MediaLivePurchaseOffering(this, 'PurchaseOffering', this.__resources, input);
  }

  public rejectInputDeviceTransfer(input: shapes.MediaLiveRejectInputDeviceTransferRequest): void {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'rejectInputDeviceTransfer',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.RejectInputDeviceTransfer'),
        parameters: {
          InputDeviceId: input.inputDeviceId,
        },
      },
    };
    new cr.AwsCustomResource(this, 'RejectInputDeviceTransfer', props);
  }

  public startChannel(input: shapes.MediaLiveStartChannelRequest): MediaLiveStartChannel {
    return new MediaLiveStartChannel(this, 'StartChannel', this.__resources, input);
  }

  public startMultiplex(input: shapes.MediaLiveStartMultiplexRequest): MediaLiveStartMultiplex {
    return new MediaLiveStartMultiplex(this, 'StartMultiplex', this.__resources, input);
  }

  public stopChannel(input: shapes.MediaLiveStopChannelRequest): MediaLiveStopChannel {
    return new MediaLiveStopChannel(this, 'StopChannel', this.__resources, input);
  }

  public stopMultiplex(input: shapes.MediaLiveStopMultiplexRequest): MediaLiveStopMultiplex {
    return new MediaLiveStopMultiplex(this, 'StopMultiplex', this.__resources, input);
  }

  public transferInputDevice(input: shapes.MediaLiveTransferInputDeviceRequest): void {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'transferInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.TransferInputDevice'),
        parameters: {
          InputDeviceId: input.inputDeviceId,
          TargetCustomerId: input.targetCustomerId,
          TransferMessage: input.transferMessage,
        },
      },
    };
    new cr.AwsCustomResource(this, 'TransferInputDevice', props);
  }

  public updateChannel(input: shapes.MediaLiveUpdateChannelRequest): MediaLiveUpdateChannel {
    return new MediaLiveUpdateChannel(this, 'UpdateChannel', this.__resources, input);
  }

  public updateChannelClass(input: shapes.MediaLiveUpdateChannelClassRequest): MediaLiveUpdateChannelClass {
    return new MediaLiveUpdateChannelClass(this, 'UpdateChannelClass', this.__resources, input);
  }

  public updateInput(input: shapes.MediaLiveUpdateInputRequest): MediaLiveUpdateInput {
    return new MediaLiveUpdateInput(this, 'UpdateInput', this.__resources, input);
  }

  public updateInputDevice(input: shapes.MediaLiveUpdateInputDeviceRequest): MediaLiveUpdateInputDevice {
    return new MediaLiveUpdateInputDevice(this, 'UpdateInputDevice', this.__resources, input);
  }

  public updateInputSecurityGroup(input: shapes.MediaLiveUpdateInputSecurityGroupRequest): MediaLiveUpdateInputSecurityGroup {
    return new MediaLiveUpdateInputSecurityGroup(this, 'UpdateInputSecurityGroup', this.__resources, input);
  }

  public updateMultiplex(input: shapes.MediaLiveUpdateMultiplexRequest): MediaLiveUpdateMultiplex {
    return new MediaLiveUpdateMultiplex(this, 'UpdateMultiplex', this.__resources, input);
  }

  public updateMultiplexProgram(input: shapes.MediaLiveUpdateMultiplexProgramRequest): MediaLiveUpdateMultiplexProgram {
    return new MediaLiveUpdateMultiplexProgram(this, 'UpdateMultiplexProgram', this.__resources, input);
  }

  public updateReservation(input: shapes.MediaLiveUpdateReservationRequest): MediaLiveUpdateReservation {
    return new MediaLiveUpdateReservation(this, 'UpdateReservation', this.__resources, input);
  }

}

export class MediaLiveBatchDelete extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveBatchDeleteRequest) {
    super(scope, id);
  }

  public get failed(): shapes.MediaLiveBatchFailedResultModel[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'batchDelete',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.BatchDelete.Failed'),
        outputPath: 'Failed',
        parameters: {
          ChannelIds: this.input.channelIds,
          InputIds: this.input.inputIds,
          InputSecurityGroupIds: this.input.inputSecurityGroupIds,
          MultiplexIds: this.input.multiplexIds,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'BatchDelete.Failed', props);
    return resource.getResponseField('Failed') as unknown as shapes.MediaLiveBatchFailedResultModel[];
  }

  public get successful(): shapes.MediaLiveBatchSuccessfulResultModel[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'batchDelete',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.BatchDelete.Successful'),
        outputPath: 'Successful',
        parameters: {
          ChannelIds: this.input.channelIds,
          InputIds: this.input.inputIds,
          InputSecurityGroupIds: this.input.inputSecurityGroupIds,
          MultiplexIds: this.input.multiplexIds,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'BatchDelete.Successful', props);
    return resource.getResponseField('Successful') as unknown as shapes.MediaLiveBatchSuccessfulResultModel[];
  }

}

export class MediaLiveBatchStart extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveBatchStartRequest) {
    super(scope, id);
  }

  public get failed(): shapes.MediaLiveBatchFailedResultModel[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'batchStart',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.BatchStart.Failed'),
        outputPath: 'Failed',
        parameters: {
          ChannelIds: this.input.channelIds,
          MultiplexIds: this.input.multiplexIds,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'BatchStart.Failed', props);
    return resource.getResponseField('Failed') as unknown as shapes.MediaLiveBatchFailedResultModel[];
  }

  public get successful(): shapes.MediaLiveBatchSuccessfulResultModel[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'batchStart',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.BatchStart.Successful'),
        outputPath: 'Successful',
        parameters: {
          ChannelIds: this.input.channelIds,
          MultiplexIds: this.input.multiplexIds,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'BatchStart.Successful', props);
    return resource.getResponseField('Successful') as unknown as shapes.MediaLiveBatchSuccessfulResultModel[];
  }

}

export class MediaLiveBatchStop extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveBatchStopRequest) {
    super(scope, id);
  }

  public get failed(): shapes.MediaLiveBatchFailedResultModel[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'batchStop',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.BatchStop.Failed'),
        outputPath: 'Failed',
        parameters: {
          ChannelIds: this.input.channelIds,
          MultiplexIds: this.input.multiplexIds,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'BatchStop.Failed', props);
    return resource.getResponseField('Failed') as unknown as shapes.MediaLiveBatchFailedResultModel[];
  }

  public get successful(): shapes.MediaLiveBatchSuccessfulResultModel[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'batchStop',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.BatchStop.Successful'),
        outputPath: 'Successful',
        parameters: {
          ChannelIds: this.input.channelIds,
          MultiplexIds: this.input.multiplexIds,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'BatchStop.Successful', props);
    return resource.getResponseField('Successful') as unknown as shapes.MediaLiveBatchSuccessfulResultModel[];
  }

}

export class MediaLiveBatchUpdateSchedule extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveBatchUpdateScheduleRequest) {
    super(scope, id);
  }

  public get creates(): MediaLiveBatchUpdateScheduleCreates {
    return new MediaLiveBatchUpdateScheduleCreates(this, 'Creates', this.__resources, this.input);
  }

  public get deletes(): MediaLiveBatchUpdateScheduleDeletes {
    return new MediaLiveBatchUpdateScheduleDeletes(this, 'Deletes', this.__resources, this.input);
  }

}

export class MediaLiveBatchUpdateScheduleCreates extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveBatchUpdateScheduleRequest) {
    super(scope, id);
  }

  public get scheduleActions(): shapes.MediaLiveScheduleAction[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'batchUpdateSchedule',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.BatchUpdateSchedule.Creates.ScheduleActions'),
        outputPath: 'Creates.ScheduleActions',
        parameters: {
          ChannelId: this.input.channelId,
          Creates: {
            ScheduleActions: this.input.creates?.scheduleActions,
          },
          Deletes: {
            ActionNames: this.input.deletes?.actionNames,
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'BatchUpdateSchedule.Creates.ScheduleActions', props);
    return resource.getResponseField('Creates.ScheduleActions') as unknown as shapes.MediaLiveScheduleAction[];
  }

}

export class MediaLiveBatchUpdateScheduleDeletes extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveBatchUpdateScheduleRequest) {
    super(scope, id);
  }

  public get scheduleActions(): shapes.MediaLiveScheduleAction[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'batchUpdateSchedule',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.BatchUpdateSchedule.Deletes.ScheduleActions'),
        outputPath: 'Deletes.ScheduleActions',
        parameters: {
          ChannelId: this.input.channelId,
          Creates: {
            ScheduleActions: this.input.creates?.scheduleActions,
          },
          Deletes: {
            ActionNames: this.input.deletes?.actionNames,
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'BatchUpdateSchedule.Deletes.ScheduleActions', props);
    return resource.getResponseField('Deletes.ScheduleActions') as unknown as shapes.MediaLiveScheduleAction[];
  }

}

export class MediaLiveCreateChannel extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateChannelRequest) {
    super(scope, id);
  }

  public get channel(): MediaLiveCreateChannelChannel {
    return new MediaLiveCreateChannelChannel(this, 'Channel', this.__resources, this.input);
  }

}

export class MediaLiveCreateChannelChannel extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateChannelRequest) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.Arn'),
        outputPath: 'Channel.Arn',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.Arn', props);
    return resource.getResponseField('Channel.Arn') as unknown as string;
  }

  public get cdiInputSpecification(): MediaLiveCreateChannelChannelCdiInputSpecification {
    return new MediaLiveCreateChannelChannelCdiInputSpecification(this, 'CdiInputSpecification', this.__resources, this.input);
  }

  public get channelClass(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.ChannelClass'),
        outputPath: 'Channel.ChannelClass',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.ChannelClass', props);
    return resource.getResponseField('Channel.ChannelClass') as unknown as string;
  }

  public get destinations(): shapes.MediaLiveOutputDestination[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.Destinations'),
        outputPath: 'Channel.Destinations',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.Destinations', props);
    return resource.getResponseField('Channel.Destinations') as unknown as shapes.MediaLiveOutputDestination[];
  }

  public get egressEndpoints(): shapes.MediaLiveChannelEgressEndpoint[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EgressEndpoints'),
        outputPath: 'Channel.EgressEndpoints',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EgressEndpoints', props);
    return resource.getResponseField('Channel.EgressEndpoints') as unknown as shapes.MediaLiveChannelEgressEndpoint[];
  }

  public get encoderSettings(): MediaLiveCreateChannelChannelEncoderSettings {
    return new MediaLiveCreateChannelChannelEncoderSettings(this, 'EncoderSettings', this.__resources, this.input);
  }

  public get id(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.Id'),
        outputPath: 'Channel.Id',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.Id', props);
    return resource.getResponseField('Channel.Id') as unknown as string;
  }

  public get inputAttachments(): shapes.MediaLiveInputAttachment[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.InputAttachments'),
        outputPath: 'Channel.InputAttachments',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.InputAttachments', props);
    return resource.getResponseField('Channel.InputAttachments') as unknown as shapes.MediaLiveInputAttachment[];
  }

  public get inputSpecification(): MediaLiveCreateChannelChannelInputSpecification {
    return new MediaLiveCreateChannelChannelInputSpecification(this, 'InputSpecification', this.__resources, this.input);
  }

  public get logLevel(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.LogLevel'),
        outputPath: 'Channel.LogLevel',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.LogLevel', props);
    return resource.getResponseField('Channel.LogLevel') as unknown as string;
  }

  public get name(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.Name'),
        outputPath: 'Channel.Name',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.Name', props);
    return resource.getResponseField('Channel.Name') as unknown as string;
  }

  public get pipelineDetails(): shapes.MediaLivePipelineDetail[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.PipelineDetails'),
        outputPath: 'Channel.PipelineDetails',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.PipelineDetails', props);
    return resource.getResponseField('Channel.PipelineDetails') as unknown as shapes.MediaLivePipelineDetail[];
  }

  public get pipelinesRunningCount(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.PipelinesRunningCount'),
        outputPath: 'Channel.PipelinesRunningCount',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.PipelinesRunningCount', props);
    return resource.getResponseField('Channel.PipelinesRunningCount') as unknown as number;
  }

  public get roleArn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.RoleArn'),
        outputPath: 'Channel.RoleArn',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.RoleArn', props);
    return resource.getResponseField('Channel.RoleArn') as unknown as string;
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.State'),
        outputPath: 'Channel.State',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.State', props);
    return resource.getResponseField('Channel.State') as unknown as string;
  }

  public get tags(): Record<string, string> {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.Tags'),
        outputPath: 'Channel.Tags',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.Tags', props);
    return resource.getResponseField('Channel.Tags') as unknown as Record<string, string>;
  }

}

export class MediaLiveCreateChannelChannelCdiInputSpecification extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateChannelRequest) {
    super(scope, id);
  }

  public get resolution(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.CdiInputSpecification.Resolution'),
        outputPath: 'Channel.CdiInputSpecification.Resolution',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.CdiInputSpecification.Resolution', props);
    return resource.getResponseField('Channel.CdiInputSpecification.Resolution') as unknown as string;
  }

}

export class MediaLiveCreateChannelChannelEncoderSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateChannelRequest) {
    super(scope, id);
  }

  public get audioDescriptions(): shapes.MediaLiveAudioDescription[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.AudioDescriptions'),
        outputPath: 'Channel.EncoderSettings.AudioDescriptions',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.AudioDescriptions', props);
    return resource.getResponseField('Channel.EncoderSettings.AudioDescriptions') as unknown as shapes.MediaLiveAudioDescription[];
  }

  public get availBlanking(): MediaLiveCreateChannelChannelEncoderSettingsAvailBlanking {
    return new MediaLiveCreateChannelChannelEncoderSettingsAvailBlanking(this, 'AvailBlanking', this.__resources, this.input);
  }

  public get availConfiguration(): MediaLiveCreateChannelChannelEncoderSettingsAvailConfiguration {
    return new MediaLiveCreateChannelChannelEncoderSettingsAvailConfiguration(this, 'AvailConfiguration', this.__resources, this.input);
  }

  public get blackoutSlate(): MediaLiveCreateChannelChannelEncoderSettingsBlackoutSlate {
    return new MediaLiveCreateChannelChannelEncoderSettingsBlackoutSlate(this, 'BlackoutSlate', this.__resources, this.input);
  }

  public get captionDescriptions(): shapes.MediaLiveCaptionDescription[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.CaptionDescriptions'),
        outputPath: 'Channel.EncoderSettings.CaptionDescriptions',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.CaptionDescriptions', props);
    return resource.getResponseField('Channel.EncoderSettings.CaptionDescriptions') as unknown as shapes.MediaLiveCaptionDescription[];
  }

  public get featureActivations(): MediaLiveCreateChannelChannelEncoderSettingsFeatureActivations {
    return new MediaLiveCreateChannelChannelEncoderSettingsFeatureActivations(this, 'FeatureActivations', this.__resources, this.input);
  }

  public get globalConfiguration(): MediaLiveCreateChannelChannelEncoderSettingsGlobalConfiguration {
    return new MediaLiveCreateChannelChannelEncoderSettingsGlobalConfiguration(this, 'GlobalConfiguration', this.__resources, this.input);
  }

  public get nielsenConfiguration(): MediaLiveCreateChannelChannelEncoderSettingsNielsenConfiguration {
    return new MediaLiveCreateChannelChannelEncoderSettingsNielsenConfiguration(this, 'NielsenConfiguration', this.__resources, this.input);
  }

  public get outputGroups(): shapes.MediaLiveOutputGroup[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.OutputGroups'),
        outputPath: 'Channel.EncoderSettings.OutputGroups',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.OutputGroups', props);
    return resource.getResponseField('Channel.EncoderSettings.OutputGroups') as unknown as shapes.MediaLiveOutputGroup[];
  }

  public get timecodeConfig(): MediaLiveCreateChannelChannelEncoderSettingsTimecodeConfig {
    return new MediaLiveCreateChannelChannelEncoderSettingsTimecodeConfig(this, 'TimecodeConfig', this.__resources, this.input);
  }

  public get videoDescriptions(): shapes.MediaLiveVideoDescription[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.VideoDescriptions'),
        outputPath: 'Channel.EncoderSettings.VideoDescriptions',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.VideoDescriptions', props);
    return resource.getResponseField('Channel.EncoderSettings.VideoDescriptions') as unknown as shapes.MediaLiveVideoDescription[];
  }

}

export class MediaLiveCreateChannelChannelEncoderSettingsAvailBlanking extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateChannelRequest) {
    super(scope, id);
  }

  public get availBlankingImage(): MediaLiveCreateChannelChannelEncoderSettingsAvailBlankingAvailBlankingImage {
    return new MediaLiveCreateChannelChannelEncoderSettingsAvailBlankingAvailBlankingImage(this, 'AvailBlankingImage', this.__resources, this.input);
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.AvailBlanking.State'),
        outputPath: 'Channel.EncoderSettings.AvailBlanking.State',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.AvailBlanking.State', props);
    return resource.getResponseField('Channel.EncoderSettings.AvailBlanking.State') as unknown as string;
  }

}

export class MediaLiveCreateChannelChannelEncoderSettingsAvailBlankingAvailBlankingImage extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateChannelRequest) {
    super(scope, id);
  }

  public get passwordParam(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.PasswordParam'),
        outputPath: 'Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.PasswordParam',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.PasswordParam', props);
    return resource.getResponseField('Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.PasswordParam') as unknown as string;
  }

  public get uri(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.Uri'),
        outputPath: 'Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.Uri',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.Uri', props);
    return resource.getResponseField('Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.Uri') as unknown as string;
  }

  public get username(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.Username'),
        outputPath: 'Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.Username',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.Username', props);
    return resource.getResponseField('Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.Username') as unknown as string;
  }

}

export class MediaLiveCreateChannelChannelEncoderSettingsAvailConfiguration extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateChannelRequest) {
    super(scope, id);
  }

  public get availSettings(): MediaLiveCreateChannelChannelEncoderSettingsAvailConfigurationAvailSettings {
    return new MediaLiveCreateChannelChannelEncoderSettingsAvailConfigurationAvailSettings(this, 'AvailSettings', this.__resources, this.input);
  }

}

export class MediaLiveCreateChannelChannelEncoderSettingsAvailConfigurationAvailSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateChannelRequest) {
    super(scope, id);
  }

  public get scte35SpliceInsert(): MediaLiveCreateChannelChannelEncoderSettingsAvailConfigurationAvailSettingsScte35SpliceInsert {
    return new MediaLiveCreateChannelChannelEncoderSettingsAvailConfigurationAvailSettingsScte35SpliceInsert(this, 'Scte35SpliceInsert', this.__resources, this.input);
  }

  public get scte35TimeSignalApos(): MediaLiveCreateChannelChannelEncoderSettingsAvailConfigurationAvailSettingsScte35TimeSignalApos {
    return new MediaLiveCreateChannelChannelEncoderSettingsAvailConfigurationAvailSettingsScte35TimeSignalApos(this, 'Scte35TimeSignalApos', this.__resources, this.input);
  }

}

export class MediaLiveCreateChannelChannelEncoderSettingsAvailConfigurationAvailSettingsScte35SpliceInsert extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateChannelRequest) {
    super(scope, id);
  }

  public get adAvailOffset(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.AdAvailOffset'),
        outputPath: 'Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.AdAvailOffset',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.AdAvailOffset', props);
    return resource.getResponseField('Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.AdAvailOffset') as unknown as number;
  }

  public get noRegionalBlackoutFlag(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.NoRegionalBlackoutFlag'),
        outputPath: 'Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.NoRegionalBlackoutFlag',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.NoRegionalBlackoutFlag', props);
    return resource.getResponseField('Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.NoRegionalBlackoutFlag') as unknown as string;
  }

  public get webDeliveryAllowedFlag(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.WebDeliveryAllowedFlag'),
        outputPath: 'Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.WebDeliveryAllowedFlag',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.WebDeliveryAllowedFlag', props);
    return resource.getResponseField('Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.WebDeliveryAllowedFlag') as unknown as string;
  }

}

export class MediaLiveCreateChannelChannelEncoderSettingsAvailConfigurationAvailSettingsScte35TimeSignalApos extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateChannelRequest) {
    super(scope, id);
  }

  public get adAvailOffset(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.AdAvailOffset'),
        outputPath: 'Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.AdAvailOffset',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.AdAvailOffset', props);
    return resource.getResponseField('Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.AdAvailOffset') as unknown as number;
  }

  public get noRegionalBlackoutFlag(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.NoRegionalBlackoutFlag'),
        outputPath: 'Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.NoRegionalBlackoutFlag',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.NoRegionalBlackoutFlag', props);
    return resource.getResponseField('Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.NoRegionalBlackoutFlag') as unknown as string;
  }

  public get webDeliveryAllowedFlag(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.WebDeliveryAllowedFlag'),
        outputPath: 'Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.WebDeliveryAllowedFlag',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.WebDeliveryAllowedFlag', props);
    return resource.getResponseField('Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.WebDeliveryAllowedFlag') as unknown as string;
  }

}

export class MediaLiveCreateChannelChannelEncoderSettingsBlackoutSlate extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateChannelRequest) {
    super(scope, id);
  }

  public get blackoutSlateImage(): MediaLiveCreateChannelChannelEncoderSettingsBlackoutSlateBlackoutSlateImage {
    return new MediaLiveCreateChannelChannelEncoderSettingsBlackoutSlateBlackoutSlateImage(this, 'BlackoutSlateImage', this.__resources, this.input);
  }

  public get networkEndBlackout(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackout'),
        outputPath: 'Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackout',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackout', props);
    return resource.getResponseField('Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackout') as unknown as string;
  }

  public get networkEndBlackoutImage(): MediaLiveCreateChannelChannelEncoderSettingsBlackoutSlateNetworkEndBlackoutImage {
    return new MediaLiveCreateChannelChannelEncoderSettingsBlackoutSlateNetworkEndBlackoutImage(this, 'NetworkEndBlackoutImage', this.__resources, this.input);
  }

  public get networkId(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.BlackoutSlate.NetworkId'),
        outputPath: 'Channel.EncoderSettings.BlackoutSlate.NetworkId',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.BlackoutSlate.NetworkId', props);
    return resource.getResponseField('Channel.EncoderSettings.BlackoutSlate.NetworkId') as unknown as string;
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.BlackoutSlate.State'),
        outputPath: 'Channel.EncoderSettings.BlackoutSlate.State',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.BlackoutSlate.State', props);
    return resource.getResponseField('Channel.EncoderSettings.BlackoutSlate.State') as unknown as string;
  }

}

export class MediaLiveCreateChannelChannelEncoderSettingsBlackoutSlateBlackoutSlateImage extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateChannelRequest) {
    super(scope, id);
  }

  public get passwordParam(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.PasswordParam'),
        outputPath: 'Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.PasswordParam',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.PasswordParam', props);
    return resource.getResponseField('Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.PasswordParam') as unknown as string;
  }

  public get uri(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Uri'),
        outputPath: 'Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Uri',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Uri', props);
    return resource.getResponseField('Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Uri') as unknown as string;
  }

  public get username(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Username'),
        outputPath: 'Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Username',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Username', props);
    return resource.getResponseField('Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Username') as unknown as string;
  }

}

export class MediaLiveCreateChannelChannelEncoderSettingsBlackoutSlateNetworkEndBlackoutImage extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateChannelRequest) {
    super(scope, id);
  }

  public get passwordParam(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.PasswordParam'),
        outputPath: 'Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.PasswordParam',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.PasswordParam', props);
    return resource.getResponseField('Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.PasswordParam') as unknown as string;
  }

  public get uri(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Uri'),
        outputPath: 'Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Uri',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Uri', props);
    return resource.getResponseField('Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Uri') as unknown as string;
  }

  public get username(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Username'),
        outputPath: 'Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Username',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Username', props);
    return resource.getResponseField('Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Username') as unknown as string;
  }

}

export class MediaLiveCreateChannelChannelEncoderSettingsFeatureActivations extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateChannelRequest) {
    super(scope, id);
  }

  public get inputPrepareScheduleActions(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.FeatureActivations.InputPrepareScheduleActions'),
        outputPath: 'Channel.EncoderSettings.FeatureActivations.InputPrepareScheduleActions',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.FeatureActivations.InputPrepareScheduleActions', props);
    return resource.getResponseField('Channel.EncoderSettings.FeatureActivations.InputPrepareScheduleActions') as unknown as string;
  }

}

export class MediaLiveCreateChannelChannelEncoderSettingsGlobalConfiguration extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateChannelRequest) {
    super(scope, id);
  }

  public get initialAudioGain(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.GlobalConfiguration.InitialAudioGain'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.InitialAudioGain',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.GlobalConfiguration.InitialAudioGain', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.InitialAudioGain') as unknown as number;
  }

  public get inputEndAction(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.GlobalConfiguration.InputEndAction'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.InputEndAction',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.GlobalConfiguration.InputEndAction', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.InputEndAction') as unknown as string;
  }

  public get inputLossBehavior(): MediaLiveCreateChannelChannelEncoderSettingsGlobalConfigurationInputLossBehavior {
    return new MediaLiveCreateChannelChannelEncoderSettingsGlobalConfigurationInputLossBehavior(this, 'InputLossBehavior', this.__resources, this.input);
  }

  public get outputLockingMode(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.GlobalConfiguration.OutputLockingMode'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.OutputLockingMode',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.GlobalConfiguration.OutputLockingMode', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.OutputLockingMode') as unknown as string;
  }

  public get outputTimingSource(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.GlobalConfiguration.OutputTimingSource'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.OutputTimingSource',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.GlobalConfiguration.OutputTimingSource', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.OutputTimingSource') as unknown as string;
  }

  public get supportLowFramerateInputs(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.GlobalConfiguration.SupportLowFramerateInputs'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.SupportLowFramerateInputs',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.GlobalConfiguration.SupportLowFramerateInputs', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.SupportLowFramerateInputs') as unknown as string;
  }

}

export class MediaLiveCreateChannelChannelEncoderSettingsGlobalConfigurationInputLossBehavior extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateChannelRequest) {
    super(scope, id);
  }

  public get blackFrameMsec(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.BlackFrameMsec'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.BlackFrameMsec',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.BlackFrameMsec', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.BlackFrameMsec') as unknown as number;
  }

  public get inputLossImageColor(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageColor'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageColor',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageColor', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageColor') as unknown as string;
  }

  public get inputLossImageSlate(): MediaLiveCreateChannelChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate {
    return new MediaLiveCreateChannelChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate(this, 'InputLossImageSlate', this.__resources, this.input);
  }

  public get inputLossImageType(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageType'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageType',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageType', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageType') as unknown as string;
  }

  public get repeatFrameMsec(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.RepeatFrameMsec'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.RepeatFrameMsec',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.RepeatFrameMsec', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.RepeatFrameMsec') as unknown as number;
  }

}

export class MediaLiveCreateChannelChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateChannelRequest) {
    super(scope, id);
  }

  public get passwordParam(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.PasswordParam'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.PasswordParam',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.PasswordParam', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.PasswordParam') as unknown as string;
  }

  public get uri(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Uri'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Uri',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Uri', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Uri') as unknown as string;
  }

  public get username(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Username'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Username',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Username', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Username') as unknown as string;
  }

}

export class MediaLiveCreateChannelChannelEncoderSettingsNielsenConfiguration extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateChannelRequest) {
    super(scope, id);
  }

  public get distributorId(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.NielsenConfiguration.DistributorId'),
        outputPath: 'Channel.EncoderSettings.NielsenConfiguration.DistributorId',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.NielsenConfiguration.DistributorId', props);
    return resource.getResponseField('Channel.EncoderSettings.NielsenConfiguration.DistributorId') as unknown as string;
  }

  public get nielsenPcmToId3Tagging(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.NielsenConfiguration.NielsenPcmToId3Tagging'),
        outputPath: 'Channel.EncoderSettings.NielsenConfiguration.NielsenPcmToId3Tagging',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.NielsenConfiguration.NielsenPcmToId3Tagging', props);
    return resource.getResponseField('Channel.EncoderSettings.NielsenConfiguration.NielsenPcmToId3Tagging') as unknown as string;
  }

}

export class MediaLiveCreateChannelChannelEncoderSettingsTimecodeConfig extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateChannelRequest) {
    super(scope, id);
  }

  public get source(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.TimecodeConfig.Source'),
        outputPath: 'Channel.EncoderSettings.TimecodeConfig.Source',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.TimecodeConfig.Source', props);
    return resource.getResponseField('Channel.EncoderSettings.TimecodeConfig.Source') as unknown as string;
  }

  public get syncThreshold(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.EncoderSettings.TimecodeConfig.SyncThreshold'),
        outputPath: 'Channel.EncoderSettings.TimecodeConfig.SyncThreshold',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.EncoderSettings.TimecodeConfig.SyncThreshold', props);
    return resource.getResponseField('Channel.EncoderSettings.TimecodeConfig.SyncThreshold') as unknown as number;
  }

}

export class MediaLiveCreateChannelChannelInputSpecification extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateChannelRequest) {
    super(scope, id);
  }

  public get codec(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.InputSpecification.Codec'),
        outputPath: 'Channel.InputSpecification.Codec',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.InputSpecification.Codec', props);
    return resource.getResponseField('Channel.InputSpecification.Codec') as unknown as string;
  }

  public get maximumBitrate(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.InputSpecification.MaximumBitrate'),
        outputPath: 'Channel.InputSpecification.MaximumBitrate',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.InputSpecification.MaximumBitrate', props);
    return resource.getResponseField('Channel.InputSpecification.MaximumBitrate') as unknown as string;
  }

  public get resolution(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateChannel.Channel.InputSpecification.Resolution'),
        outputPath: 'Channel.InputSpecification.Resolution',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelClass: this.input.channelClass,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RequestId: this.input.requestId,
          Reserved: this.input.reserved,
          RoleArn: this.input.roleArn,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateChannel.Channel.InputSpecification.Resolution', props);
    return resource.getResponseField('Channel.InputSpecification.Resolution') as unknown as string;
  }

}

export class MediaLiveCreateInput extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateInputRequest) {
    super(scope, id);
  }

  public get input(): MediaLiveCreateInputInput {
    return new MediaLiveCreateInputInput(this, 'Input', this.__resources, this.input);
  }

}

export class MediaLiveCreateInputInput extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateInputRequest) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateInput.Input.Arn'),
        outputPath: 'Input.Arn',
        parameters: {
          Destinations: this.input.destinations,
          InputDevices: this.input.inputDevices,
          InputSecurityGroups: this.input.inputSecurityGroups,
          MediaConnectFlows: this.input.mediaConnectFlows,
          Name: this.input.name,
          RequestId: this.input.requestId,
          RoleArn: this.input.roleArn,
          Sources: this.input.sources,
          Tags: this.input.tags,
          Type: this.input.type,
          Vpc: {
            SecurityGroupIds: this.input.vpc?.securityGroupIds,
            SubnetIds: this.input.vpc?.subnetIds,
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateInput.Input.Arn', props);
    return resource.getResponseField('Input.Arn') as unknown as string;
  }

  public get attachedChannels(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateInput.Input.AttachedChannels'),
        outputPath: 'Input.AttachedChannels',
        parameters: {
          Destinations: this.input.destinations,
          InputDevices: this.input.inputDevices,
          InputSecurityGroups: this.input.inputSecurityGroups,
          MediaConnectFlows: this.input.mediaConnectFlows,
          Name: this.input.name,
          RequestId: this.input.requestId,
          RoleArn: this.input.roleArn,
          Sources: this.input.sources,
          Tags: this.input.tags,
          Type: this.input.type,
          Vpc: {
            SecurityGroupIds: this.input.vpc?.securityGroupIds,
            SubnetIds: this.input.vpc?.subnetIds,
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateInput.Input.AttachedChannels', props);
    return resource.getResponseField('Input.AttachedChannels') as unknown as string[];
  }

  public get destinations(): shapes.MediaLiveInputDestination[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateInput.Input.Destinations'),
        outputPath: 'Input.Destinations',
        parameters: {
          Destinations: this.input.destinations,
          InputDevices: this.input.inputDevices,
          InputSecurityGroups: this.input.inputSecurityGroups,
          MediaConnectFlows: this.input.mediaConnectFlows,
          Name: this.input.name,
          RequestId: this.input.requestId,
          RoleArn: this.input.roleArn,
          Sources: this.input.sources,
          Tags: this.input.tags,
          Type: this.input.type,
          Vpc: {
            SecurityGroupIds: this.input.vpc?.securityGroupIds,
            SubnetIds: this.input.vpc?.subnetIds,
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateInput.Input.Destinations', props);
    return resource.getResponseField('Input.Destinations') as unknown as shapes.MediaLiveInputDestination[];
  }

  public get id(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateInput.Input.Id'),
        outputPath: 'Input.Id',
        parameters: {
          Destinations: this.input.destinations,
          InputDevices: this.input.inputDevices,
          InputSecurityGroups: this.input.inputSecurityGroups,
          MediaConnectFlows: this.input.mediaConnectFlows,
          Name: this.input.name,
          RequestId: this.input.requestId,
          RoleArn: this.input.roleArn,
          Sources: this.input.sources,
          Tags: this.input.tags,
          Type: this.input.type,
          Vpc: {
            SecurityGroupIds: this.input.vpc?.securityGroupIds,
            SubnetIds: this.input.vpc?.subnetIds,
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateInput.Input.Id', props);
    return resource.getResponseField('Input.Id') as unknown as string;
  }

  public get inputClass(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateInput.Input.InputClass'),
        outputPath: 'Input.InputClass',
        parameters: {
          Destinations: this.input.destinations,
          InputDevices: this.input.inputDevices,
          InputSecurityGroups: this.input.inputSecurityGroups,
          MediaConnectFlows: this.input.mediaConnectFlows,
          Name: this.input.name,
          RequestId: this.input.requestId,
          RoleArn: this.input.roleArn,
          Sources: this.input.sources,
          Tags: this.input.tags,
          Type: this.input.type,
          Vpc: {
            SecurityGroupIds: this.input.vpc?.securityGroupIds,
            SubnetIds: this.input.vpc?.subnetIds,
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateInput.Input.InputClass', props);
    return resource.getResponseField('Input.InputClass') as unknown as string;
  }

  public get inputDevices(): shapes.MediaLiveInputDeviceSettings[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateInput.Input.InputDevices'),
        outputPath: 'Input.InputDevices',
        parameters: {
          Destinations: this.input.destinations,
          InputDevices: this.input.inputDevices,
          InputSecurityGroups: this.input.inputSecurityGroups,
          MediaConnectFlows: this.input.mediaConnectFlows,
          Name: this.input.name,
          RequestId: this.input.requestId,
          RoleArn: this.input.roleArn,
          Sources: this.input.sources,
          Tags: this.input.tags,
          Type: this.input.type,
          Vpc: {
            SecurityGroupIds: this.input.vpc?.securityGroupIds,
            SubnetIds: this.input.vpc?.subnetIds,
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateInput.Input.InputDevices', props);
    return resource.getResponseField('Input.InputDevices') as unknown as shapes.MediaLiveInputDeviceSettings[];
  }

  public get inputSourceType(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateInput.Input.InputSourceType'),
        outputPath: 'Input.InputSourceType',
        parameters: {
          Destinations: this.input.destinations,
          InputDevices: this.input.inputDevices,
          InputSecurityGroups: this.input.inputSecurityGroups,
          MediaConnectFlows: this.input.mediaConnectFlows,
          Name: this.input.name,
          RequestId: this.input.requestId,
          RoleArn: this.input.roleArn,
          Sources: this.input.sources,
          Tags: this.input.tags,
          Type: this.input.type,
          Vpc: {
            SecurityGroupIds: this.input.vpc?.securityGroupIds,
            SubnetIds: this.input.vpc?.subnetIds,
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateInput.Input.InputSourceType', props);
    return resource.getResponseField('Input.InputSourceType') as unknown as string;
  }

  public get mediaConnectFlows(): shapes.MediaLiveMediaConnectFlow[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateInput.Input.MediaConnectFlows'),
        outputPath: 'Input.MediaConnectFlows',
        parameters: {
          Destinations: this.input.destinations,
          InputDevices: this.input.inputDevices,
          InputSecurityGroups: this.input.inputSecurityGroups,
          MediaConnectFlows: this.input.mediaConnectFlows,
          Name: this.input.name,
          RequestId: this.input.requestId,
          RoleArn: this.input.roleArn,
          Sources: this.input.sources,
          Tags: this.input.tags,
          Type: this.input.type,
          Vpc: {
            SecurityGroupIds: this.input.vpc?.securityGroupIds,
            SubnetIds: this.input.vpc?.subnetIds,
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateInput.Input.MediaConnectFlows', props);
    return resource.getResponseField('Input.MediaConnectFlows') as unknown as shapes.MediaLiveMediaConnectFlow[];
  }

  public get name(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateInput.Input.Name'),
        outputPath: 'Input.Name',
        parameters: {
          Destinations: this.input.destinations,
          InputDevices: this.input.inputDevices,
          InputSecurityGroups: this.input.inputSecurityGroups,
          MediaConnectFlows: this.input.mediaConnectFlows,
          Name: this.input.name,
          RequestId: this.input.requestId,
          RoleArn: this.input.roleArn,
          Sources: this.input.sources,
          Tags: this.input.tags,
          Type: this.input.type,
          Vpc: {
            SecurityGroupIds: this.input.vpc?.securityGroupIds,
            SubnetIds: this.input.vpc?.subnetIds,
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateInput.Input.Name', props);
    return resource.getResponseField('Input.Name') as unknown as string;
  }

  public get roleArn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateInput.Input.RoleArn'),
        outputPath: 'Input.RoleArn',
        parameters: {
          Destinations: this.input.destinations,
          InputDevices: this.input.inputDevices,
          InputSecurityGroups: this.input.inputSecurityGroups,
          MediaConnectFlows: this.input.mediaConnectFlows,
          Name: this.input.name,
          RequestId: this.input.requestId,
          RoleArn: this.input.roleArn,
          Sources: this.input.sources,
          Tags: this.input.tags,
          Type: this.input.type,
          Vpc: {
            SecurityGroupIds: this.input.vpc?.securityGroupIds,
            SubnetIds: this.input.vpc?.subnetIds,
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateInput.Input.RoleArn', props);
    return resource.getResponseField('Input.RoleArn') as unknown as string;
  }

  public get securityGroups(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateInput.Input.SecurityGroups'),
        outputPath: 'Input.SecurityGroups',
        parameters: {
          Destinations: this.input.destinations,
          InputDevices: this.input.inputDevices,
          InputSecurityGroups: this.input.inputSecurityGroups,
          MediaConnectFlows: this.input.mediaConnectFlows,
          Name: this.input.name,
          RequestId: this.input.requestId,
          RoleArn: this.input.roleArn,
          Sources: this.input.sources,
          Tags: this.input.tags,
          Type: this.input.type,
          Vpc: {
            SecurityGroupIds: this.input.vpc?.securityGroupIds,
            SubnetIds: this.input.vpc?.subnetIds,
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateInput.Input.SecurityGroups', props);
    return resource.getResponseField('Input.SecurityGroups') as unknown as string[];
  }

  public get sources(): shapes.MediaLiveInputSource[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateInput.Input.Sources'),
        outputPath: 'Input.Sources',
        parameters: {
          Destinations: this.input.destinations,
          InputDevices: this.input.inputDevices,
          InputSecurityGroups: this.input.inputSecurityGroups,
          MediaConnectFlows: this.input.mediaConnectFlows,
          Name: this.input.name,
          RequestId: this.input.requestId,
          RoleArn: this.input.roleArn,
          Sources: this.input.sources,
          Tags: this.input.tags,
          Type: this.input.type,
          Vpc: {
            SecurityGroupIds: this.input.vpc?.securityGroupIds,
            SubnetIds: this.input.vpc?.subnetIds,
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateInput.Input.Sources', props);
    return resource.getResponseField('Input.Sources') as unknown as shapes.MediaLiveInputSource[];
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateInput.Input.State'),
        outputPath: 'Input.State',
        parameters: {
          Destinations: this.input.destinations,
          InputDevices: this.input.inputDevices,
          InputSecurityGroups: this.input.inputSecurityGroups,
          MediaConnectFlows: this.input.mediaConnectFlows,
          Name: this.input.name,
          RequestId: this.input.requestId,
          RoleArn: this.input.roleArn,
          Sources: this.input.sources,
          Tags: this.input.tags,
          Type: this.input.type,
          Vpc: {
            SecurityGroupIds: this.input.vpc?.securityGroupIds,
            SubnetIds: this.input.vpc?.subnetIds,
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateInput.Input.State', props);
    return resource.getResponseField('Input.State') as unknown as string;
  }

  public get tags(): Record<string, string> {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateInput.Input.Tags'),
        outputPath: 'Input.Tags',
        parameters: {
          Destinations: this.input.destinations,
          InputDevices: this.input.inputDevices,
          InputSecurityGroups: this.input.inputSecurityGroups,
          MediaConnectFlows: this.input.mediaConnectFlows,
          Name: this.input.name,
          RequestId: this.input.requestId,
          RoleArn: this.input.roleArn,
          Sources: this.input.sources,
          Tags: this.input.tags,
          Type: this.input.type,
          Vpc: {
            SecurityGroupIds: this.input.vpc?.securityGroupIds,
            SubnetIds: this.input.vpc?.subnetIds,
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateInput.Input.Tags', props);
    return resource.getResponseField('Input.Tags') as unknown as Record<string, string>;
  }

  public get type(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateInput.Input.Type'),
        outputPath: 'Input.Type',
        parameters: {
          Destinations: this.input.destinations,
          InputDevices: this.input.inputDevices,
          InputSecurityGroups: this.input.inputSecurityGroups,
          MediaConnectFlows: this.input.mediaConnectFlows,
          Name: this.input.name,
          RequestId: this.input.requestId,
          RoleArn: this.input.roleArn,
          Sources: this.input.sources,
          Tags: this.input.tags,
          Type: this.input.type,
          Vpc: {
            SecurityGroupIds: this.input.vpc?.securityGroupIds,
            SubnetIds: this.input.vpc?.subnetIds,
          },
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateInput.Input.Type', props);
    return resource.getResponseField('Input.Type') as unknown as string;
  }

}

export class MediaLiveCreateInputSecurityGroup extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateInputSecurityGroupRequest) {
    super(scope, id);
  }

  public get securityGroup(): MediaLiveCreateInputSecurityGroupSecurityGroup {
    return new MediaLiveCreateInputSecurityGroupSecurityGroup(this, 'SecurityGroup', this.__resources, this.input);
  }

}

export class MediaLiveCreateInputSecurityGroupSecurityGroup extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateInputSecurityGroupRequest) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createInputSecurityGroup',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateInputSecurityGroup.SecurityGroup.Arn'),
        outputPath: 'SecurityGroup.Arn',
        parameters: {
          Tags: this.input.tags,
          WhitelistRules: this.input.whitelistRules,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateInputSecurityGroup.SecurityGroup.Arn', props);
    return resource.getResponseField('SecurityGroup.Arn') as unknown as string;
  }

  public get id(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createInputSecurityGroup',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateInputSecurityGroup.SecurityGroup.Id'),
        outputPath: 'SecurityGroup.Id',
        parameters: {
          Tags: this.input.tags,
          WhitelistRules: this.input.whitelistRules,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateInputSecurityGroup.SecurityGroup.Id', props);
    return resource.getResponseField('SecurityGroup.Id') as unknown as string;
  }

  public get inputs(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createInputSecurityGroup',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateInputSecurityGroup.SecurityGroup.Inputs'),
        outputPath: 'SecurityGroup.Inputs',
        parameters: {
          Tags: this.input.tags,
          WhitelistRules: this.input.whitelistRules,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateInputSecurityGroup.SecurityGroup.Inputs', props);
    return resource.getResponseField('SecurityGroup.Inputs') as unknown as string[];
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createInputSecurityGroup',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateInputSecurityGroup.SecurityGroup.State'),
        outputPath: 'SecurityGroup.State',
        parameters: {
          Tags: this.input.tags,
          WhitelistRules: this.input.whitelistRules,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateInputSecurityGroup.SecurityGroup.State', props);
    return resource.getResponseField('SecurityGroup.State') as unknown as string;
  }

  public get tags(): Record<string, string> {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createInputSecurityGroup',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateInputSecurityGroup.SecurityGroup.Tags'),
        outputPath: 'SecurityGroup.Tags',
        parameters: {
          Tags: this.input.tags,
          WhitelistRules: this.input.whitelistRules,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateInputSecurityGroup.SecurityGroup.Tags', props);
    return resource.getResponseField('SecurityGroup.Tags') as unknown as Record<string, string>;
  }

  public get whitelistRules(): shapes.MediaLiveInputWhitelistRule[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createInputSecurityGroup',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateInputSecurityGroup.SecurityGroup.WhitelistRules'),
        outputPath: 'SecurityGroup.WhitelistRules',
        parameters: {
          Tags: this.input.tags,
          WhitelistRules: this.input.whitelistRules,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateInputSecurityGroup.SecurityGroup.WhitelistRules', props);
    return resource.getResponseField('SecurityGroup.WhitelistRules') as unknown as shapes.MediaLiveInputWhitelistRule[];
  }

}

export class MediaLiveCreateMultiplex extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateMultiplexRequest) {
    super(scope, id);
  }

  public get multiplex(): MediaLiveCreateMultiplexMultiplex {
    return new MediaLiveCreateMultiplexMultiplex(this, 'Multiplex', this.__resources, this.input);
  }

}

export class MediaLiveCreateMultiplexMultiplex extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateMultiplexRequest) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplex.Multiplex.Arn'),
        outputPath: 'Multiplex.Arn',
        parameters: {
          AvailabilityZones: this.input.availabilityZones,
          MultiplexSettings: {
            MaximumVideoBufferDelayMilliseconds: this.input.multiplexSettings.maximumVideoBufferDelayMilliseconds,
            TransportStreamBitrate: this.input.multiplexSettings.transportStreamBitrate,
            TransportStreamId: this.input.multiplexSettings.transportStreamId,
            TransportStreamReservedBitrate: this.input.multiplexSettings.transportStreamReservedBitrate,
          },
          Name: this.input.name,
          RequestId: this.input.requestId,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplex.Multiplex.Arn', props);
    return resource.getResponseField('Multiplex.Arn') as unknown as string;
  }

  public get availabilityZones(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplex.Multiplex.AvailabilityZones'),
        outputPath: 'Multiplex.AvailabilityZones',
        parameters: {
          AvailabilityZones: this.input.availabilityZones,
          MultiplexSettings: {
            MaximumVideoBufferDelayMilliseconds: this.input.multiplexSettings.maximumVideoBufferDelayMilliseconds,
            TransportStreamBitrate: this.input.multiplexSettings.transportStreamBitrate,
            TransportStreamId: this.input.multiplexSettings.transportStreamId,
            TransportStreamReservedBitrate: this.input.multiplexSettings.transportStreamReservedBitrate,
          },
          Name: this.input.name,
          RequestId: this.input.requestId,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplex.Multiplex.AvailabilityZones', props);
    return resource.getResponseField('Multiplex.AvailabilityZones') as unknown as string[];
  }

  public get destinations(): shapes.MediaLiveMultiplexOutputDestination[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplex.Multiplex.Destinations'),
        outputPath: 'Multiplex.Destinations',
        parameters: {
          AvailabilityZones: this.input.availabilityZones,
          MultiplexSettings: {
            MaximumVideoBufferDelayMilliseconds: this.input.multiplexSettings.maximumVideoBufferDelayMilliseconds,
            TransportStreamBitrate: this.input.multiplexSettings.transportStreamBitrate,
            TransportStreamId: this.input.multiplexSettings.transportStreamId,
            TransportStreamReservedBitrate: this.input.multiplexSettings.transportStreamReservedBitrate,
          },
          Name: this.input.name,
          RequestId: this.input.requestId,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplex.Multiplex.Destinations', props);
    return resource.getResponseField('Multiplex.Destinations') as unknown as shapes.MediaLiveMultiplexOutputDestination[];
  }

  public get id(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplex.Multiplex.Id'),
        outputPath: 'Multiplex.Id',
        parameters: {
          AvailabilityZones: this.input.availabilityZones,
          MultiplexSettings: {
            MaximumVideoBufferDelayMilliseconds: this.input.multiplexSettings.maximumVideoBufferDelayMilliseconds,
            TransportStreamBitrate: this.input.multiplexSettings.transportStreamBitrate,
            TransportStreamId: this.input.multiplexSettings.transportStreamId,
            TransportStreamReservedBitrate: this.input.multiplexSettings.transportStreamReservedBitrate,
          },
          Name: this.input.name,
          RequestId: this.input.requestId,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplex.Multiplex.Id', props);
    return resource.getResponseField('Multiplex.Id') as unknown as string;
  }

  public get multiplexSettings(): MediaLiveCreateMultiplexMultiplexMultiplexSettings {
    return new MediaLiveCreateMultiplexMultiplexMultiplexSettings(this, 'MultiplexSettings', this.__resources, this.input);
  }

  public get name(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplex.Multiplex.Name'),
        outputPath: 'Multiplex.Name',
        parameters: {
          AvailabilityZones: this.input.availabilityZones,
          MultiplexSettings: {
            MaximumVideoBufferDelayMilliseconds: this.input.multiplexSettings.maximumVideoBufferDelayMilliseconds,
            TransportStreamBitrate: this.input.multiplexSettings.transportStreamBitrate,
            TransportStreamId: this.input.multiplexSettings.transportStreamId,
            TransportStreamReservedBitrate: this.input.multiplexSettings.transportStreamReservedBitrate,
          },
          Name: this.input.name,
          RequestId: this.input.requestId,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplex.Multiplex.Name', props);
    return resource.getResponseField('Multiplex.Name') as unknown as string;
  }

  public get pipelinesRunningCount(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplex.Multiplex.PipelinesRunningCount'),
        outputPath: 'Multiplex.PipelinesRunningCount',
        parameters: {
          AvailabilityZones: this.input.availabilityZones,
          MultiplexSettings: {
            MaximumVideoBufferDelayMilliseconds: this.input.multiplexSettings.maximumVideoBufferDelayMilliseconds,
            TransportStreamBitrate: this.input.multiplexSettings.transportStreamBitrate,
            TransportStreamId: this.input.multiplexSettings.transportStreamId,
            TransportStreamReservedBitrate: this.input.multiplexSettings.transportStreamReservedBitrate,
          },
          Name: this.input.name,
          RequestId: this.input.requestId,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplex.Multiplex.PipelinesRunningCount', props);
    return resource.getResponseField('Multiplex.PipelinesRunningCount') as unknown as number;
  }

  public get programCount(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplex.Multiplex.ProgramCount'),
        outputPath: 'Multiplex.ProgramCount',
        parameters: {
          AvailabilityZones: this.input.availabilityZones,
          MultiplexSettings: {
            MaximumVideoBufferDelayMilliseconds: this.input.multiplexSettings.maximumVideoBufferDelayMilliseconds,
            TransportStreamBitrate: this.input.multiplexSettings.transportStreamBitrate,
            TransportStreamId: this.input.multiplexSettings.transportStreamId,
            TransportStreamReservedBitrate: this.input.multiplexSettings.transportStreamReservedBitrate,
          },
          Name: this.input.name,
          RequestId: this.input.requestId,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplex.Multiplex.ProgramCount', props);
    return resource.getResponseField('Multiplex.ProgramCount') as unknown as number;
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplex.Multiplex.State'),
        outputPath: 'Multiplex.State',
        parameters: {
          AvailabilityZones: this.input.availabilityZones,
          MultiplexSettings: {
            MaximumVideoBufferDelayMilliseconds: this.input.multiplexSettings.maximumVideoBufferDelayMilliseconds,
            TransportStreamBitrate: this.input.multiplexSettings.transportStreamBitrate,
            TransportStreamId: this.input.multiplexSettings.transportStreamId,
            TransportStreamReservedBitrate: this.input.multiplexSettings.transportStreamReservedBitrate,
          },
          Name: this.input.name,
          RequestId: this.input.requestId,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplex.Multiplex.State', props);
    return resource.getResponseField('Multiplex.State') as unknown as string;
  }

  public get tags(): Record<string, string> {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplex.Multiplex.Tags'),
        outputPath: 'Multiplex.Tags',
        parameters: {
          AvailabilityZones: this.input.availabilityZones,
          MultiplexSettings: {
            MaximumVideoBufferDelayMilliseconds: this.input.multiplexSettings.maximumVideoBufferDelayMilliseconds,
            TransportStreamBitrate: this.input.multiplexSettings.transportStreamBitrate,
            TransportStreamId: this.input.multiplexSettings.transportStreamId,
            TransportStreamReservedBitrate: this.input.multiplexSettings.transportStreamReservedBitrate,
          },
          Name: this.input.name,
          RequestId: this.input.requestId,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplex.Multiplex.Tags', props);
    return resource.getResponseField('Multiplex.Tags') as unknown as Record<string, string>;
  }

}

export class MediaLiveCreateMultiplexMultiplexMultiplexSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateMultiplexRequest) {
    super(scope, id);
  }

  public get maximumVideoBufferDelayMilliseconds(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplex.Multiplex.MultiplexSettings.MaximumVideoBufferDelayMilliseconds'),
        outputPath: 'Multiplex.MultiplexSettings.MaximumVideoBufferDelayMilliseconds',
        parameters: {
          AvailabilityZones: this.input.availabilityZones,
          MultiplexSettings: {
            MaximumVideoBufferDelayMilliseconds: this.input.multiplexSettings.maximumVideoBufferDelayMilliseconds,
            TransportStreamBitrate: this.input.multiplexSettings.transportStreamBitrate,
            TransportStreamId: this.input.multiplexSettings.transportStreamId,
            TransportStreamReservedBitrate: this.input.multiplexSettings.transportStreamReservedBitrate,
          },
          Name: this.input.name,
          RequestId: this.input.requestId,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplex.Multiplex.MultiplexSettings.MaximumVideoBufferDelayMilliseconds', props);
    return resource.getResponseField('Multiplex.MultiplexSettings.MaximumVideoBufferDelayMilliseconds') as unknown as number;
  }

  public get transportStreamBitrate(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplex.Multiplex.MultiplexSettings.TransportStreamBitrate'),
        outputPath: 'Multiplex.MultiplexSettings.TransportStreamBitrate',
        parameters: {
          AvailabilityZones: this.input.availabilityZones,
          MultiplexSettings: {
            MaximumVideoBufferDelayMilliseconds: this.input.multiplexSettings.maximumVideoBufferDelayMilliseconds,
            TransportStreamBitrate: this.input.multiplexSettings.transportStreamBitrate,
            TransportStreamId: this.input.multiplexSettings.transportStreamId,
            TransportStreamReservedBitrate: this.input.multiplexSettings.transportStreamReservedBitrate,
          },
          Name: this.input.name,
          RequestId: this.input.requestId,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplex.Multiplex.MultiplexSettings.TransportStreamBitrate', props);
    return resource.getResponseField('Multiplex.MultiplexSettings.TransportStreamBitrate') as unknown as number;
  }

  public get transportStreamId(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplex.Multiplex.MultiplexSettings.TransportStreamId'),
        outputPath: 'Multiplex.MultiplexSettings.TransportStreamId',
        parameters: {
          AvailabilityZones: this.input.availabilityZones,
          MultiplexSettings: {
            MaximumVideoBufferDelayMilliseconds: this.input.multiplexSettings.maximumVideoBufferDelayMilliseconds,
            TransportStreamBitrate: this.input.multiplexSettings.transportStreamBitrate,
            TransportStreamId: this.input.multiplexSettings.transportStreamId,
            TransportStreamReservedBitrate: this.input.multiplexSettings.transportStreamReservedBitrate,
          },
          Name: this.input.name,
          RequestId: this.input.requestId,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplex.Multiplex.MultiplexSettings.TransportStreamId', props);
    return resource.getResponseField('Multiplex.MultiplexSettings.TransportStreamId') as unknown as number;
  }

  public get transportStreamReservedBitrate(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplex.Multiplex.MultiplexSettings.TransportStreamReservedBitrate'),
        outputPath: 'Multiplex.MultiplexSettings.TransportStreamReservedBitrate',
        parameters: {
          AvailabilityZones: this.input.availabilityZones,
          MultiplexSettings: {
            MaximumVideoBufferDelayMilliseconds: this.input.multiplexSettings.maximumVideoBufferDelayMilliseconds,
            TransportStreamBitrate: this.input.multiplexSettings.transportStreamBitrate,
            TransportStreamId: this.input.multiplexSettings.transportStreamId,
            TransportStreamReservedBitrate: this.input.multiplexSettings.transportStreamReservedBitrate,
          },
          Name: this.input.name,
          RequestId: this.input.requestId,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplex.Multiplex.MultiplexSettings.TransportStreamReservedBitrate', props);
    return resource.getResponseField('Multiplex.MultiplexSettings.TransportStreamReservedBitrate') as unknown as number;
  }

}

export class MediaLiveCreateMultiplexProgram extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateMultiplexProgramRequest) {
    super(scope, id);
  }

  public get multiplexProgram(): MediaLiveCreateMultiplexProgramMultiplexProgram {
    return new MediaLiveCreateMultiplexProgramMultiplexProgram(this, 'MultiplexProgram', this.__resources, this.input);
  }

}

export class MediaLiveCreateMultiplexProgramMultiplexProgram extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateMultiplexProgramRequest) {
    super(scope, id);
  }

  public get channelId(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplexProgram.MultiplexProgram.ChannelId'),
        outputPath: 'MultiplexProgram.ChannelId',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
          RequestId: this.input.requestId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplexProgram.MultiplexProgram.ChannelId', props);
    return resource.getResponseField('MultiplexProgram.ChannelId') as unknown as string;
  }

  public get multiplexProgramSettings(): MediaLiveCreateMultiplexProgramMultiplexProgramMultiplexProgramSettings {
    return new MediaLiveCreateMultiplexProgramMultiplexProgramMultiplexProgramSettings(this, 'MultiplexProgramSettings', this.__resources, this.input);
  }

  public get packetIdentifiersMap(): MediaLiveCreateMultiplexProgramMultiplexProgramPacketIdentifiersMap {
    return new MediaLiveCreateMultiplexProgramMultiplexProgramPacketIdentifiersMap(this, 'PacketIdentifiersMap', this.__resources, this.input);
  }

  public get pipelineDetails(): shapes.MediaLiveMultiplexProgramPipelineDetail[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplexProgram.MultiplexProgram.PipelineDetails'),
        outputPath: 'MultiplexProgram.PipelineDetails',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
          RequestId: this.input.requestId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplexProgram.MultiplexProgram.PipelineDetails', props);
    return resource.getResponseField('MultiplexProgram.PipelineDetails') as unknown as shapes.MediaLiveMultiplexProgramPipelineDetail[];
  }

  public get programName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplexProgram.MultiplexProgram.ProgramName'),
        outputPath: 'MultiplexProgram.ProgramName',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
          RequestId: this.input.requestId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplexProgram.MultiplexProgram.ProgramName', props);
    return resource.getResponseField('MultiplexProgram.ProgramName') as unknown as string;
  }

}

export class MediaLiveCreateMultiplexProgramMultiplexProgramMultiplexProgramSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateMultiplexProgramRequest) {
    super(scope, id);
  }

  public get preferredChannelPipeline(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.PreferredChannelPipeline'),
        outputPath: 'MultiplexProgram.MultiplexProgramSettings.PreferredChannelPipeline',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
          RequestId: this.input.requestId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.PreferredChannelPipeline', props);
    return resource.getResponseField('MultiplexProgram.MultiplexProgramSettings.PreferredChannelPipeline') as unknown as string;
  }

  public get programNumber(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.ProgramNumber'),
        outputPath: 'MultiplexProgram.MultiplexProgramSettings.ProgramNumber',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
          RequestId: this.input.requestId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.ProgramNumber', props);
    return resource.getResponseField('MultiplexProgram.MultiplexProgramSettings.ProgramNumber') as unknown as number;
  }

  public get serviceDescriptor(): MediaLiveCreateMultiplexProgramMultiplexProgramMultiplexProgramSettingsServiceDescriptor {
    return new MediaLiveCreateMultiplexProgramMultiplexProgramMultiplexProgramSettingsServiceDescriptor(this, 'ServiceDescriptor', this.__resources, this.input);
  }

  public get videoSettings(): MediaLiveCreateMultiplexProgramMultiplexProgramMultiplexProgramSettingsVideoSettings {
    return new MediaLiveCreateMultiplexProgramMultiplexProgramMultiplexProgramSettingsVideoSettings(this, 'VideoSettings', this.__resources, this.input);
  }

}

export class MediaLiveCreateMultiplexProgramMultiplexProgramMultiplexProgramSettingsServiceDescriptor extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateMultiplexProgramRequest) {
    super(scope, id);
  }

  public get providerName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.ServiceDescriptor.ProviderName'),
        outputPath: 'MultiplexProgram.MultiplexProgramSettings.ServiceDescriptor.ProviderName',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
          RequestId: this.input.requestId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.ServiceDescriptor.ProviderName', props);
    return resource.getResponseField('MultiplexProgram.MultiplexProgramSettings.ServiceDescriptor.ProviderName') as unknown as string;
  }

  public get serviceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.ServiceDescriptor.ServiceName'),
        outputPath: 'MultiplexProgram.MultiplexProgramSettings.ServiceDescriptor.ServiceName',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
          RequestId: this.input.requestId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.ServiceDescriptor.ServiceName', props);
    return resource.getResponseField('MultiplexProgram.MultiplexProgramSettings.ServiceDescriptor.ServiceName') as unknown as string;
  }

}

export class MediaLiveCreateMultiplexProgramMultiplexProgramMultiplexProgramSettingsVideoSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateMultiplexProgramRequest) {
    super(scope, id);
  }

  public get constantBitrate(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.VideoSettings.ConstantBitrate'),
        outputPath: 'MultiplexProgram.MultiplexProgramSettings.VideoSettings.ConstantBitrate',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
          RequestId: this.input.requestId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.VideoSettings.ConstantBitrate', props);
    return resource.getResponseField('MultiplexProgram.MultiplexProgramSettings.VideoSettings.ConstantBitrate') as unknown as number;
  }

  public get statmuxSettings(): MediaLiveCreateMultiplexProgramMultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettings {
    return new MediaLiveCreateMultiplexProgramMultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettings(this, 'StatmuxSettings', this.__resources, this.input);
  }

}

export class MediaLiveCreateMultiplexProgramMultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateMultiplexProgramRequest) {
    super(scope, id);
  }

  public get maximumBitrate(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.MaximumBitrate'),
        outputPath: 'MultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.MaximumBitrate',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
          RequestId: this.input.requestId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.MaximumBitrate', props);
    return resource.getResponseField('MultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.MaximumBitrate') as unknown as number;
  }

  public get minimumBitrate(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.MinimumBitrate'),
        outputPath: 'MultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.MinimumBitrate',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
          RequestId: this.input.requestId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.MinimumBitrate', props);
    return resource.getResponseField('MultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.MinimumBitrate') as unknown as number;
  }

  public get priority(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.Priority'),
        outputPath: 'MultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.Priority',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
          RequestId: this.input.requestId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.Priority', props);
    return resource.getResponseField('MultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.Priority') as unknown as number;
  }

}

export class MediaLiveCreateMultiplexProgramMultiplexProgramPacketIdentifiersMap extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveCreateMultiplexProgramRequest) {
    super(scope, id);
  }

  public get audioPids(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.AudioPids'),
        outputPath: 'MultiplexProgram.PacketIdentifiersMap.AudioPids',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
          RequestId: this.input.requestId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.AudioPids', props);
    return resource.getResponseField('MultiplexProgram.PacketIdentifiersMap.AudioPids') as unknown as number[];
  }

  public get dvbSubPids(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.DvbSubPids'),
        outputPath: 'MultiplexProgram.PacketIdentifiersMap.DvbSubPids',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
          RequestId: this.input.requestId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.DvbSubPids', props);
    return resource.getResponseField('MultiplexProgram.PacketIdentifiersMap.DvbSubPids') as unknown as number[];
  }

  public get dvbTeletextPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.DvbTeletextPid'),
        outputPath: 'MultiplexProgram.PacketIdentifiersMap.DvbTeletextPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
          RequestId: this.input.requestId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.DvbTeletextPid', props);
    return resource.getResponseField('MultiplexProgram.PacketIdentifiersMap.DvbTeletextPid') as unknown as number;
  }

  public get etvPlatformPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.EtvPlatformPid'),
        outputPath: 'MultiplexProgram.PacketIdentifiersMap.EtvPlatformPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
          RequestId: this.input.requestId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.EtvPlatformPid', props);
    return resource.getResponseField('MultiplexProgram.PacketIdentifiersMap.EtvPlatformPid') as unknown as number;
  }

  public get etvSignalPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.EtvSignalPid'),
        outputPath: 'MultiplexProgram.PacketIdentifiersMap.EtvSignalPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
          RequestId: this.input.requestId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.EtvSignalPid', props);
    return resource.getResponseField('MultiplexProgram.PacketIdentifiersMap.EtvSignalPid') as unknown as number;
  }

  public get klvDataPids(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.KlvDataPids'),
        outputPath: 'MultiplexProgram.PacketIdentifiersMap.KlvDataPids',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
          RequestId: this.input.requestId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.KlvDataPids', props);
    return resource.getResponseField('MultiplexProgram.PacketIdentifiersMap.KlvDataPids') as unknown as number[];
  }

  public get pcrPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.PcrPid'),
        outputPath: 'MultiplexProgram.PacketIdentifiersMap.PcrPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
          RequestId: this.input.requestId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.PcrPid', props);
    return resource.getResponseField('MultiplexProgram.PacketIdentifiersMap.PcrPid') as unknown as number;
  }

  public get pmtPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.PmtPid'),
        outputPath: 'MultiplexProgram.PacketIdentifiersMap.PmtPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
          RequestId: this.input.requestId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.PmtPid', props);
    return resource.getResponseField('MultiplexProgram.PacketIdentifiersMap.PmtPid') as unknown as number;
  }

  public get privateMetadataPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.PrivateMetadataPid'),
        outputPath: 'MultiplexProgram.PacketIdentifiersMap.PrivateMetadataPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
          RequestId: this.input.requestId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.PrivateMetadataPid', props);
    return resource.getResponseField('MultiplexProgram.PacketIdentifiersMap.PrivateMetadataPid') as unknown as number;
  }

  public get scte27Pids(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.Scte27Pids'),
        outputPath: 'MultiplexProgram.PacketIdentifiersMap.Scte27Pids',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
          RequestId: this.input.requestId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.Scte27Pids', props);
    return resource.getResponseField('MultiplexProgram.PacketIdentifiersMap.Scte27Pids') as unknown as number[];
  }

  public get scte35Pid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.Scte35Pid'),
        outputPath: 'MultiplexProgram.PacketIdentifiersMap.Scte35Pid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
          RequestId: this.input.requestId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.Scte35Pid', props);
    return resource.getResponseField('MultiplexProgram.PacketIdentifiersMap.Scte35Pid') as unknown as number;
  }

  public get timedMetadataPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.TimedMetadataPid'),
        outputPath: 'MultiplexProgram.PacketIdentifiersMap.TimedMetadataPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
          RequestId: this.input.requestId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.TimedMetadataPid', props);
    return resource.getResponseField('MultiplexProgram.PacketIdentifiersMap.TimedMetadataPid') as unknown as number;
  }

  public get videoPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'createMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.CreateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.VideoPid'),
        outputPath: 'MultiplexProgram.PacketIdentifiersMap.VideoPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
          RequestId: this.input.requestId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'CreateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.VideoPid', props);
    return resource.getResponseField('MultiplexProgram.PacketIdentifiersMap.VideoPid') as unknown as number;
  }

}

export class MediaLiveDeleteChannel extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDeleteChannelRequest) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.Arn'),
        outputPath: 'Arn',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.Arn', props);
    return resource.getResponseField('Arn') as unknown as string;
  }

  public get cdiInputSpecification(): MediaLiveDeleteChannelCdiInputSpecification {
    return new MediaLiveDeleteChannelCdiInputSpecification(this, 'CdiInputSpecification', this.__resources, this.input);
  }

  public get channelClass(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.ChannelClass'),
        outputPath: 'ChannelClass',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.ChannelClass', props);
    return resource.getResponseField('ChannelClass') as unknown as string;
  }

  public get destinations(): shapes.MediaLiveOutputDestination[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.Destinations'),
        outputPath: 'Destinations',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.Destinations', props);
    return resource.getResponseField('Destinations') as unknown as shapes.MediaLiveOutputDestination[];
  }

  public get egressEndpoints(): shapes.MediaLiveChannelEgressEndpoint[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EgressEndpoints'),
        outputPath: 'EgressEndpoints',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EgressEndpoints', props);
    return resource.getResponseField('EgressEndpoints') as unknown as shapes.MediaLiveChannelEgressEndpoint[];
  }

  public get encoderSettings(): MediaLiveDeleteChannelEncoderSettings {
    return new MediaLiveDeleteChannelEncoderSettings(this, 'EncoderSettings', this.__resources, this.input);
  }

  public get id(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.Id'),
        outputPath: 'Id',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.Id', props);
    return resource.getResponseField('Id') as unknown as string;
  }

  public get inputAttachments(): shapes.MediaLiveInputAttachment[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.InputAttachments'),
        outputPath: 'InputAttachments',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.InputAttachments', props);
    return resource.getResponseField('InputAttachments') as unknown as shapes.MediaLiveInputAttachment[];
  }

  public get inputSpecification(): MediaLiveDeleteChannelInputSpecification {
    return new MediaLiveDeleteChannelInputSpecification(this, 'InputSpecification', this.__resources, this.input);
  }

  public get logLevel(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.LogLevel'),
        outputPath: 'LogLevel',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.LogLevel', props);
    return resource.getResponseField('LogLevel') as unknown as string;
  }

  public get name(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.Name'),
        outputPath: 'Name',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.Name', props);
    return resource.getResponseField('Name') as unknown as string;
  }

  public get pipelineDetails(): shapes.MediaLivePipelineDetail[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.PipelineDetails'),
        outputPath: 'PipelineDetails',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.PipelineDetails', props);
    return resource.getResponseField('PipelineDetails') as unknown as shapes.MediaLivePipelineDetail[];
  }

  public get pipelinesRunningCount(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.PipelinesRunningCount'),
        outputPath: 'PipelinesRunningCount',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.PipelinesRunningCount', props);
    return resource.getResponseField('PipelinesRunningCount') as unknown as number;
  }

  public get roleArn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.RoleArn'),
        outputPath: 'RoleArn',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.RoleArn', props);
    return resource.getResponseField('RoleArn') as unknown as string;
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.State'),
        outputPath: 'State',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.State', props);
    return resource.getResponseField('State') as unknown as string;
  }

  public get tags(): Record<string, string> {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.Tags'),
        outputPath: 'Tags',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.Tags', props);
    return resource.getResponseField('Tags') as unknown as Record<string, string>;
  }

}

export class MediaLiveDeleteChannelCdiInputSpecification extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDeleteChannelRequest) {
    super(scope, id);
  }

  public get resolution(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.CdiInputSpecification.Resolution'),
        outputPath: 'CdiInputSpecification.Resolution',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.CdiInputSpecification.Resolution', props);
    return resource.getResponseField('CdiInputSpecification.Resolution') as unknown as string;
  }

}

export class MediaLiveDeleteChannelEncoderSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDeleteChannelRequest) {
    super(scope, id);
  }

  public get audioDescriptions(): shapes.MediaLiveAudioDescription[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.AudioDescriptions'),
        outputPath: 'EncoderSettings.AudioDescriptions',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.AudioDescriptions', props);
    return resource.getResponseField('EncoderSettings.AudioDescriptions') as unknown as shapes.MediaLiveAudioDescription[];
  }

  public get availBlanking(): MediaLiveDeleteChannelEncoderSettingsAvailBlanking {
    return new MediaLiveDeleteChannelEncoderSettingsAvailBlanking(this, 'AvailBlanking', this.__resources, this.input);
  }

  public get availConfiguration(): MediaLiveDeleteChannelEncoderSettingsAvailConfiguration {
    return new MediaLiveDeleteChannelEncoderSettingsAvailConfiguration(this, 'AvailConfiguration', this.__resources, this.input);
  }

  public get blackoutSlate(): MediaLiveDeleteChannelEncoderSettingsBlackoutSlate {
    return new MediaLiveDeleteChannelEncoderSettingsBlackoutSlate(this, 'BlackoutSlate', this.__resources, this.input);
  }

  public get captionDescriptions(): shapes.MediaLiveCaptionDescription[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.CaptionDescriptions'),
        outputPath: 'EncoderSettings.CaptionDescriptions',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.CaptionDescriptions', props);
    return resource.getResponseField('EncoderSettings.CaptionDescriptions') as unknown as shapes.MediaLiveCaptionDescription[];
  }

  public get featureActivations(): MediaLiveDeleteChannelEncoderSettingsFeatureActivations {
    return new MediaLiveDeleteChannelEncoderSettingsFeatureActivations(this, 'FeatureActivations', this.__resources, this.input);
  }

  public get globalConfiguration(): MediaLiveDeleteChannelEncoderSettingsGlobalConfiguration {
    return new MediaLiveDeleteChannelEncoderSettingsGlobalConfiguration(this, 'GlobalConfiguration', this.__resources, this.input);
  }

  public get nielsenConfiguration(): MediaLiveDeleteChannelEncoderSettingsNielsenConfiguration {
    return new MediaLiveDeleteChannelEncoderSettingsNielsenConfiguration(this, 'NielsenConfiguration', this.__resources, this.input);
  }

  public get outputGroups(): shapes.MediaLiveOutputGroup[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.OutputGroups'),
        outputPath: 'EncoderSettings.OutputGroups',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.OutputGroups', props);
    return resource.getResponseField('EncoderSettings.OutputGroups') as unknown as shapes.MediaLiveOutputGroup[];
  }

  public get timecodeConfig(): MediaLiveDeleteChannelEncoderSettingsTimecodeConfig {
    return new MediaLiveDeleteChannelEncoderSettingsTimecodeConfig(this, 'TimecodeConfig', this.__resources, this.input);
  }

  public get videoDescriptions(): shapes.MediaLiveVideoDescription[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.VideoDescriptions'),
        outputPath: 'EncoderSettings.VideoDescriptions',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.VideoDescriptions', props);
    return resource.getResponseField('EncoderSettings.VideoDescriptions') as unknown as shapes.MediaLiveVideoDescription[];
  }

}

export class MediaLiveDeleteChannelEncoderSettingsAvailBlanking extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDeleteChannelRequest) {
    super(scope, id);
  }

  public get availBlankingImage(): MediaLiveDeleteChannelEncoderSettingsAvailBlankingAvailBlankingImage {
    return new MediaLiveDeleteChannelEncoderSettingsAvailBlankingAvailBlankingImage(this, 'AvailBlankingImage', this.__resources, this.input);
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.AvailBlanking.State'),
        outputPath: 'EncoderSettings.AvailBlanking.State',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.AvailBlanking.State', props);
    return resource.getResponseField('EncoderSettings.AvailBlanking.State') as unknown as string;
  }

}

export class MediaLiveDeleteChannelEncoderSettingsAvailBlankingAvailBlankingImage extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDeleteChannelRequest) {
    super(scope, id);
  }

  public get passwordParam(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.AvailBlanking.AvailBlankingImage.PasswordParam'),
        outputPath: 'EncoderSettings.AvailBlanking.AvailBlankingImage.PasswordParam',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.AvailBlanking.AvailBlankingImage.PasswordParam', props);
    return resource.getResponseField('EncoderSettings.AvailBlanking.AvailBlankingImage.PasswordParam') as unknown as string;
  }

  public get uri(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.AvailBlanking.AvailBlankingImage.Uri'),
        outputPath: 'EncoderSettings.AvailBlanking.AvailBlankingImage.Uri',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.AvailBlanking.AvailBlankingImage.Uri', props);
    return resource.getResponseField('EncoderSettings.AvailBlanking.AvailBlankingImage.Uri') as unknown as string;
  }

  public get username(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.AvailBlanking.AvailBlankingImage.Username'),
        outputPath: 'EncoderSettings.AvailBlanking.AvailBlankingImage.Username',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.AvailBlanking.AvailBlankingImage.Username', props);
    return resource.getResponseField('EncoderSettings.AvailBlanking.AvailBlankingImage.Username') as unknown as string;
  }

}

export class MediaLiveDeleteChannelEncoderSettingsAvailConfiguration extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDeleteChannelRequest) {
    super(scope, id);
  }

  public get availSettings(): MediaLiveDeleteChannelEncoderSettingsAvailConfigurationAvailSettings {
    return new MediaLiveDeleteChannelEncoderSettingsAvailConfigurationAvailSettings(this, 'AvailSettings', this.__resources, this.input);
  }

}

export class MediaLiveDeleteChannelEncoderSettingsAvailConfigurationAvailSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDeleteChannelRequest) {
    super(scope, id);
  }

  public get scte35SpliceInsert(): MediaLiveDeleteChannelEncoderSettingsAvailConfigurationAvailSettingsScte35SpliceInsert {
    return new MediaLiveDeleteChannelEncoderSettingsAvailConfigurationAvailSettingsScte35SpliceInsert(this, 'Scte35SpliceInsert', this.__resources, this.input);
  }

  public get scte35TimeSignalApos(): MediaLiveDeleteChannelEncoderSettingsAvailConfigurationAvailSettingsScte35TimeSignalApos {
    return new MediaLiveDeleteChannelEncoderSettingsAvailConfigurationAvailSettingsScte35TimeSignalApos(this, 'Scte35TimeSignalApos', this.__resources, this.input);
  }

}

export class MediaLiveDeleteChannelEncoderSettingsAvailConfigurationAvailSettingsScte35SpliceInsert extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDeleteChannelRequest) {
    super(scope, id);
  }

  public get adAvailOffset(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.AdAvailOffset'),
        outputPath: 'EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.AdAvailOffset',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.AdAvailOffset', props);
    return resource.getResponseField('EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.AdAvailOffset') as unknown as number;
  }

  public get noRegionalBlackoutFlag(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.NoRegionalBlackoutFlag'),
        outputPath: 'EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.NoRegionalBlackoutFlag',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.NoRegionalBlackoutFlag', props);
    return resource.getResponseField('EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.NoRegionalBlackoutFlag') as unknown as string;
  }

  public get webDeliveryAllowedFlag(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.WebDeliveryAllowedFlag'),
        outputPath: 'EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.WebDeliveryAllowedFlag',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.WebDeliveryAllowedFlag', props);
    return resource.getResponseField('EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.WebDeliveryAllowedFlag') as unknown as string;
  }

}

export class MediaLiveDeleteChannelEncoderSettingsAvailConfigurationAvailSettingsScte35TimeSignalApos extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDeleteChannelRequest) {
    super(scope, id);
  }

  public get adAvailOffset(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.AdAvailOffset'),
        outputPath: 'EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.AdAvailOffset',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.AdAvailOffset', props);
    return resource.getResponseField('EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.AdAvailOffset') as unknown as number;
  }

  public get noRegionalBlackoutFlag(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.NoRegionalBlackoutFlag'),
        outputPath: 'EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.NoRegionalBlackoutFlag',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.NoRegionalBlackoutFlag', props);
    return resource.getResponseField('EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.NoRegionalBlackoutFlag') as unknown as string;
  }

  public get webDeliveryAllowedFlag(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.WebDeliveryAllowedFlag'),
        outputPath: 'EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.WebDeliveryAllowedFlag',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.WebDeliveryAllowedFlag', props);
    return resource.getResponseField('EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.WebDeliveryAllowedFlag') as unknown as string;
  }

}

export class MediaLiveDeleteChannelEncoderSettingsBlackoutSlate extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDeleteChannelRequest) {
    super(scope, id);
  }

  public get blackoutSlateImage(): MediaLiveDeleteChannelEncoderSettingsBlackoutSlateBlackoutSlateImage {
    return new MediaLiveDeleteChannelEncoderSettingsBlackoutSlateBlackoutSlateImage(this, 'BlackoutSlateImage', this.__resources, this.input);
  }

  public get networkEndBlackout(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackout'),
        outputPath: 'EncoderSettings.BlackoutSlate.NetworkEndBlackout',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackout', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.NetworkEndBlackout') as unknown as string;
  }

  public get networkEndBlackoutImage(): MediaLiveDeleteChannelEncoderSettingsBlackoutSlateNetworkEndBlackoutImage {
    return new MediaLiveDeleteChannelEncoderSettingsBlackoutSlateNetworkEndBlackoutImage(this, 'NetworkEndBlackoutImage', this.__resources, this.input);
  }

  public get networkId(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.BlackoutSlate.NetworkId'),
        outputPath: 'EncoderSettings.BlackoutSlate.NetworkId',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.BlackoutSlate.NetworkId', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.NetworkId') as unknown as string;
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.BlackoutSlate.State'),
        outputPath: 'EncoderSettings.BlackoutSlate.State',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.BlackoutSlate.State', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.State') as unknown as string;
  }

}

export class MediaLiveDeleteChannelEncoderSettingsBlackoutSlateBlackoutSlateImage extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDeleteChannelRequest) {
    super(scope, id);
  }

  public get passwordParam(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.PasswordParam'),
        outputPath: 'EncoderSettings.BlackoutSlate.BlackoutSlateImage.PasswordParam',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.PasswordParam', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.BlackoutSlateImage.PasswordParam') as unknown as string;
  }

  public get uri(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Uri'),
        outputPath: 'EncoderSettings.BlackoutSlate.BlackoutSlateImage.Uri',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Uri', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.BlackoutSlateImage.Uri') as unknown as string;
  }

  public get username(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Username'),
        outputPath: 'EncoderSettings.BlackoutSlate.BlackoutSlateImage.Username',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Username', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.BlackoutSlateImage.Username') as unknown as string;
  }

}

export class MediaLiveDeleteChannelEncoderSettingsBlackoutSlateNetworkEndBlackoutImage extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDeleteChannelRequest) {
    super(scope, id);
  }

  public get passwordParam(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.PasswordParam'),
        outputPath: 'EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.PasswordParam',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.PasswordParam', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.PasswordParam') as unknown as string;
  }

  public get uri(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Uri'),
        outputPath: 'EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Uri',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Uri', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Uri') as unknown as string;
  }

  public get username(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Username'),
        outputPath: 'EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Username',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Username', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Username') as unknown as string;
  }

}

export class MediaLiveDeleteChannelEncoderSettingsFeatureActivations extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDeleteChannelRequest) {
    super(scope, id);
  }

  public get inputPrepareScheduleActions(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.FeatureActivations.InputPrepareScheduleActions'),
        outputPath: 'EncoderSettings.FeatureActivations.InputPrepareScheduleActions',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.FeatureActivations.InputPrepareScheduleActions', props);
    return resource.getResponseField('EncoderSettings.FeatureActivations.InputPrepareScheduleActions') as unknown as string;
  }

}

export class MediaLiveDeleteChannelEncoderSettingsGlobalConfiguration extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDeleteChannelRequest) {
    super(scope, id);
  }

  public get initialAudioGain(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.GlobalConfiguration.InitialAudioGain'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InitialAudioGain',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.GlobalConfiguration.InitialAudioGain', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InitialAudioGain') as unknown as number;
  }

  public get inputEndAction(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.GlobalConfiguration.InputEndAction'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputEndAction',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.GlobalConfiguration.InputEndAction', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputEndAction') as unknown as string;
  }

  public get inputLossBehavior(): MediaLiveDeleteChannelEncoderSettingsGlobalConfigurationInputLossBehavior {
    return new MediaLiveDeleteChannelEncoderSettingsGlobalConfigurationInputLossBehavior(this, 'InputLossBehavior', this.__resources, this.input);
  }

  public get outputLockingMode(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.GlobalConfiguration.OutputLockingMode'),
        outputPath: 'EncoderSettings.GlobalConfiguration.OutputLockingMode',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.GlobalConfiguration.OutputLockingMode', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.OutputLockingMode') as unknown as string;
  }

  public get outputTimingSource(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.GlobalConfiguration.OutputTimingSource'),
        outputPath: 'EncoderSettings.GlobalConfiguration.OutputTimingSource',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.GlobalConfiguration.OutputTimingSource', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.OutputTimingSource') as unknown as string;
  }

  public get supportLowFramerateInputs(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.GlobalConfiguration.SupportLowFramerateInputs'),
        outputPath: 'EncoderSettings.GlobalConfiguration.SupportLowFramerateInputs',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.GlobalConfiguration.SupportLowFramerateInputs', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.SupportLowFramerateInputs') as unknown as string;
  }

}

export class MediaLiveDeleteChannelEncoderSettingsGlobalConfigurationInputLossBehavior extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDeleteChannelRequest) {
    super(scope, id);
  }

  public get blackFrameMsec(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.BlackFrameMsec'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputLossBehavior.BlackFrameMsec',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.BlackFrameMsec', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputLossBehavior.BlackFrameMsec') as unknown as number;
  }

  public get inputLossImageColor(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageColor'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageColor',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageColor', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageColor') as unknown as string;
  }

  public get inputLossImageSlate(): MediaLiveDeleteChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate {
    return new MediaLiveDeleteChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate(this, 'InputLossImageSlate', this.__resources, this.input);
  }

  public get inputLossImageType(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageType'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageType',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageType', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageType') as unknown as string;
  }

  public get repeatFrameMsec(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.RepeatFrameMsec'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputLossBehavior.RepeatFrameMsec',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.RepeatFrameMsec', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputLossBehavior.RepeatFrameMsec') as unknown as number;
  }

}

export class MediaLiveDeleteChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDeleteChannelRequest) {
    super(scope, id);
  }

  public get passwordParam(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.PasswordParam'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.PasswordParam',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.PasswordParam', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.PasswordParam') as unknown as string;
  }

  public get uri(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Uri'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Uri',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Uri', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Uri') as unknown as string;
  }

  public get username(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Username'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Username',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Username', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Username') as unknown as string;
  }

}

export class MediaLiveDeleteChannelEncoderSettingsNielsenConfiguration extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDeleteChannelRequest) {
    super(scope, id);
  }

  public get distributorId(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.NielsenConfiguration.DistributorId'),
        outputPath: 'EncoderSettings.NielsenConfiguration.DistributorId',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.NielsenConfiguration.DistributorId', props);
    return resource.getResponseField('EncoderSettings.NielsenConfiguration.DistributorId') as unknown as string;
  }

  public get nielsenPcmToId3Tagging(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.NielsenConfiguration.NielsenPcmToId3Tagging'),
        outputPath: 'EncoderSettings.NielsenConfiguration.NielsenPcmToId3Tagging',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.NielsenConfiguration.NielsenPcmToId3Tagging', props);
    return resource.getResponseField('EncoderSettings.NielsenConfiguration.NielsenPcmToId3Tagging') as unknown as string;
  }

}

export class MediaLiveDeleteChannelEncoderSettingsTimecodeConfig extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDeleteChannelRequest) {
    super(scope, id);
  }

  public get source(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.TimecodeConfig.Source'),
        outputPath: 'EncoderSettings.TimecodeConfig.Source',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.TimecodeConfig.Source', props);
    return resource.getResponseField('EncoderSettings.TimecodeConfig.Source') as unknown as string;
  }

  public get syncThreshold(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.EncoderSettings.TimecodeConfig.SyncThreshold'),
        outputPath: 'EncoderSettings.TimecodeConfig.SyncThreshold',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.EncoderSettings.TimecodeConfig.SyncThreshold', props);
    return resource.getResponseField('EncoderSettings.TimecodeConfig.SyncThreshold') as unknown as number;
  }

}

export class MediaLiveDeleteChannelInputSpecification extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDeleteChannelRequest) {
    super(scope, id);
  }

  public get codec(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.InputSpecification.Codec'),
        outputPath: 'InputSpecification.Codec',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.InputSpecification.Codec', props);
    return resource.getResponseField('InputSpecification.Codec') as unknown as string;
  }

  public get maximumBitrate(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.InputSpecification.MaximumBitrate'),
        outputPath: 'InputSpecification.MaximumBitrate',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.InputSpecification.MaximumBitrate', props);
    return resource.getResponseField('InputSpecification.MaximumBitrate') as unknown as string;
  }

  public get resolution(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteChannel.InputSpecification.Resolution'),
        outputPath: 'InputSpecification.Resolution',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteChannel.InputSpecification.Resolution', props);
    return resource.getResponseField('InputSpecification.Resolution') as unknown as string;
  }

}

export class MediaLiveDeleteMultiplex extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDeleteMultiplexRequest) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplex.Arn'),
        outputPath: 'Arn',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplex.Arn', props);
    return resource.getResponseField('Arn') as unknown as string;
  }

  public get availabilityZones(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplex.AvailabilityZones'),
        outputPath: 'AvailabilityZones',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplex.AvailabilityZones', props);
    return resource.getResponseField('AvailabilityZones') as unknown as string[];
  }

  public get destinations(): shapes.MediaLiveMultiplexOutputDestination[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplex.Destinations'),
        outputPath: 'Destinations',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplex.Destinations', props);
    return resource.getResponseField('Destinations') as unknown as shapes.MediaLiveMultiplexOutputDestination[];
  }

  public get id(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplex.Id'),
        outputPath: 'Id',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplex.Id', props);
    return resource.getResponseField('Id') as unknown as string;
  }

  public get multiplexSettings(): MediaLiveDeleteMultiplexMultiplexSettings {
    return new MediaLiveDeleteMultiplexMultiplexSettings(this, 'MultiplexSettings', this.__resources, this.input);
  }

  public get name(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplex.Name'),
        outputPath: 'Name',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplex.Name', props);
    return resource.getResponseField('Name') as unknown as string;
  }

  public get pipelinesRunningCount(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplex.PipelinesRunningCount'),
        outputPath: 'PipelinesRunningCount',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplex.PipelinesRunningCount', props);
    return resource.getResponseField('PipelinesRunningCount') as unknown as number;
  }

  public get programCount(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplex.ProgramCount'),
        outputPath: 'ProgramCount',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplex.ProgramCount', props);
    return resource.getResponseField('ProgramCount') as unknown as number;
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplex.State'),
        outputPath: 'State',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplex.State', props);
    return resource.getResponseField('State') as unknown as string;
  }

  public get tags(): Record<string, string> {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplex.Tags'),
        outputPath: 'Tags',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplex.Tags', props);
    return resource.getResponseField('Tags') as unknown as Record<string, string>;
  }

}

export class MediaLiveDeleteMultiplexMultiplexSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDeleteMultiplexRequest) {
    super(scope, id);
  }

  public get maximumVideoBufferDelayMilliseconds(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplex.MultiplexSettings.MaximumVideoBufferDelayMilliseconds'),
        outputPath: 'MultiplexSettings.MaximumVideoBufferDelayMilliseconds',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplex.MultiplexSettings.MaximumVideoBufferDelayMilliseconds', props);
    return resource.getResponseField('MultiplexSettings.MaximumVideoBufferDelayMilliseconds') as unknown as number;
  }

  public get transportStreamBitrate(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplex.MultiplexSettings.TransportStreamBitrate'),
        outputPath: 'MultiplexSettings.TransportStreamBitrate',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplex.MultiplexSettings.TransportStreamBitrate', props);
    return resource.getResponseField('MultiplexSettings.TransportStreamBitrate') as unknown as number;
  }

  public get transportStreamId(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplex.MultiplexSettings.TransportStreamId'),
        outputPath: 'MultiplexSettings.TransportStreamId',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplex.MultiplexSettings.TransportStreamId', props);
    return resource.getResponseField('MultiplexSettings.TransportStreamId') as unknown as number;
  }

  public get transportStreamReservedBitrate(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplex.MultiplexSettings.TransportStreamReservedBitrate'),
        outputPath: 'MultiplexSettings.TransportStreamReservedBitrate',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplex.MultiplexSettings.TransportStreamReservedBitrate', props);
    return resource.getResponseField('MultiplexSettings.TransportStreamReservedBitrate') as unknown as number;
  }

}

export class MediaLiveDeleteMultiplexProgram extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDeleteMultiplexProgramRequest) {
    super(scope, id);
  }

  public get channelId(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplexProgram.ChannelId'),
        outputPath: 'ChannelId',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplexProgram.ChannelId', props);
    return resource.getResponseField('ChannelId') as unknown as string;
  }

  public get multiplexProgramSettings(): MediaLiveDeleteMultiplexProgramMultiplexProgramSettings {
    return new MediaLiveDeleteMultiplexProgramMultiplexProgramSettings(this, 'MultiplexProgramSettings', this.__resources, this.input);
  }

  public get packetIdentifiersMap(): MediaLiveDeleteMultiplexProgramPacketIdentifiersMap {
    return new MediaLiveDeleteMultiplexProgramPacketIdentifiersMap(this, 'PacketIdentifiersMap', this.__resources, this.input);
  }

  public get pipelineDetails(): shapes.MediaLiveMultiplexProgramPipelineDetail[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplexProgram.PipelineDetails'),
        outputPath: 'PipelineDetails',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplexProgram.PipelineDetails', props);
    return resource.getResponseField('PipelineDetails') as unknown as shapes.MediaLiveMultiplexProgramPipelineDetail[];
  }

  public get programName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplexProgram.ProgramName'),
        outputPath: 'ProgramName',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplexProgram.ProgramName', props);
    return resource.getResponseField('ProgramName') as unknown as string;
  }

}

export class MediaLiveDeleteMultiplexProgramMultiplexProgramSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDeleteMultiplexProgramRequest) {
    super(scope, id);
  }

  public get preferredChannelPipeline(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplexProgram.MultiplexProgramSettings.PreferredChannelPipeline'),
        outputPath: 'MultiplexProgramSettings.PreferredChannelPipeline',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplexProgram.MultiplexProgramSettings.PreferredChannelPipeline', props);
    return resource.getResponseField('MultiplexProgramSettings.PreferredChannelPipeline') as unknown as string;
  }

  public get programNumber(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplexProgram.MultiplexProgramSettings.ProgramNumber'),
        outputPath: 'MultiplexProgramSettings.ProgramNumber',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplexProgram.MultiplexProgramSettings.ProgramNumber', props);
    return resource.getResponseField('MultiplexProgramSettings.ProgramNumber') as unknown as number;
  }

  public get serviceDescriptor(): MediaLiveDeleteMultiplexProgramMultiplexProgramSettingsServiceDescriptor {
    return new MediaLiveDeleteMultiplexProgramMultiplexProgramSettingsServiceDescriptor(this, 'ServiceDescriptor', this.__resources, this.input);
  }

  public get videoSettings(): MediaLiveDeleteMultiplexProgramMultiplexProgramSettingsVideoSettings {
    return new MediaLiveDeleteMultiplexProgramMultiplexProgramSettingsVideoSettings(this, 'VideoSettings', this.__resources, this.input);
  }

}

export class MediaLiveDeleteMultiplexProgramMultiplexProgramSettingsServiceDescriptor extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDeleteMultiplexProgramRequest) {
    super(scope, id);
  }

  public get providerName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplexProgram.MultiplexProgramSettings.ServiceDescriptor.ProviderName'),
        outputPath: 'MultiplexProgramSettings.ServiceDescriptor.ProviderName',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplexProgram.MultiplexProgramSettings.ServiceDescriptor.ProviderName', props);
    return resource.getResponseField('MultiplexProgramSettings.ServiceDescriptor.ProviderName') as unknown as string;
  }

  public get serviceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplexProgram.MultiplexProgramSettings.ServiceDescriptor.ServiceName'),
        outputPath: 'MultiplexProgramSettings.ServiceDescriptor.ServiceName',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplexProgram.MultiplexProgramSettings.ServiceDescriptor.ServiceName', props);
    return resource.getResponseField('MultiplexProgramSettings.ServiceDescriptor.ServiceName') as unknown as string;
  }

}

export class MediaLiveDeleteMultiplexProgramMultiplexProgramSettingsVideoSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDeleteMultiplexProgramRequest) {
    super(scope, id);
  }

  public get constantBitrate(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplexProgram.MultiplexProgramSettings.VideoSettings.ConstantBitrate'),
        outputPath: 'MultiplexProgramSettings.VideoSettings.ConstantBitrate',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplexProgram.MultiplexProgramSettings.VideoSettings.ConstantBitrate', props);
    return resource.getResponseField('MultiplexProgramSettings.VideoSettings.ConstantBitrate') as unknown as number;
  }

  public get statmuxSettings(): MediaLiveDeleteMultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettings {
    return new MediaLiveDeleteMultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettings(this, 'StatmuxSettings', this.__resources, this.input);
  }

}

export class MediaLiveDeleteMultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDeleteMultiplexProgramRequest) {
    super(scope, id);
  }

  public get maximumBitrate(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.MaximumBitrate'),
        outputPath: 'MultiplexProgramSettings.VideoSettings.StatmuxSettings.MaximumBitrate',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.MaximumBitrate', props);
    return resource.getResponseField('MultiplexProgramSettings.VideoSettings.StatmuxSettings.MaximumBitrate') as unknown as number;
  }

  public get minimumBitrate(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.MinimumBitrate'),
        outputPath: 'MultiplexProgramSettings.VideoSettings.StatmuxSettings.MinimumBitrate',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.MinimumBitrate', props);
    return resource.getResponseField('MultiplexProgramSettings.VideoSettings.StatmuxSettings.MinimumBitrate') as unknown as number;
  }

  public get priority(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.Priority'),
        outputPath: 'MultiplexProgramSettings.VideoSettings.StatmuxSettings.Priority',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.Priority', props);
    return resource.getResponseField('MultiplexProgramSettings.VideoSettings.StatmuxSettings.Priority') as unknown as number;
  }

}

export class MediaLiveDeleteMultiplexProgramPacketIdentifiersMap extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDeleteMultiplexProgramRequest) {
    super(scope, id);
  }

  public get audioPids(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplexProgram.PacketIdentifiersMap.AudioPids'),
        outputPath: 'PacketIdentifiersMap.AudioPids',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplexProgram.PacketIdentifiersMap.AudioPids', props);
    return resource.getResponseField('PacketIdentifiersMap.AudioPids') as unknown as number[];
  }

  public get dvbSubPids(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplexProgram.PacketIdentifiersMap.DvbSubPids'),
        outputPath: 'PacketIdentifiersMap.DvbSubPids',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplexProgram.PacketIdentifiersMap.DvbSubPids', props);
    return resource.getResponseField('PacketIdentifiersMap.DvbSubPids') as unknown as number[];
  }

  public get dvbTeletextPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplexProgram.PacketIdentifiersMap.DvbTeletextPid'),
        outputPath: 'PacketIdentifiersMap.DvbTeletextPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplexProgram.PacketIdentifiersMap.DvbTeletextPid', props);
    return resource.getResponseField('PacketIdentifiersMap.DvbTeletextPid') as unknown as number;
  }

  public get etvPlatformPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplexProgram.PacketIdentifiersMap.EtvPlatformPid'),
        outputPath: 'PacketIdentifiersMap.EtvPlatformPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplexProgram.PacketIdentifiersMap.EtvPlatformPid', props);
    return resource.getResponseField('PacketIdentifiersMap.EtvPlatformPid') as unknown as number;
  }

  public get etvSignalPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplexProgram.PacketIdentifiersMap.EtvSignalPid'),
        outputPath: 'PacketIdentifiersMap.EtvSignalPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplexProgram.PacketIdentifiersMap.EtvSignalPid', props);
    return resource.getResponseField('PacketIdentifiersMap.EtvSignalPid') as unknown as number;
  }

  public get klvDataPids(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplexProgram.PacketIdentifiersMap.KlvDataPids'),
        outputPath: 'PacketIdentifiersMap.KlvDataPids',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplexProgram.PacketIdentifiersMap.KlvDataPids', props);
    return resource.getResponseField('PacketIdentifiersMap.KlvDataPids') as unknown as number[];
  }

  public get pcrPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplexProgram.PacketIdentifiersMap.PcrPid'),
        outputPath: 'PacketIdentifiersMap.PcrPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplexProgram.PacketIdentifiersMap.PcrPid', props);
    return resource.getResponseField('PacketIdentifiersMap.PcrPid') as unknown as number;
  }

  public get pmtPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplexProgram.PacketIdentifiersMap.PmtPid'),
        outputPath: 'PacketIdentifiersMap.PmtPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplexProgram.PacketIdentifiersMap.PmtPid', props);
    return resource.getResponseField('PacketIdentifiersMap.PmtPid') as unknown as number;
  }

  public get privateMetadataPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplexProgram.PacketIdentifiersMap.PrivateMetadataPid'),
        outputPath: 'PacketIdentifiersMap.PrivateMetadataPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplexProgram.PacketIdentifiersMap.PrivateMetadataPid', props);
    return resource.getResponseField('PacketIdentifiersMap.PrivateMetadataPid') as unknown as number;
  }

  public get scte27Pids(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplexProgram.PacketIdentifiersMap.Scte27Pids'),
        outputPath: 'PacketIdentifiersMap.Scte27Pids',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplexProgram.PacketIdentifiersMap.Scte27Pids', props);
    return resource.getResponseField('PacketIdentifiersMap.Scte27Pids') as unknown as number[];
  }

  public get scte35Pid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplexProgram.PacketIdentifiersMap.Scte35Pid'),
        outputPath: 'PacketIdentifiersMap.Scte35Pid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplexProgram.PacketIdentifiersMap.Scte35Pid', props);
    return resource.getResponseField('PacketIdentifiersMap.Scte35Pid') as unknown as number;
  }

  public get timedMetadataPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplexProgram.PacketIdentifiersMap.TimedMetadataPid'),
        outputPath: 'PacketIdentifiersMap.TimedMetadataPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplexProgram.PacketIdentifiersMap.TimedMetadataPid', props);
    return resource.getResponseField('PacketIdentifiersMap.TimedMetadataPid') as unknown as number;
  }

  public get videoPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteMultiplexProgram.PacketIdentifiersMap.VideoPid'),
        outputPath: 'PacketIdentifiersMap.VideoPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteMultiplexProgram.PacketIdentifiersMap.VideoPid', props);
    return resource.getResponseField('PacketIdentifiersMap.VideoPid') as unknown as number;
  }

}

export class MediaLiveDeleteReservation extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDeleteReservationRequest) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteReservation.Arn'),
        outputPath: 'Arn',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteReservation.Arn', props);
    return resource.getResponseField('Arn') as unknown as string;
  }

  public get count(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteReservation.Count'),
        outputPath: 'Count',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteReservation.Count', props);
    return resource.getResponseField('Count') as unknown as number;
  }

  public get currencyCode(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteReservation.CurrencyCode'),
        outputPath: 'CurrencyCode',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteReservation.CurrencyCode', props);
    return resource.getResponseField('CurrencyCode') as unknown as string;
  }

  public get duration(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteReservation.Duration'),
        outputPath: 'Duration',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteReservation.Duration', props);
    return resource.getResponseField('Duration') as unknown as number;
  }

  public get durationUnits(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteReservation.DurationUnits'),
        outputPath: 'DurationUnits',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteReservation.DurationUnits', props);
    return resource.getResponseField('DurationUnits') as unknown as string;
  }

  public get end(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteReservation.End'),
        outputPath: 'End',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteReservation.End', props);
    return resource.getResponseField('End') as unknown as string;
  }

  public get fixedPrice(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteReservation.FixedPrice'),
        outputPath: 'FixedPrice',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteReservation.FixedPrice', props);
    return resource.getResponseField('FixedPrice') as unknown as number;
  }

  public get name(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteReservation.Name'),
        outputPath: 'Name',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteReservation.Name', props);
    return resource.getResponseField('Name') as unknown as string;
  }

  public get offeringDescription(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteReservation.OfferingDescription'),
        outputPath: 'OfferingDescription',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteReservation.OfferingDescription', props);
    return resource.getResponseField('OfferingDescription') as unknown as string;
  }

  public get offeringId(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteReservation.OfferingId'),
        outputPath: 'OfferingId',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteReservation.OfferingId', props);
    return resource.getResponseField('OfferingId') as unknown as string;
  }

  public get offeringType(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteReservation.OfferingType'),
        outputPath: 'OfferingType',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteReservation.OfferingType', props);
    return resource.getResponseField('OfferingType') as unknown as string;
  }

  public get region(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteReservation.Region'),
        outputPath: 'Region',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteReservation.Region', props);
    return resource.getResponseField('Region') as unknown as string;
  }

  public get reservationId(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteReservation.ReservationId'),
        outputPath: 'ReservationId',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteReservation.ReservationId', props);
    return resource.getResponseField('ReservationId') as unknown as string;
  }

  public get resourceSpecification(): MediaLiveDeleteReservationResourceSpecification {
    return new MediaLiveDeleteReservationResourceSpecification(this, 'ResourceSpecification', this.__resources, this.input);
  }

  public get start(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteReservation.Start'),
        outputPath: 'Start',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteReservation.Start', props);
    return resource.getResponseField('Start') as unknown as string;
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteReservation.State'),
        outputPath: 'State',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteReservation.State', props);
    return resource.getResponseField('State') as unknown as string;
  }

  public get tags(): Record<string, string> {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteReservation.Tags'),
        outputPath: 'Tags',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteReservation.Tags', props);
    return resource.getResponseField('Tags') as unknown as Record<string, string>;
  }

  public get usagePrice(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteReservation.UsagePrice'),
        outputPath: 'UsagePrice',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteReservation.UsagePrice', props);
    return resource.getResponseField('UsagePrice') as unknown as number;
  }

}

export class MediaLiveDeleteReservationResourceSpecification extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDeleteReservationRequest) {
    super(scope, id);
  }

  public get channelClass(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteReservation.ResourceSpecification.ChannelClass'),
        outputPath: 'ResourceSpecification.ChannelClass',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteReservation.ResourceSpecification.ChannelClass', props);
    return resource.getResponseField('ResourceSpecification.ChannelClass') as unknown as string;
  }

  public get codec(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteReservation.ResourceSpecification.Codec'),
        outputPath: 'ResourceSpecification.Codec',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteReservation.ResourceSpecification.Codec', props);
    return resource.getResponseField('ResourceSpecification.Codec') as unknown as string;
  }

  public get maximumBitrate(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteReservation.ResourceSpecification.MaximumBitrate'),
        outputPath: 'ResourceSpecification.MaximumBitrate',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteReservation.ResourceSpecification.MaximumBitrate', props);
    return resource.getResponseField('ResourceSpecification.MaximumBitrate') as unknown as string;
  }

  public get maximumFramerate(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteReservation.ResourceSpecification.MaximumFramerate'),
        outputPath: 'ResourceSpecification.MaximumFramerate',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteReservation.ResourceSpecification.MaximumFramerate', props);
    return resource.getResponseField('ResourceSpecification.MaximumFramerate') as unknown as string;
  }

  public get resolution(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteReservation.ResourceSpecification.Resolution'),
        outputPath: 'ResourceSpecification.Resolution',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteReservation.ResourceSpecification.Resolution', props);
    return resource.getResponseField('ResourceSpecification.Resolution') as unknown as string;
  }

  public get resourceType(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteReservation.ResourceSpecification.ResourceType'),
        outputPath: 'ResourceSpecification.ResourceType',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteReservation.ResourceSpecification.ResourceType', props);
    return resource.getResponseField('ResourceSpecification.ResourceType') as unknown as string;
  }

  public get specialFeature(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteReservation.ResourceSpecification.SpecialFeature'),
        outputPath: 'ResourceSpecification.SpecialFeature',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteReservation.ResourceSpecification.SpecialFeature', props);
    return resource.getResponseField('ResourceSpecification.SpecialFeature') as unknown as string;
  }

  public get videoQuality(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'deleteReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DeleteReservation.ResourceSpecification.VideoQuality'),
        outputPath: 'ResourceSpecification.VideoQuality',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DeleteReservation.ResourceSpecification.VideoQuality', props);
    return resource.getResponseField('ResourceSpecification.VideoQuality') as unknown as string;
  }

}

export class MediaLiveDescribeChannel extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeChannelRequest) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.Arn'),
        outputPath: 'Arn',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.Arn', props);
    return resource.getResponseField('Arn') as unknown as string;
  }

  public get cdiInputSpecification(): MediaLiveDescribeChannelCdiInputSpecification {
    return new MediaLiveDescribeChannelCdiInputSpecification(this, 'CdiInputSpecification', this.__resources, this.input);
  }

  public get channelClass(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.ChannelClass'),
        outputPath: 'ChannelClass',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.ChannelClass', props);
    return resource.getResponseField('ChannelClass') as unknown as string;
  }

  public get destinations(): shapes.MediaLiveOutputDestination[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.Destinations'),
        outputPath: 'Destinations',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.Destinations', props);
    return resource.getResponseField('Destinations') as unknown as shapes.MediaLiveOutputDestination[];
  }

  public get egressEndpoints(): shapes.MediaLiveChannelEgressEndpoint[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EgressEndpoints'),
        outputPath: 'EgressEndpoints',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EgressEndpoints', props);
    return resource.getResponseField('EgressEndpoints') as unknown as shapes.MediaLiveChannelEgressEndpoint[];
  }

  public get encoderSettings(): MediaLiveDescribeChannelEncoderSettings {
    return new MediaLiveDescribeChannelEncoderSettings(this, 'EncoderSettings', this.__resources, this.input);
  }

  public get id(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.Id'),
        outputPath: 'Id',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.Id', props);
    return resource.getResponseField('Id') as unknown as string;
  }

  public get inputAttachments(): shapes.MediaLiveInputAttachment[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.InputAttachments'),
        outputPath: 'InputAttachments',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.InputAttachments', props);
    return resource.getResponseField('InputAttachments') as unknown as shapes.MediaLiveInputAttachment[];
  }

  public get inputSpecification(): MediaLiveDescribeChannelInputSpecification {
    return new MediaLiveDescribeChannelInputSpecification(this, 'InputSpecification', this.__resources, this.input);
  }

  public get logLevel(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.LogLevel'),
        outputPath: 'LogLevel',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.LogLevel', props);
    return resource.getResponseField('LogLevel') as unknown as string;
  }

  public get name(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.Name'),
        outputPath: 'Name',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.Name', props);
    return resource.getResponseField('Name') as unknown as string;
  }

  public get pipelineDetails(): shapes.MediaLivePipelineDetail[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.PipelineDetails'),
        outputPath: 'PipelineDetails',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.PipelineDetails', props);
    return resource.getResponseField('PipelineDetails') as unknown as shapes.MediaLivePipelineDetail[];
  }

  public get pipelinesRunningCount(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.PipelinesRunningCount'),
        outputPath: 'PipelinesRunningCount',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.PipelinesRunningCount', props);
    return resource.getResponseField('PipelinesRunningCount') as unknown as number;
  }

  public get roleArn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.RoleArn'),
        outputPath: 'RoleArn',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.RoleArn', props);
    return resource.getResponseField('RoleArn') as unknown as string;
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.State'),
        outputPath: 'State',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.State', props);
    return resource.getResponseField('State') as unknown as string;
  }

  public get tags(): Record<string, string> {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.Tags'),
        outputPath: 'Tags',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.Tags', props);
    return resource.getResponseField('Tags') as unknown as Record<string, string>;
  }

}

export class MediaLiveDescribeChannelCdiInputSpecification extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeChannelRequest) {
    super(scope, id);
  }

  public get resolution(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.CdiInputSpecification.Resolution'),
        outputPath: 'CdiInputSpecification.Resolution',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.CdiInputSpecification.Resolution', props);
    return resource.getResponseField('CdiInputSpecification.Resolution') as unknown as string;
  }

}

export class MediaLiveDescribeChannelEncoderSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeChannelRequest) {
    super(scope, id);
  }

  public get audioDescriptions(): shapes.MediaLiveAudioDescription[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.AudioDescriptions'),
        outputPath: 'EncoderSettings.AudioDescriptions',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.AudioDescriptions', props);
    return resource.getResponseField('EncoderSettings.AudioDescriptions') as unknown as shapes.MediaLiveAudioDescription[];
  }

  public get availBlanking(): MediaLiveDescribeChannelEncoderSettingsAvailBlanking {
    return new MediaLiveDescribeChannelEncoderSettingsAvailBlanking(this, 'AvailBlanking', this.__resources, this.input);
  }

  public get availConfiguration(): MediaLiveDescribeChannelEncoderSettingsAvailConfiguration {
    return new MediaLiveDescribeChannelEncoderSettingsAvailConfiguration(this, 'AvailConfiguration', this.__resources, this.input);
  }

  public get blackoutSlate(): MediaLiveDescribeChannelEncoderSettingsBlackoutSlate {
    return new MediaLiveDescribeChannelEncoderSettingsBlackoutSlate(this, 'BlackoutSlate', this.__resources, this.input);
  }

  public get captionDescriptions(): shapes.MediaLiveCaptionDescription[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.CaptionDescriptions'),
        outputPath: 'EncoderSettings.CaptionDescriptions',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.CaptionDescriptions', props);
    return resource.getResponseField('EncoderSettings.CaptionDescriptions') as unknown as shapes.MediaLiveCaptionDescription[];
  }

  public get featureActivations(): MediaLiveDescribeChannelEncoderSettingsFeatureActivations {
    return new MediaLiveDescribeChannelEncoderSettingsFeatureActivations(this, 'FeatureActivations', this.__resources, this.input);
  }

  public get globalConfiguration(): MediaLiveDescribeChannelEncoderSettingsGlobalConfiguration {
    return new MediaLiveDescribeChannelEncoderSettingsGlobalConfiguration(this, 'GlobalConfiguration', this.__resources, this.input);
  }

  public get nielsenConfiguration(): MediaLiveDescribeChannelEncoderSettingsNielsenConfiguration {
    return new MediaLiveDescribeChannelEncoderSettingsNielsenConfiguration(this, 'NielsenConfiguration', this.__resources, this.input);
  }

  public get outputGroups(): shapes.MediaLiveOutputGroup[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.OutputGroups'),
        outputPath: 'EncoderSettings.OutputGroups',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.OutputGroups', props);
    return resource.getResponseField('EncoderSettings.OutputGroups') as unknown as shapes.MediaLiveOutputGroup[];
  }

  public get timecodeConfig(): MediaLiveDescribeChannelEncoderSettingsTimecodeConfig {
    return new MediaLiveDescribeChannelEncoderSettingsTimecodeConfig(this, 'TimecodeConfig', this.__resources, this.input);
  }

  public get videoDescriptions(): shapes.MediaLiveVideoDescription[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.VideoDescriptions'),
        outputPath: 'EncoderSettings.VideoDescriptions',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.VideoDescriptions', props);
    return resource.getResponseField('EncoderSettings.VideoDescriptions') as unknown as shapes.MediaLiveVideoDescription[];
  }

}

export class MediaLiveDescribeChannelEncoderSettingsAvailBlanking extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeChannelRequest) {
    super(scope, id);
  }

  public get availBlankingImage(): MediaLiveDescribeChannelEncoderSettingsAvailBlankingAvailBlankingImage {
    return new MediaLiveDescribeChannelEncoderSettingsAvailBlankingAvailBlankingImage(this, 'AvailBlankingImage', this.__resources, this.input);
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.AvailBlanking.State'),
        outputPath: 'EncoderSettings.AvailBlanking.State',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.AvailBlanking.State', props);
    return resource.getResponseField('EncoderSettings.AvailBlanking.State') as unknown as string;
  }

}

export class MediaLiveDescribeChannelEncoderSettingsAvailBlankingAvailBlankingImage extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeChannelRequest) {
    super(scope, id);
  }

  public get passwordParam(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.AvailBlanking.AvailBlankingImage.PasswordParam'),
        outputPath: 'EncoderSettings.AvailBlanking.AvailBlankingImage.PasswordParam',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.AvailBlanking.AvailBlankingImage.PasswordParam', props);
    return resource.getResponseField('EncoderSettings.AvailBlanking.AvailBlankingImage.PasswordParam') as unknown as string;
  }

  public get uri(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.AvailBlanking.AvailBlankingImage.Uri'),
        outputPath: 'EncoderSettings.AvailBlanking.AvailBlankingImage.Uri',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.AvailBlanking.AvailBlankingImage.Uri', props);
    return resource.getResponseField('EncoderSettings.AvailBlanking.AvailBlankingImage.Uri') as unknown as string;
  }

  public get username(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.AvailBlanking.AvailBlankingImage.Username'),
        outputPath: 'EncoderSettings.AvailBlanking.AvailBlankingImage.Username',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.AvailBlanking.AvailBlankingImage.Username', props);
    return resource.getResponseField('EncoderSettings.AvailBlanking.AvailBlankingImage.Username') as unknown as string;
  }

}

export class MediaLiveDescribeChannelEncoderSettingsAvailConfiguration extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeChannelRequest) {
    super(scope, id);
  }

  public get availSettings(): MediaLiveDescribeChannelEncoderSettingsAvailConfigurationAvailSettings {
    return new MediaLiveDescribeChannelEncoderSettingsAvailConfigurationAvailSettings(this, 'AvailSettings', this.__resources, this.input);
  }

}

export class MediaLiveDescribeChannelEncoderSettingsAvailConfigurationAvailSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeChannelRequest) {
    super(scope, id);
  }

  public get scte35SpliceInsert(): MediaLiveDescribeChannelEncoderSettingsAvailConfigurationAvailSettingsScte35SpliceInsert {
    return new MediaLiveDescribeChannelEncoderSettingsAvailConfigurationAvailSettingsScte35SpliceInsert(this, 'Scte35SpliceInsert', this.__resources, this.input);
  }

  public get scte35TimeSignalApos(): MediaLiveDescribeChannelEncoderSettingsAvailConfigurationAvailSettingsScte35TimeSignalApos {
    return new MediaLiveDescribeChannelEncoderSettingsAvailConfigurationAvailSettingsScte35TimeSignalApos(this, 'Scte35TimeSignalApos', this.__resources, this.input);
  }

}

export class MediaLiveDescribeChannelEncoderSettingsAvailConfigurationAvailSettingsScte35SpliceInsert extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeChannelRequest) {
    super(scope, id);
  }

  public get adAvailOffset(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.AdAvailOffset'),
        outputPath: 'EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.AdAvailOffset',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.AdAvailOffset', props);
    return resource.getResponseField('EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.AdAvailOffset') as unknown as number;
  }

  public get noRegionalBlackoutFlag(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.NoRegionalBlackoutFlag'),
        outputPath: 'EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.NoRegionalBlackoutFlag',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.NoRegionalBlackoutFlag', props);
    return resource.getResponseField('EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.NoRegionalBlackoutFlag') as unknown as string;
  }

  public get webDeliveryAllowedFlag(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.WebDeliveryAllowedFlag'),
        outputPath: 'EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.WebDeliveryAllowedFlag',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.WebDeliveryAllowedFlag', props);
    return resource.getResponseField('EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.WebDeliveryAllowedFlag') as unknown as string;
  }

}

export class MediaLiveDescribeChannelEncoderSettingsAvailConfigurationAvailSettingsScte35TimeSignalApos extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeChannelRequest) {
    super(scope, id);
  }

  public get adAvailOffset(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.AdAvailOffset'),
        outputPath: 'EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.AdAvailOffset',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.AdAvailOffset', props);
    return resource.getResponseField('EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.AdAvailOffset') as unknown as number;
  }

  public get noRegionalBlackoutFlag(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.NoRegionalBlackoutFlag'),
        outputPath: 'EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.NoRegionalBlackoutFlag',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.NoRegionalBlackoutFlag', props);
    return resource.getResponseField('EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.NoRegionalBlackoutFlag') as unknown as string;
  }

  public get webDeliveryAllowedFlag(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.WebDeliveryAllowedFlag'),
        outputPath: 'EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.WebDeliveryAllowedFlag',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.WebDeliveryAllowedFlag', props);
    return resource.getResponseField('EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.WebDeliveryAllowedFlag') as unknown as string;
  }

}

export class MediaLiveDescribeChannelEncoderSettingsBlackoutSlate extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeChannelRequest) {
    super(scope, id);
  }

  public get blackoutSlateImage(): MediaLiveDescribeChannelEncoderSettingsBlackoutSlateBlackoutSlateImage {
    return new MediaLiveDescribeChannelEncoderSettingsBlackoutSlateBlackoutSlateImage(this, 'BlackoutSlateImage', this.__resources, this.input);
  }

  public get networkEndBlackout(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackout'),
        outputPath: 'EncoderSettings.BlackoutSlate.NetworkEndBlackout',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackout', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.NetworkEndBlackout') as unknown as string;
  }

  public get networkEndBlackoutImage(): MediaLiveDescribeChannelEncoderSettingsBlackoutSlateNetworkEndBlackoutImage {
    return new MediaLiveDescribeChannelEncoderSettingsBlackoutSlateNetworkEndBlackoutImage(this, 'NetworkEndBlackoutImage', this.__resources, this.input);
  }

  public get networkId(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.BlackoutSlate.NetworkId'),
        outputPath: 'EncoderSettings.BlackoutSlate.NetworkId',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.BlackoutSlate.NetworkId', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.NetworkId') as unknown as string;
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.BlackoutSlate.State'),
        outputPath: 'EncoderSettings.BlackoutSlate.State',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.BlackoutSlate.State', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.State') as unknown as string;
  }

}

export class MediaLiveDescribeChannelEncoderSettingsBlackoutSlateBlackoutSlateImage extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeChannelRequest) {
    super(scope, id);
  }

  public get passwordParam(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.PasswordParam'),
        outputPath: 'EncoderSettings.BlackoutSlate.BlackoutSlateImage.PasswordParam',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.PasswordParam', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.BlackoutSlateImage.PasswordParam') as unknown as string;
  }

  public get uri(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Uri'),
        outputPath: 'EncoderSettings.BlackoutSlate.BlackoutSlateImage.Uri',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Uri', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.BlackoutSlateImage.Uri') as unknown as string;
  }

  public get username(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Username'),
        outputPath: 'EncoderSettings.BlackoutSlate.BlackoutSlateImage.Username',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Username', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.BlackoutSlateImage.Username') as unknown as string;
  }

}

export class MediaLiveDescribeChannelEncoderSettingsBlackoutSlateNetworkEndBlackoutImage extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeChannelRequest) {
    super(scope, id);
  }

  public get passwordParam(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.PasswordParam'),
        outputPath: 'EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.PasswordParam',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.PasswordParam', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.PasswordParam') as unknown as string;
  }

  public get uri(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Uri'),
        outputPath: 'EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Uri',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Uri', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Uri') as unknown as string;
  }

  public get username(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Username'),
        outputPath: 'EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Username',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Username', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Username') as unknown as string;
  }

}

export class MediaLiveDescribeChannelEncoderSettingsFeatureActivations extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeChannelRequest) {
    super(scope, id);
  }

  public get inputPrepareScheduleActions(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.FeatureActivations.InputPrepareScheduleActions'),
        outputPath: 'EncoderSettings.FeatureActivations.InputPrepareScheduleActions',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.FeatureActivations.InputPrepareScheduleActions', props);
    return resource.getResponseField('EncoderSettings.FeatureActivations.InputPrepareScheduleActions') as unknown as string;
  }

}

export class MediaLiveDescribeChannelEncoderSettingsGlobalConfiguration extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeChannelRequest) {
    super(scope, id);
  }

  public get initialAudioGain(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.GlobalConfiguration.InitialAudioGain'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InitialAudioGain',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.GlobalConfiguration.InitialAudioGain', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InitialAudioGain') as unknown as number;
  }

  public get inputEndAction(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.GlobalConfiguration.InputEndAction'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputEndAction',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.GlobalConfiguration.InputEndAction', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputEndAction') as unknown as string;
  }

  public get inputLossBehavior(): MediaLiveDescribeChannelEncoderSettingsGlobalConfigurationInputLossBehavior {
    return new MediaLiveDescribeChannelEncoderSettingsGlobalConfigurationInputLossBehavior(this, 'InputLossBehavior', this.__resources, this.input);
  }

  public get outputLockingMode(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.GlobalConfiguration.OutputLockingMode'),
        outputPath: 'EncoderSettings.GlobalConfiguration.OutputLockingMode',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.GlobalConfiguration.OutputLockingMode', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.OutputLockingMode') as unknown as string;
  }

  public get outputTimingSource(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.GlobalConfiguration.OutputTimingSource'),
        outputPath: 'EncoderSettings.GlobalConfiguration.OutputTimingSource',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.GlobalConfiguration.OutputTimingSource', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.OutputTimingSource') as unknown as string;
  }

  public get supportLowFramerateInputs(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.GlobalConfiguration.SupportLowFramerateInputs'),
        outputPath: 'EncoderSettings.GlobalConfiguration.SupportLowFramerateInputs',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.GlobalConfiguration.SupportLowFramerateInputs', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.SupportLowFramerateInputs') as unknown as string;
  }

}

export class MediaLiveDescribeChannelEncoderSettingsGlobalConfigurationInputLossBehavior extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeChannelRequest) {
    super(scope, id);
  }

  public get blackFrameMsec(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.BlackFrameMsec'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputLossBehavior.BlackFrameMsec',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.BlackFrameMsec', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputLossBehavior.BlackFrameMsec') as unknown as number;
  }

  public get inputLossImageColor(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageColor'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageColor',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageColor', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageColor') as unknown as string;
  }

  public get inputLossImageSlate(): MediaLiveDescribeChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate {
    return new MediaLiveDescribeChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate(this, 'InputLossImageSlate', this.__resources, this.input);
  }

  public get inputLossImageType(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageType'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageType',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageType', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageType') as unknown as string;
  }

  public get repeatFrameMsec(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.RepeatFrameMsec'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputLossBehavior.RepeatFrameMsec',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.RepeatFrameMsec', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputLossBehavior.RepeatFrameMsec') as unknown as number;
  }

}

export class MediaLiveDescribeChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeChannelRequest) {
    super(scope, id);
  }

  public get passwordParam(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.PasswordParam'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.PasswordParam',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.PasswordParam', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.PasswordParam') as unknown as string;
  }

  public get uri(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Uri'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Uri',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Uri', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Uri') as unknown as string;
  }

  public get username(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Username'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Username',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Username', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Username') as unknown as string;
  }

}

export class MediaLiveDescribeChannelEncoderSettingsNielsenConfiguration extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeChannelRequest) {
    super(scope, id);
  }

  public get distributorId(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.NielsenConfiguration.DistributorId'),
        outputPath: 'EncoderSettings.NielsenConfiguration.DistributorId',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.NielsenConfiguration.DistributorId', props);
    return resource.getResponseField('EncoderSettings.NielsenConfiguration.DistributorId') as unknown as string;
  }

  public get nielsenPcmToId3Tagging(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.NielsenConfiguration.NielsenPcmToId3Tagging'),
        outputPath: 'EncoderSettings.NielsenConfiguration.NielsenPcmToId3Tagging',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.NielsenConfiguration.NielsenPcmToId3Tagging', props);
    return resource.getResponseField('EncoderSettings.NielsenConfiguration.NielsenPcmToId3Tagging') as unknown as string;
  }

}

export class MediaLiveDescribeChannelEncoderSettingsTimecodeConfig extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeChannelRequest) {
    super(scope, id);
  }

  public get source(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.TimecodeConfig.Source'),
        outputPath: 'EncoderSettings.TimecodeConfig.Source',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.TimecodeConfig.Source', props);
    return resource.getResponseField('EncoderSettings.TimecodeConfig.Source') as unknown as string;
  }

  public get syncThreshold(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.EncoderSettings.TimecodeConfig.SyncThreshold'),
        outputPath: 'EncoderSettings.TimecodeConfig.SyncThreshold',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.EncoderSettings.TimecodeConfig.SyncThreshold', props);
    return resource.getResponseField('EncoderSettings.TimecodeConfig.SyncThreshold') as unknown as number;
  }

}

export class MediaLiveDescribeChannelInputSpecification extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeChannelRequest) {
    super(scope, id);
  }

  public get codec(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.InputSpecification.Codec'),
        outputPath: 'InputSpecification.Codec',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.InputSpecification.Codec', props);
    return resource.getResponseField('InputSpecification.Codec') as unknown as string;
  }

  public get maximumBitrate(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.InputSpecification.MaximumBitrate'),
        outputPath: 'InputSpecification.MaximumBitrate',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.InputSpecification.MaximumBitrate', props);
    return resource.getResponseField('InputSpecification.MaximumBitrate') as unknown as string;
  }

  public get resolution(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeChannel.InputSpecification.Resolution'),
        outputPath: 'InputSpecification.Resolution',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeChannel.InputSpecification.Resolution', props);
    return resource.getResponseField('InputSpecification.Resolution') as unknown as string;
  }

}

export class MediaLiveDescribeInput extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeInputRequest) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInput.Arn'),
        outputPath: 'Arn',
        parameters: {
          InputId: this.input.inputId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInput.Arn', props);
    return resource.getResponseField('Arn') as unknown as string;
  }

  public get attachedChannels(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInput.AttachedChannels'),
        outputPath: 'AttachedChannels',
        parameters: {
          InputId: this.input.inputId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInput.AttachedChannels', props);
    return resource.getResponseField('AttachedChannels') as unknown as string[];
  }

  public get destinations(): shapes.MediaLiveInputDestination[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInput.Destinations'),
        outputPath: 'Destinations',
        parameters: {
          InputId: this.input.inputId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInput.Destinations', props);
    return resource.getResponseField('Destinations') as unknown as shapes.MediaLiveInputDestination[];
  }

  public get id(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInput.Id'),
        outputPath: 'Id',
        parameters: {
          InputId: this.input.inputId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInput.Id', props);
    return resource.getResponseField('Id') as unknown as string;
  }

  public get inputClass(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInput.InputClass'),
        outputPath: 'InputClass',
        parameters: {
          InputId: this.input.inputId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInput.InputClass', props);
    return resource.getResponseField('InputClass') as unknown as string;
  }

  public get inputDevices(): shapes.MediaLiveInputDeviceSettings[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInput.InputDevices'),
        outputPath: 'InputDevices',
        parameters: {
          InputId: this.input.inputId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInput.InputDevices', props);
    return resource.getResponseField('InputDevices') as unknown as shapes.MediaLiveInputDeviceSettings[];
  }

  public get inputSourceType(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInput.InputSourceType'),
        outputPath: 'InputSourceType',
        parameters: {
          InputId: this.input.inputId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInput.InputSourceType', props);
    return resource.getResponseField('InputSourceType') as unknown as string;
  }

  public get mediaConnectFlows(): shapes.MediaLiveMediaConnectFlow[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInput.MediaConnectFlows'),
        outputPath: 'MediaConnectFlows',
        parameters: {
          InputId: this.input.inputId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInput.MediaConnectFlows', props);
    return resource.getResponseField('MediaConnectFlows') as unknown as shapes.MediaLiveMediaConnectFlow[];
  }

  public get name(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInput.Name'),
        outputPath: 'Name',
        parameters: {
          InputId: this.input.inputId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInput.Name', props);
    return resource.getResponseField('Name') as unknown as string;
  }

  public get roleArn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInput.RoleArn'),
        outputPath: 'RoleArn',
        parameters: {
          InputId: this.input.inputId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInput.RoleArn', props);
    return resource.getResponseField('RoleArn') as unknown as string;
  }

  public get securityGroups(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInput.SecurityGroups'),
        outputPath: 'SecurityGroups',
        parameters: {
          InputId: this.input.inputId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInput.SecurityGroups', props);
    return resource.getResponseField('SecurityGroups') as unknown as string[];
  }

  public get sources(): shapes.MediaLiveInputSource[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInput.Sources'),
        outputPath: 'Sources',
        parameters: {
          InputId: this.input.inputId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInput.Sources', props);
    return resource.getResponseField('Sources') as unknown as shapes.MediaLiveInputSource[];
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInput.State'),
        outputPath: 'State',
        parameters: {
          InputId: this.input.inputId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInput.State', props);
    return resource.getResponseField('State') as unknown as string;
  }

  public get tags(): Record<string, string> {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInput.Tags'),
        outputPath: 'Tags',
        parameters: {
          InputId: this.input.inputId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInput.Tags', props);
    return resource.getResponseField('Tags') as unknown as Record<string, string>;
  }

  public get type(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInput.Type'),
        outputPath: 'Type',
        parameters: {
          InputId: this.input.inputId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInput.Type', props);
    return resource.getResponseField('Type') as unknown as string;
  }

}

export class MediaLiveDescribeInputDevice extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeInputDeviceRequest) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputDevice.Arn'),
        outputPath: 'Arn',
        parameters: {
          InputDeviceId: this.input.inputDeviceId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputDevice.Arn', props);
    return resource.getResponseField('Arn') as unknown as string;
  }

  public get connectionState(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputDevice.ConnectionState'),
        outputPath: 'ConnectionState',
        parameters: {
          InputDeviceId: this.input.inputDeviceId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputDevice.ConnectionState', props);
    return resource.getResponseField('ConnectionState') as unknown as string;
  }

  public get deviceSettingsSyncState(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputDevice.DeviceSettingsSyncState'),
        outputPath: 'DeviceSettingsSyncState',
        parameters: {
          InputDeviceId: this.input.inputDeviceId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputDevice.DeviceSettingsSyncState', props);
    return resource.getResponseField('DeviceSettingsSyncState') as unknown as string;
  }

  public get deviceUpdateStatus(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputDevice.DeviceUpdateStatus'),
        outputPath: 'DeviceUpdateStatus',
        parameters: {
          InputDeviceId: this.input.inputDeviceId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputDevice.DeviceUpdateStatus', props);
    return resource.getResponseField('DeviceUpdateStatus') as unknown as string;
  }

  public get hdDeviceSettings(): MediaLiveDescribeInputDeviceHdDeviceSettings {
    return new MediaLiveDescribeInputDeviceHdDeviceSettings(this, 'HdDeviceSettings', this.__resources, this.input);
  }

  public get id(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputDevice.Id'),
        outputPath: 'Id',
        parameters: {
          InputDeviceId: this.input.inputDeviceId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputDevice.Id', props);
    return resource.getResponseField('Id') as unknown as string;
  }

  public get macAddress(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputDevice.MacAddress'),
        outputPath: 'MacAddress',
        parameters: {
          InputDeviceId: this.input.inputDeviceId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputDevice.MacAddress', props);
    return resource.getResponseField('MacAddress') as unknown as string;
  }

  public get name(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputDevice.Name'),
        outputPath: 'Name',
        parameters: {
          InputDeviceId: this.input.inputDeviceId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputDevice.Name', props);
    return resource.getResponseField('Name') as unknown as string;
  }

  public get networkSettings(): MediaLiveDescribeInputDeviceNetworkSettings {
    return new MediaLiveDescribeInputDeviceNetworkSettings(this, 'NetworkSettings', this.__resources, this.input);
  }

  public get serialNumber(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputDevice.SerialNumber'),
        outputPath: 'SerialNumber',
        parameters: {
          InputDeviceId: this.input.inputDeviceId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputDevice.SerialNumber', props);
    return resource.getResponseField('SerialNumber') as unknown as string;
  }

  public get type(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputDevice.Type'),
        outputPath: 'Type',
        parameters: {
          InputDeviceId: this.input.inputDeviceId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputDevice.Type', props);
    return resource.getResponseField('Type') as unknown as string;
  }

}

export class MediaLiveDescribeInputDeviceHdDeviceSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeInputDeviceRequest) {
    super(scope, id);
  }

  public get activeInput(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputDevice.HdDeviceSettings.ActiveInput'),
        outputPath: 'HdDeviceSettings.ActiveInput',
        parameters: {
          InputDeviceId: this.input.inputDeviceId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputDevice.HdDeviceSettings.ActiveInput', props);
    return resource.getResponseField('HdDeviceSettings.ActiveInput') as unknown as string;
  }

  public get configuredInput(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputDevice.HdDeviceSettings.ConfiguredInput'),
        outputPath: 'HdDeviceSettings.ConfiguredInput',
        parameters: {
          InputDeviceId: this.input.inputDeviceId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputDevice.HdDeviceSettings.ConfiguredInput', props);
    return resource.getResponseField('HdDeviceSettings.ConfiguredInput') as unknown as string;
  }

  public get deviceState(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputDevice.HdDeviceSettings.DeviceState'),
        outputPath: 'HdDeviceSettings.DeviceState',
        parameters: {
          InputDeviceId: this.input.inputDeviceId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputDevice.HdDeviceSettings.DeviceState', props);
    return resource.getResponseField('HdDeviceSettings.DeviceState') as unknown as string;
  }

  public get framerate(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputDevice.HdDeviceSettings.Framerate'),
        outputPath: 'HdDeviceSettings.Framerate',
        parameters: {
          InputDeviceId: this.input.inputDeviceId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputDevice.HdDeviceSettings.Framerate', props);
    return resource.getResponseField('HdDeviceSettings.Framerate') as unknown as number;
  }

  public get height(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputDevice.HdDeviceSettings.Height'),
        outputPath: 'HdDeviceSettings.Height',
        parameters: {
          InputDeviceId: this.input.inputDeviceId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputDevice.HdDeviceSettings.Height', props);
    return resource.getResponseField('HdDeviceSettings.Height') as unknown as number;
  }

  public get maxBitrate(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputDevice.HdDeviceSettings.MaxBitrate'),
        outputPath: 'HdDeviceSettings.MaxBitrate',
        parameters: {
          InputDeviceId: this.input.inputDeviceId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputDevice.HdDeviceSettings.MaxBitrate', props);
    return resource.getResponseField('HdDeviceSettings.MaxBitrate') as unknown as number;
  }

  public get scanType(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputDevice.HdDeviceSettings.ScanType'),
        outputPath: 'HdDeviceSettings.ScanType',
        parameters: {
          InputDeviceId: this.input.inputDeviceId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputDevice.HdDeviceSettings.ScanType', props);
    return resource.getResponseField('HdDeviceSettings.ScanType') as unknown as string;
  }

  public get width(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputDevice.HdDeviceSettings.Width'),
        outputPath: 'HdDeviceSettings.Width',
        parameters: {
          InputDeviceId: this.input.inputDeviceId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputDevice.HdDeviceSettings.Width', props);
    return resource.getResponseField('HdDeviceSettings.Width') as unknown as number;
  }

}

export class MediaLiveDescribeInputDeviceNetworkSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeInputDeviceRequest) {
    super(scope, id);
  }

  public get dnsAddresses(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputDevice.NetworkSettings.DnsAddresses'),
        outputPath: 'NetworkSettings.DnsAddresses',
        parameters: {
          InputDeviceId: this.input.inputDeviceId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputDevice.NetworkSettings.DnsAddresses', props);
    return resource.getResponseField('NetworkSettings.DnsAddresses') as unknown as string[];
  }

  public get gateway(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputDevice.NetworkSettings.Gateway'),
        outputPath: 'NetworkSettings.Gateway',
        parameters: {
          InputDeviceId: this.input.inputDeviceId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputDevice.NetworkSettings.Gateway', props);
    return resource.getResponseField('NetworkSettings.Gateway') as unknown as string;
  }

  public get ipAddress(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputDevice.NetworkSettings.IpAddress'),
        outputPath: 'NetworkSettings.IpAddress',
        parameters: {
          InputDeviceId: this.input.inputDeviceId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputDevice.NetworkSettings.IpAddress', props);
    return resource.getResponseField('NetworkSettings.IpAddress') as unknown as string;
  }

  public get ipScheme(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputDevice.NetworkSettings.IpScheme'),
        outputPath: 'NetworkSettings.IpScheme',
        parameters: {
          InputDeviceId: this.input.inputDeviceId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputDevice.NetworkSettings.IpScheme', props);
    return resource.getResponseField('NetworkSettings.IpScheme') as unknown as string;
  }

  public get subnetMask(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputDevice.NetworkSettings.SubnetMask'),
        outputPath: 'NetworkSettings.SubnetMask',
        parameters: {
          InputDeviceId: this.input.inputDeviceId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputDevice.NetworkSettings.SubnetMask', props);
    return resource.getResponseField('NetworkSettings.SubnetMask') as unknown as string;
  }

}

export class MediaLiveDescribeInputDeviceThumbnail extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeInputDeviceThumbnailRequest) {
    super(scope, id);
  }

  public get body(): any {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputDeviceThumbnail',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputDeviceThumbnail.Body'),
        outputPath: 'Body',
        parameters: {
          InputDeviceId: this.input.inputDeviceId,
          Accept: this.input.accept,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputDeviceThumbnail.Body', props);
    return resource.getResponseField('Body') as unknown as any;
  }

  public get contentType(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputDeviceThumbnail',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputDeviceThumbnail.ContentType'),
        outputPath: 'ContentType',
        parameters: {
          InputDeviceId: this.input.inputDeviceId,
          Accept: this.input.accept,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputDeviceThumbnail.ContentType', props);
    return resource.getResponseField('ContentType') as unknown as string;
  }

  public get contentLength(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputDeviceThumbnail',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputDeviceThumbnail.ContentLength'),
        outputPath: 'ContentLength',
        parameters: {
          InputDeviceId: this.input.inputDeviceId,
          Accept: this.input.accept,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputDeviceThumbnail.ContentLength', props);
    return resource.getResponseField('ContentLength') as unknown as number;
  }

  public get eTag(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputDeviceThumbnail',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputDeviceThumbnail.ETag'),
        outputPath: 'ETag',
        parameters: {
          InputDeviceId: this.input.inputDeviceId,
          Accept: this.input.accept,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputDeviceThumbnail.ETag', props);
    return resource.getResponseField('ETag') as unknown as string;
  }

  public get lastModified(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputDeviceThumbnail',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputDeviceThumbnail.LastModified'),
        outputPath: 'LastModified',
        parameters: {
          InputDeviceId: this.input.inputDeviceId,
          Accept: this.input.accept,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputDeviceThumbnail.LastModified', props);
    return resource.getResponseField('LastModified') as unknown as string;
  }

}

export class MediaLiveDescribeInputSecurityGroup extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeInputSecurityGroupRequest) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputSecurityGroup',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputSecurityGroup.Arn'),
        outputPath: 'Arn',
        parameters: {
          InputSecurityGroupId: this.input.inputSecurityGroupId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputSecurityGroup.Arn', props);
    return resource.getResponseField('Arn') as unknown as string;
  }

  public get id(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputSecurityGroup',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputSecurityGroup.Id'),
        outputPath: 'Id',
        parameters: {
          InputSecurityGroupId: this.input.inputSecurityGroupId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputSecurityGroup.Id', props);
    return resource.getResponseField('Id') as unknown as string;
  }

  public get inputs(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputSecurityGroup',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputSecurityGroup.Inputs'),
        outputPath: 'Inputs',
        parameters: {
          InputSecurityGroupId: this.input.inputSecurityGroupId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputSecurityGroup.Inputs', props);
    return resource.getResponseField('Inputs') as unknown as string[];
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputSecurityGroup',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputSecurityGroup.State'),
        outputPath: 'State',
        parameters: {
          InputSecurityGroupId: this.input.inputSecurityGroupId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputSecurityGroup.State', props);
    return resource.getResponseField('State') as unknown as string;
  }

  public get tags(): Record<string, string> {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputSecurityGroup',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputSecurityGroup.Tags'),
        outputPath: 'Tags',
        parameters: {
          InputSecurityGroupId: this.input.inputSecurityGroupId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputSecurityGroup.Tags', props);
    return resource.getResponseField('Tags') as unknown as Record<string, string>;
  }

  public get whitelistRules(): shapes.MediaLiveInputWhitelistRule[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeInputSecurityGroup',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeInputSecurityGroup.WhitelistRules'),
        outputPath: 'WhitelistRules',
        parameters: {
          InputSecurityGroupId: this.input.inputSecurityGroupId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeInputSecurityGroup.WhitelistRules', props);
    return resource.getResponseField('WhitelistRules') as unknown as shapes.MediaLiveInputWhitelistRule[];
  }

}

export class MediaLiveDescribeMultiplex extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeMultiplexRequest) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplex.Arn'),
        outputPath: 'Arn',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplex.Arn', props);
    return resource.getResponseField('Arn') as unknown as string;
  }

  public get availabilityZones(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplex.AvailabilityZones'),
        outputPath: 'AvailabilityZones',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplex.AvailabilityZones', props);
    return resource.getResponseField('AvailabilityZones') as unknown as string[];
  }

  public get destinations(): shapes.MediaLiveMultiplexOutputDestination[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplex.Destinations'),
        outputPath: 'Destinations',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplex.Destinations', props);
    return resource.getResponseField('Destinations') as unknown as shapes.MediaLiveMultiplexOutputDestination[];
  }

  public get id(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplex.Id'),
        outputPath: 'Id',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplex.Id', props);
    return resource.getResponseField('Id') as unknown as string;
  }

  public get multiplexSettings(): MediaLiveDescribeMultiplexMultiplexSettings {
    return new MediaLiveDescribeMultiplexMultiplexSettings(this, 'MultiplexSettings', this.__resources, this.input);
  }

  public get name(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplex.Name'),
        outputPath: 'Name',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplex.Name', props);
    return resource.getResponseField('Name') as unknown as string;
  }

  public get pipelinesRunningCount(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplex.PipelinesRunningCount'),
        outputPath: 'PipelinesRunningCount',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplex.PipelinesRunningCount', props);
    return resource.getResponseField('PipelinesRunningCount') as unknown as number;
  }

  public get programCount(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplex.ProgramCount'),
        outputPath: 'ProgramCount',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplex.ProgramCount', props);
    return resource.getResponseField('ProgramCount') as unknown as number;
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplex.State'),
        outputPath: 'State',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplex.State', props);
    return resource.getResponseField('State') as unknown as string;
  }

  public get tags(): Record<string, string> {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplex.Tags'),
        outputPath: 'Tags',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplex.Tags', props);
    return resource.getResponseField('Tags') as unknown as Record<string, string>;
  }

}

export class MediaLiveDescribeMultiplexMultiplexSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeMultiplexRequest) {
    super(scope, id);
  }

  public get maximumVideoBufferDelayMilliseconds(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplex.MultiplexSettings.MaximumVideoBufferDelayMilliseconds'),
        outputPath: 'MultiplexSettings.MaximumVideoBufferDelayMilliseconds',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplex.MultiplexSettings.MaximumVideoBufferDelayMilliseconds', props);
    return resource.getResponseField('MultiplexSettings.MaximumVideoBufferDelayMilliseconds') as unknown as number;
  }

  public get transportStreamBitrate(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplex.MultiplexSettings.TransportStreamBitrate'),
        outputPath: 'MultiplexSettings.TransportStreamBitrate',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplex.MultiplexSettings.TransportStreamBitrate', props);
    return resource.getResponseField('MultiplexSettings.TransportStreamBitrate') as unknown as number;
  }

  public get transportStreamId(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplex.MultiplexSettings.TransportStreamId'),
        outputPath: 'MultiplexSettings.TransportStreamId',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplex.MultiplexSettings.TransportStreamId', props);
    return resource.getResponseField('MultiplexSettings.TransportStreamId') as unknown as number;
  }

  public get transportStreamReservedBitrate(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplex.MultiplexSettings.TransportStreamReservedBitrate'),
        outputPath: 'MultiplexSettings.TransportStreamReservedBitrate',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplex.MultiplexSettings.TransportStreamReservedBitrate', props);
    return resource.getResponseField('MultiplexSettings.TransportStreamReservedBitrate') as unknown as number;
  }

}

export class MediaLiveDescribeMultiplexProgram extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeMultiplexProgramRequest) {
    super(scope, id);
  }

  public get channelId(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplexProgram.ChannelId'),
        outputPath: 'ChannelId',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplexProgram.ChannelId', props);
    return resource.getResponseField('ChannelId') as unknown as string;
  }

  public get multiplexProgramSettings(): MediaLiveDescribeMultiplexProgramMultiplexProgramSettings {
    return new MediaLiveDescribeMultiplexProgramMultiplexProgramSettings(this, 'MultiplexProgramSettings', this.__resources, this.input);
  }

  public get packetIdentifiersMap(): MediaLiveDescribeMultiplexProgramPacketIdentifiersMap {
    return new MediaLiveDescribeMultiplexProgramPacketIdentifiersMap(this, 'PacketIdentifiersMap', this.__resources, this.input);
  }

  public get pipelineDetails(): shapes.MediaLiveMultiplexProgramPipelineDetail[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplexProgram.PipelineDetails'),
        outputPath: 'PipelineDetails',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplexProgram.PipelineDetails', props);
    return resource.getResponseField('PipelineDetails') as unknown as shapes.MediaLiveMultiplexProgramPipelineDetail[];
  }

  public get programName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplexProgram.ProgramName'),
        outputPath: 'ProgramName',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplexProgram.ProgramName', props);
    return resource.getResponseField('ProgramName') as unknown as string;
  }

}

export class MediaLiveDescribeMultiplexProgramMultiplexProgramSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeMultiplexProgramRequest) {
    super(scope, id);
  }

  public get preferredChannelPipeline(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplexProgram.MultiplexProgramSettings.PreferredChannelPipeline'),
        outputPath: 'MultiplexProgramSettings.PreferredChannelPipeline',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplexProgram.MultiplexProgramSettings.PreferredChannelPipeline', props);
    return resource.getResponseField('MultiplexProgramSettings.PreferredChannelPipeline') as unknown as string;
  }

  public get programNumber(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplexProgram.MultiplexProgramSettings.ProgramNumber'),
        outputPath: 'MultiplexProgramSettings.ProgramNumber',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplexProgram.MultiplexProgramSettings.ProgramNumber', props);
    return resource.getResponseField('MultiplexProgramSettings.ProgramNumber') as unknown as number;
  }

  public get serviceDescriptor(): MediaLiveDescribeMultiplexProgramMultiplexProgramSettingsServiceDescriptor {
    return new MediaLiveDescribeMultiplexProgramMultiplexProgramSettingsServiceDescriptor(this, 'ServiceDescriptor', this.__resources, this.input);
  }

  public get videoSettings(): MediaLiveDescribeMultiplexProgramMultiplexProgramSettingsVideoSettings {
    return new MediaLiveDescribeMultiplexProgramMultiplexProgramSettingsVideoSettings(this, 'VideoSettings', this.__resources, this.input);
  }

}

export class MediaLiveDescribeMultiplexProgramMultiplexProgramSettingsServiceDescriptor extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeMultiplexProgramRequest) {
    super(scope, id);
  }

  public get providerName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplexProgram.MultiplexProgramSettings.ServiceDescriptor.ProviderName'),
        outputPath: 'MultiplexProgramSettings.ServiceDescriptor.ProviderName',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplexProgram.MultiplexProgramSettings.ServiceDescriptor.ProviderName', props);
    return resource.getResponseField('MultiplexProgramSettings.ServiceDescriptor.ProviderName') as unknown as string;
  }

  public get serviceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplexProgram.MultiplexProgramSettings.ServiceDescriptor.ServiceName'),
        outputPath: 'MultiplexProgramSettings.ServiceDescriptor.ServiceName',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplexProgram.MultiplexProgramSettings.ServiceDescriptor.ServiceName', props);
    return resource.getResponseField('MultiplexProgramSettings.ServiceDescriptor.ServiceName') as unknown as string;
  }

}

export class MediaLiveDescribeMultiplexProgramMultiplexProgramSettingsVideoSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeMultiplexProgramRequest) {
    super(scope, id);
  }

  public get constantBitrate(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplexProgram.MultiplexProgramSettings.VideoSettings.ConstantBitrate'),
        outputPath: 'MultiplexProgramSettings.VideoSettings.ConstantBitrate',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplexProgram.MultiplexProgramSettings.VideoSettings.ConstantBitrate', props);
    return resource.getResponseField('MultiplexProgramSettings.VideoSettings.ConstantBitrate') as unknown as number;
  }

  public get statmuxSettings(): MediaLiveDescribeMultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettings {
    return new MediaLiveDescribeMultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettings(this, 'StatmuxSettings', this.__resources, this.input);
  }

}

export class MediaLiveDescribeMultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeMultiplexProgramRequest) {
    super(scope, id);
  }

  public get maximumBitrate(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.MaximumBitrate'),
        outputPath: 'MultiplexProgramSettings.VideoSettings.StatmuxSettings.MaximumBitrate',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.MaximumBitrate', props);
    return resource.getResponseField('MultiplexProgramSettings.VideoSettings.StatmuxSettings.MaximumBitrate') as unknown as number;
  }

  public get minimumBitrate(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.MinimumBitrate'),
        outputPath: 'MultiplexProgramSettings.VideoSettings.StatmuxSettings.MinimumBitrate',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.MinimumBitrate', props);
    return resource.getResponseField('MultiplexProgramSettings.VideoSettings.StatmuxSettings.MinimumBitrate') as unknown as number;
  }

  public get priority(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.Priority'),
        outputPath: 'MultiplexProgramSettings.VideoSettings.StatmuxSettings.Priority',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.Priority', props);
    return resource.getResponseField('MultiplexProgramSettings.VideoSettings.StatmuxSettings.Priority') as unknown as number;
  }

}

export class MediaLiveDescribeMultiplexProgramPacketIdentifiersMap extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeMultiplexProgramRequest) {
    super(scope, id);
  }

  public get audioPids(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplexProgram.PacketIdentifiersMap.AudioPids'),
        outputPath: 'PacketIdentifiersMap.AudioPids',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplexProgram.PacketIdentifiersMap.AudioPids', props);
    return resource.getResponseField('PacketIdentifiersMap.AudioPids') as unknown as number[];
  }

  public get dvbSubPids(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplexProgram.PacketIdentifiersMap.DvbSubPids'),
        outputPath: 'PacketIdentifiersMap.DvbSubPids',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplexProgram.PacketIdentifiersMap.DvbSubPids', props);
    return resource.getResponseField('PacketIdentifiersMap.DvbSubPids') as unknown as number[];
  }

  public get dvbTeletextPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplexProgram.PacketIdentifiersMap.DvbTeletextPid'),
        outputPath: 'PacketIdentifiersMap.DvbTeletextPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplexProgram.PacketIdentifiersMap.DvbTeletextPid', props);
    return resource.getResponseField('PacketIdentifiersMap.DvbTeletextPid') as unknown as number;
  }

  public get etvPlatformPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplexProgram.PacketIdentifiersMap.EtvPlatformPid'),
        outputPath: 'PacketIdentifiersMap.EtvPlatformPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplexProgram.PacketIdentifiersMap.EtvPlatformPid', props);
    return resource.getResponseField('PacketIdentifiersMap.EtvPlatformPid') as unknown as number;
  }

  public get etvSignalPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplexProgram.PacketIdentifiersMap.EtvSignalPid'),
        outputPath: 'PacketIdentifiersMap.EtvSignalPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplexProgram.PacketIdentifiersMap.EtvSignalPid', props);
    return resource.getResponseField('PacketIdentifiersMap.EtvSignalPid') as unknown as number;
  }

  public get klvDataPids(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplexProgram.PacketIdentifiersMap.KlvDataPids'),
        outputPath: 'PacketIdentifiersMap.KlvDataPids',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplexProgram.PacketIdentifiersMap.KlvDataPids', props);
    return resource.getResponseField('PacketIdentifiersMap.KlvDataPids') as unknown as number[];
  }

  public get pcrPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplexProgram.PacketIdentifiersMap.PcrPid'),
        outputPath: 'PacketIdentifiersMap.PcrPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplexProgram.PacketIdentifiersMap.PcrPid', props);
    return resource.getResponseField('PacketIdentifiersMap.PcrPid') as unknown as number;
  }

  public get pmtPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplexProgram.PacketIdentifiersMap.PmtPid'),
        outputPath: 'PacketIdentifiersMap.PmtPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplexProgram.PacketIdentifiersMap.PmtPid', props);
    return resource.getResponseField('PacketIdentifiersMap.PmtPid') as unknown as number;
  }

  public get privateMetadataPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplexProgram.PacketIdentifiersMap.PrivateMetadataPid'),
        outputPath: 'PacketIdentifiersMap.PrivateMetadataPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplexProgram.PacketIdentifiersMap.PrivateMetadataPid', props);
    return resource.getResponseField('PacketIdentifiersMap.PrivateMetadataPid') as unknown as number;
  }

  public get scte27Pids(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplexProgram.PacketIdentifiersMap.Scte27Pids'),
        outputPath: 'PacketIdentifiersMap.Scte27Pids',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplexProgram.PacketIdentifiersMap.Scte27Pids', props);
    return resource.getResponseField('PacketIdentifiersMap.Scte27Pids') as unknown as number[];
  }

  public get scte35Pid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplexProgram.PacketIdentifiersMap.Scte35Pid'),
        outputPath: 'PacketIdentifiersMap.Scte35Pid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplexProgram.PacketIdentifiersMap.Scte35Pid', props);
    return resource.getResponseField('PacketIdentifiersMap.Scte35Pid') as unknown as number;
  }

  public get timedMetadataPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplexProgram.PacketIdentifiersMap.TimedMetadataPid'),
        outputPath: 'PacketIdentifiersMap.TimedMetadataPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplexProgram.PacketIdentifiersMap.TimedMetadataPid', props);
    return resource.getResponseField('PacketIdentifiersMap.TimedMetadataPid') as unknown as number;
  }

  public get videoPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeMultiplexProgram.PacketIdentifiersMap.VideoPid'),
        outputPath: 'PacketIdentifiersMap.VideoPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeMultiplexProgram.PacketIdentifiersMap.VideoPid', props);
    return resource.getResponseField('PacketIdentifiersMap.VideoPid') as unknown as number;
  }

}

export class MediaLiveDescribeOffering extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeOfferingRequest) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeOffering.Arn'),
        outputPath: 'Arn',
        parameters: {
          OfferingId: this.input.offeringId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeOffering.Arn', props);
    return resource.getResponseField('Arn') as unknown as string;
  }

  public get currencyCode(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeOffering.CurrencyCode'),
        outputPath: 'CurrencyCode',
        parameters: {
          OfferingId: this.input.offeringId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeOffering.CurrencyCode', props);
    return resource.getResponseField('CurrencyCode') as unknown as string;
  }

  public get duration(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeOffering.Duration'),
        outputPath: 'Duration',
        parameters: {
          OfferingId: this.input.offeringId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeOffering.Duration', props);
    return resource.getResponseField('Duration') as unknown as number;
  }

  public get durationUnits(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeOffering.DurationUnits'),
        outputPath: 'DurationUnits',
        parameters: {
          OfferingId: this.input.offeringId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeOffering.DurationUnits', props);
    return resource.getResponseField('DurationUnits') as unknown as string;
  }

  public get fixedPrice(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeOffering.FixedPrice'),
        outputPath: 'FixedPrice',
        parameters: {
          OfferingId: this.input.offeringId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeOffering.FixedPrice', props);
    return resource.getResponseField('FixedPrice') as unknown as number;
  }

  public get offeringDescription(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeOffering.OfferingDescription'),
        outputPath: 'OfferingDescription',
        parameters: {
          OfferingId: this.input.offeringId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeOffering.OfferingDescription', props);
    return resource.getResponseField('OfferingDescription') as unknown as string;
  }

  public get offeringId(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeOffering.OfferingId'),
        outputPath: 'OfferingId',
        parameters: {
          OfferingId: this.input.offeringId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeOffering.OfferingId', props);
    return resource.getResponseField('OfferingId') as unknown as string;
  }

  public get offeringType(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeOffering.OfferingType'),
        outputPath: 'OfferingType',
        parameters: {
          OfferingId: this.input.offeringId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeOffering.OfferingType', props);
    return resource.getResponseField('OfferingType') as unknown as string;
  }

  public get region(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeOffering.Region'),
        outputPath: 'Region',
        parameters: {
          OfferingId: this.input.offeringId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeOffering.Region', props);
    return resource.getResponseField('Region') as unknown as string;
  }

  public get resourceSpecification(): MediaLiveDescribeOfferingResourceSpecification {
    return new MediaLiveDescribeOfferingResourceSpecification(this, 'ResourceSpecification', this.__resources, this.input);
  }

  public get usagePrice(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeOffering.UsagePrice'),
        outputPath: 'UsagePrice',
        parameters: {
          OfferingId: this.input.offeringId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeOffering.UsagePrice', props);
    return resource.getResponseField('UsagePrice') as unknown as number;
  }

}

export class MediaLiveDescribeOfferingResourceSpecification extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeOfferingRequest) {
    super(scope, id);
  }

  public get channelClass(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeOffering.ResourceSpecification.ChannelClass'),
        outputPath: 'ResourceSpecification.ChannelClass',
        parameters: {
          OfferingId: this.input.offeringId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeOffering.ResourceSpecification.ChannelClass', props);
    return resource.getResponseField('ResourceSpecification.ChannelClass') as unknown as string;
  }

  public get codec(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeOffering.ResourceSpecification.Codec'),
        outputPath: 'ResourceSpecification.Codec',
        parameters: {
          OfferingId: this.input.offeringId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeOffering.ResourceSpecification.Codec', props);
    return resource.getResponseField('ResourceSpecification.Codec') as unknown as string;
  }

  public get maximumBitrate(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeOffering.ResourceSpecification.MaximumBitrate'),
        outputPath: 'ResourceSpecification.MaximumBitrate',
        parameters: {
          OfferingId: this.input.offeringId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeOffering.ResourceSpecification.MaximumBitrate', props);
    return resource.getResponseField('ResourceSpecification.MaximumBitrate') as unknown as string;
  }

  public get maximumFramerate(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeOffering.ResourceSpecification.MaximumFramerate'),
        outputPath: 'ResourceSpecification.MaximumFramerate',
        parameters: {
          OfferingId: this.input.offeringId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeOffering.ResourceSpecification.MaximumFramerate', props);
    return resource.getResponseField('ResourceSpecification.MaximumFramerate') as unknown as string;
  }

  public get resolution(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeOffering.ResourceSpecification.Resolution'),
        outputPath: 'ResourceSpecification.Resolution',
        parameters: {
          OfferingId: this.input.offeringId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeOffering.ResourceSpecification.Resolution', props);
    return resource.getResponseField('ResourceSpecification.Resolution') as unknown as string;
  }

  public get resourceType(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeOffering.ResourceSpecification.ResourceType'),
        outputPath: 'ResourceSpecification.ResourceType',
        parameters: {
          OfferingId: this.input.offeringId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeOffering.ResourceSpecification.ResourceType', props);
    return resource.getResponseField('ResourceSpecification.ResourceType') as unknown as string;
  }

  public get specialFeature(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeOffering.ResourceSpecification.SpecialFeature'),
        outputPath: 'ResourceSpecification.SpecialFeature',
        parameters: {
          OfferingId: this.input.offeringId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeOffering.ResourceSpecification.SpecialFeature', props);
    return resource.getResponseField('ResourceSpecification.SpecialFeature') as unknown as string;
  }

  public get videoQuality(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeOffering.ResourceSpecification.VideoQuality'),
        outputPath: 'ResourceSpecification.VideoQuality',
        parameters: {
          OfferingId: this.input.offeringId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeOffering.ResourceSpecification.VideoQuality', props);
    return resource.getResponseField('ResourceSpecification.VideoQuality') as unknown as string;
  }

}

export class MediaLiveDescribeReservation extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeReservationRequest) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeReservation.Arn'),
        outputPath: 'Arn',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeReservation.Arn', props);
    return resource.getResponseField('Arn') as unknown as string;
  }

  public get count(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeReservation.Count'),
        outputPath: 'Count',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeReservation.Count', props);
    return resource.getResponseField('Count') as unknown as number;
  }

  public get currencyCode(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeReservation.CurrencyCode'),
        outputPath: 'CurrencyCode',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeReservation.CurrencyCode', props);
    return resource.getResponseField('CurrencyCode') as unknown as string;
  }

  public get duration(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeReservation.Duration'),
        outputPath: 'Duration',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeReservation.Duration', props);
    return resource.getResponseField('Duration') as unknown as number;
  }

  public get durationUnits(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeReservation.DurationUnits'),
        outputPath: 'DurationUnits',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeReservation.DurationUnits', props);
    return resource.getResponseField('DurationUnits') as unknown as string;
  }

  public get end(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeReservation.End'),
        outputPath: 'End',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeReservation.End', props);
    return resource.getResponseField('End') as unknown as string;
  }

  public get fixedPrice(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeReservation.FixedPrice'),
        outputPath: 'FixedPrice',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeReservation.FixedPrice', props);
    return resource.getResponseField('FixedPrice') as unknown as number;
  }

  public get name(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeReservation.Name'),
        outputPath: 'Name',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeReservation.Name', props);
    return resource.getResponseField('Name') as unknown as string;
  }

  public get offeringDescription(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeReservation.OfferingDescription'),
        outputPath: 'OfferingDescription',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeReservation.OfferingDescription', props);
    return resource.getResponseField('OfferingDescription') as unknown as string;
  }

  public get offeringId(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeReservation.OfferingId'),
        outputPath: 'OfferingId',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeReservation.OfferingId', props);
    return resource.getResponseField('OfferingId') as unknown as string;
  }

  public get offeringType(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeReservation.OfferingType'),
        outputPath: 'OfferingType',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeReservation.OfferingType', props);
    return resource.getResponseField('OfferingType') as unknown as string;
  }

  public get region(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeReservation.Region'),
        outputPath: 'Region',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeReservation.Region', props);
    return resource.getResponseField('Region') as unknown as string;
  }

  public get reservationId(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeReservation.ReservationId'),
        outputPath: 'ReservationId',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeReservation.ReservationId', props);
    return resource.getResponseField('ReservationId') as unknown as string;
  }

  public get resourceSpecification(): MediaLiveDescribeReservationResourceSpecification {
    return new MediaLiveDescribeReservationResourceSpecification(this, 'ResourceSpecification', this.__resources, this.input);
  }

  public get start(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeReservation.Start'),
        outputPath: 'Start',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeReservation.Start', props);
    return resource.getResponseField('Start') as unknown as string;
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeReservation.State'),
        outputPath: 'State',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeReservation.State', props);
    return resource.getResponseField('State') as unknown as string;
  }

  public get tags(): Record<string, string> {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeReservation.Tags'),
        outputPath: 'Tags',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeReservation.Tags', props);
    return resource.getResponseField('Tags') as unknown as Record<string, string>;
  }

  public get usagePrice(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeReservation.UsagePrice'),
        outputPath: 'UsagePrice',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeReservation.UsagePrice', props);
    return resource.getResponseField('UsagePrice') as unknown as number;
  }

}

export class MediaLiveDescribeReservationResourceSpecification extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeReservationRequest) {
    super(scope, id);
  }

  public get channelClass(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeReservation.ResourceSpecification.ChannelClass'),
        outputPath: 'ResourceSpecification.ChannelClass',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeReservation.ResourceSpecification.ChannelClass', props);
    return resource.getResponseField('ResourceSpecification.ChannelClass') as unknown as string;
  }

  public get codec(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeReservation.ResourceSpecification.Codec'),
        outputPath: 'ResourceSpecification.Codec',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeReservation.ResourceSpecification.Codec', props);
    return resource.getResponseField('ResourceSpecification.Codec') as unknown as string;
  }

  public get maximumBitrate(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeReservation.ResourceSpecification.MaximumBitrate'),
        outputPath: 'ResourceSpecification.MaximumBitrate',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeReservation.ResourceSpecification.MaximumBitrate', props);
    return resource.getResponseField('ResourceSpecification.MaximumBitrate') as unknown as string;
  }

  public get maximumFramerate(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeReservation.ResourceSpecification.MaximumFramerate'),
        outputPath: 'ResourceSpecification.MaximumFramerate',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeReservation.ResourceSpecification.MaximumFramerate', props);
    return resource.getResponseField('ResourceSpecification.MaximumFramerate') as unknown as string;
  }

  public get resolution(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeReservation.ResourceSpecification.Resolution'),
        outputPath: 'ResourceSpecification.Resolution',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeReservation.ResourceSpecification.Resolution', props);
    return resource.getResponseField('ResourceSpecification.Resolution') as unknown as string;
  }

  public get resourceType(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeReservation.ResourceSpecification.ResourceType'),
        outputPath: 'ResourceSpecification.ResourceType',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeReservation.ResourceSpecification.ResourceType', props);
    return resource.getResponseField('ResourceSpecification.ResourceType') as unknown as string;
  }

  public get specialFeature(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeReservation.ResourceSpecification.SpecialFeature'),
        outputPath: 'ResourceSpecification.SpecialFeature',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeReservation.ResourceSpecification.SpecialFeature', props);
    return resource.getResponseField('ResourceSpecification.SpecialFeature') as unknown as string;
  }

  public get videoQuality(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeReservation.ResourceSpecification.VideoQuality'),
        outputPath: 'ResourceSpecification.VideoQuality',
        parameters: {
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeReservation.ResourceSpecification.VideoQuality', props);
    return resource.getResponseField('ResourceSpecification.VideoQuality') as unknown as string;
  }

}

export class MediaLiveDescribeSchedule extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveDescribeScheduleRequest) {
    super(scope, id);
  }

  public get nextToken(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeSchedule',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeSchedule.NextToken'),
        outputPath: 'NextToken',
        parameters: {
          ChannelId: this.input.channelId,
          MaxResults: this.input.maxResults,
          NextToken: this.input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeSchedule.NextToken', props);
    return resource.getResponseField('NextToken') as unknown as string;
  }

  public get scheduleActions(): shapes.MediaLiveScheduleAction[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'describeSchedule',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.DescribeSchedule.ScheduleActions'),
        outputPath: 'ScheduleActions',
        parameters: {
          ChannelId: this.input.channelId,
          MaxResults: this.input.maxResults,
          NextToken: this.input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'DescribeSchedule.ScheduleActions', props);
    return resource.getResponseField('ScheduleActions') as unknown as shapes.MediaLiveScheduleAction[];
  }

}

export class MediaLiveListChannels extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveListChannelsRequest) {
    super(scope, id);
  }

  public get channels(): shapes.MediaLiveChannelSummary[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listChannels',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.ListChannels.Channels'),
        outputPath: 'Channels',
        parameters: {
          MaxResults: this.input.maxResults,
          NextToken: this.input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListChannels.Channels', props);
    return resource.getResponseField('Channels') as unknown as shapes.MediaLiveChannelSummary[];
  }

  public get nextToken(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listChannels',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.ListChannels.NextToken'),
        outputPath: 'NextToken',
        parameters: {
          MaxResults: this.input.maxResults,
          NextToken: this.input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListChannels.NextToken', props);
    return resource.getResponseField('NextToken') as unknown as string;
  }

}

export class MediaLiveListInputDeviceTransfers extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveListInputDeviceTransfersRequest) {
    super(scope, id);
  }

  public get inputDeviceTransfers(): shapes.MediaLiveTransferringInputDeviceSummary[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listInputDeviceTransfers',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.ListInputDeviceTransfers.InputDeviceTransfers'),
        outputPath: 'InputDeviceTransfers',
        parameters: {
          MaxResults: this.input.maxResults,
          NextToken: this.input.nextToken,
          TransferType: this.input.transferType,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListInputDeviceTransfers.InputDeviceTransfers', props);
    return resource.getResponseField('InputDeviceTransfers') as unknown as shapes.MediaLiveTransferringInputDeviceSummary[];
  }

  public get nextToken(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listInputDeviceTransfers',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.ListInputDeviceTransfers.NextToken'),
        outputPath: 'NextToken',
        parameters: {
          MaxResults: this.input.maxResults,
          NextToken: this.input.nextToken,
          TransferType: this.input.transferType,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListInputDeviceTransfers.NextToken', props);
    return resource.getResponseField('NextToken') as unknown as string;
  }

}

export class MediaLiveListInputDevices extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveListInputDevicesRequest) {
    super(scope, id);
  }

  public get inputDevices(): shapes.MediaLiveInputDeviceSummary[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listInputDevices',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.ListInputDevices.InputDevices'),
        outputPath: 'InputDevices',
        parameters: {
          MaxResults: this.input.maxResults,
          NextToken: this.input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListInputDevices.InputDevices', props);
    return resource.getResponseField('InputDevices') as unknown as shapes.MediaLiveInputDeviceSummary[];
  }

  public get nextToken(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listInputDevices',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.ListInputDevices.NextToken'),
        outputPath: 'NextToken',
        parameters: {
          MaxResults: this.input.maxResults,
          NextToken: this.input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListInputDevices.NextToken', props);
    return resource.getResponseField('NextToken') as unknown as string;
  }

}

export class MediaLiveListInputSecurityGroups extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveListInputSecurityGroupsRequest) {
    super(scope, id);
  }

  public get inputSecurityGroups(): shapes.MediaLiveInputSecurityGroup[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listInputSecurityGroups',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.ListInputSecurityGroups.InputSecurityGroups'),
        outputPath: 'InputSecurityGroups',
        parameters: {
          MaxResults: this.input.maxResults,
          NextToken: this.input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListInputSecurityGroups.InputSecurityGroups', props);
    return resource.getResponseField('InputSecurityGroups') as unknown as shapes.MediaLiveInputSecurityGroup[];
  }

  public get nextToken(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listInputSecurityGroups',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.ListInputSecurityGroups.NextToken'),
        outputPath: 'NextToken',
        parameters: {
          MaxResults: this.input.maxResults,
          NextToken: this.input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListInputSecurityGroups.NextToken', props);
    return resource.getResponseField('NextToken') as unknown as string;
  }

}

export class MediaLiveListInputs extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveListInputsRequest) {
    super(scope, id);
  }

  public get inputs(): shapes.MediaLiveInput[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listInputs',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.ListInputs.Inputs'),
        outputPath: 'Inputs',
        parameters: {
          MaxResults: this.input.maxResults,
          NextToken: this.input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListInputs.Inputs', props);
    return resource.getResponseField('Inputs') as unknown as shapes.MediaLiveInput[];
  }

  public get nextToken(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listInputs',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.ListInputs.NextToken'),
        outputPath: 'NextToken',
        parameters: {
          MaxResults: this.input.maxResults,
          NextToken: this.input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListInputs.NextToken', props);
    return resource.getResponseField('NextToken') as unknown as string;
  }

}

export class MediaLiveListMultiplexPrograms extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveListMultiplexProgramsRequest) {
    super(scope, id);
  }

  public get multiplexPrograms(): shapes.MediaLiveMultiplexProgramSummary[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listMultiplexPrograms',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.ListMultiplexPrograms.MultiplexPrograms'),
        outputPath: 'MultiplexPrograms',
        parameters: {
          MaxResults: this.input.maxResults,
          MultiplexId: this.input.multiplexId,
          NextToken: this.input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListMultiplexPrograms.MultiplexPrograms', props);
    return resource.getResponseField('MultiplexPrograms') as unknown as shapes.MediaLiveMultiplexProgramSummary[];
  }

  public get nextToken(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listMultiplexPrograms',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.ListMultiplexPrograms.NextToken'),
        outputPath: 'NextToken',
        parameters: {
          MaxResults: this.input.maxResults,
          MultiplexId: this.input.multiplexId,
          NextToken: this.input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListMultiplexPrograms.NextToken', props);
    return resource.getResponseField('NextToken') as unknown as string;
  }

}

export class MediaLiveListMultiplexes extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveListMultiplexesRequest) {
    super(scope, id);
  }

  public get multiplexes(): shapes.MediaLiveMultiplexSummary[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listMultiplexes',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.ListMultiplexes.Multiplexes'),
        outputPath: 'Multiplexes',
        parameters: {
          MaxResults: this.input.maxResults,
          NextToken: this.input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListMultiplexes.Multiplexes', props);
    return resource.getResponseField('Multiplexes') as unknown as shapes.MediaLiveMultiplexSummary[];
  }

  public get nextToken(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listMultiplexes',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.ListMultiplexes.NextToken'),
        outputPath: 'NextToken',
        parameters: {
          MaxResults: this.input.maxResults,
          NextToken: this.input.nextToken,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListMultiplexes.NextToken', props);
    return resource.getResponseField('NextToken') as unknown as string;
  }

}

export class MediaLiveListOfferings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveListOfferingsRequest) {
    super(scope, id);
  }

  public get nextToken(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listOfferings',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.ListOfferings.NextToken'),
        outputPath: 'NextToken',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelConfiguration: this.input.channelConfiguration,
          Codec: this.input.codec,
          Duration: this.input.duration,
          MaxResults: this.input.maxResults,
          MaximumBitrate: this.input.maximumBitrate,
          MaximumFramerate: this.input.maximumFramerate,
          NextToken: this.input.nextToken,
          Resolution: this.input.resolution,
          ResourceType: this.input.resourceType,
          SpecialFeature: this.input.specialFeature,
          VideoQuality: this.input.videoQuality,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListOfferings.NextToken', props);
    return resource.getResponseField('NextToken') as unknown as string;
  }

  public get offerings(): shapes.MediaLiveOffering[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listOfferings',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.ListOfferings.Offerings'),
        outputPath: 'Offerings',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelConfiguration: this.input.channelConfiguration,
          Codec: this.input.codec,
          Duration: this.input.duration,
          MaxResults: this.input.maxResults,
          MaximumBitrate: this.input.maximumBitrate,
          MaximumFramerate: this.input.maximumFramerate,
          NextToken: this.input.nextToken,
          Resolution: this.input.resolution,
          ResourceType: this.input.resourceType,
          SpecialFeature: this.input.specialFeature,
          VideoQuality: this.input.videoQuality,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListOfferings.Offerings', props);
    return resource.getResponseField('Offerings') as unknown as shapes.MediaLiveOffering[];
  }

}

export class MediaLiveListReservations extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveListReservationsRequest) {
    super(scope, id);
  }

  public get nextToken(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listReservations',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.ListReservations.NextToken'),
        outputPath: 'NextToken',
        parameters: {
          ChannelClass: this.input.channelClass,
          Codec: this.input.codec,
          MaxResults: this.input.maxResults,
          MaximumBitrate: this.input.maximumBitrate,
          MaximumFramerate: this.input.maximumFramerate,
          NextToken: this.input.nextToken,
          Resolution: this.input.resolution,
          ResourceType: this.input.resourceType,
          SpecialFeature: this.input.specialFeature,
          VideoQuality: this.input.videoQuality,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListReservations.NextToken', props);
    return resource.getResponseField('NextToken') as unknown as string;
  }

  public get reservations(): shapes.MediaLiveReservation[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listReservations',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.ListReservations.Reservations'),
        outputPath: 'Reservations',
        parameters: {
          ChannelClass: this.input.channelClass,
          Codec: this.input.codec,
          MaxResults: this.input.maxResults,
          MaximumBitrate: this.input.maximumBitrate,
          MaximumFramerate: this.input.maximumFramerate,
          NextToken: this.input.nextToken,
          Resolution: this.input.resolution,
          ResourceType: this.input.resourceType,
          SpecialFeature: this.input.specialFeature,
          VideoQuality: this.input.videoQuality,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListReservations.Reservations', props);
    return resource.getResponseField('Reservations') as unknown as shapes.MediaLiveReservation[];
  }

}

export class MediaLiveListTagsForResource extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveListTagsForResourceRequest) {
    super(scope, id);
  }

  public get tags(): Record<string, string> {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'listTagsForResource',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.ListTagsForResource.Tags'),
        outputPath: 'Tags',
        parameters: {
          ResourceArn: this.input.resourceArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'ListTagsForResource.Tags', props);
    return resource.getResponseField('Tags') as unknown as Record<string, string>;
  }

}

export class MediaLivePurchaseOffering extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLivePurchaseOfferingRequest) {
    super(scope, id);
  }

  public get reservation(): MediaLivePurchaseOfferingReservation {
    return new MediaLivePurchaseOfferingReservation(this, 'Reservation', this.__resources, this.input);
  }

}

export class MediaLivePurchaseOfferingReservation extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLivePurchaseOfferingRequest) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'purchaseOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.PurchaseOffering.Reservation.Arn'),
        outputPath: 'Reservation.Arn',
        parameters: {
          Count: this.input.count,
          Name: this.input.name,
          OfferingId: this.input.offeringId,
          RequestId: this.input.requestId,
          Start: this.input.start,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'PurchaseOffering.Reservation.Arn', props);
    return resource.getResponseField('Reservation.Arn') as unknown as string;
  }

  public get count(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'purchaseOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.PurchaseOffering.Reservation.Count'),
        outputPath: 'Reservation.Count',
        parameters: {
          Count: this.input.count,
          Name: this.input.name,
          OfferingId: this.input.offeringId,
          RequestId: this.input.requestId,
          Start: this.input.start,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'PurchaseOffering.Reservation.Count', props);
    return resource.getResponseField('Reservation.Count') as unknown as number;
  }

  public get currencyCode(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'purchaseOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.PurchaseOffering.Reservation.CurrencyCode'),
        outputPath: 'Reservation.CurrencyCode',
        parameters: {
          Count: this.input.count,
          Name: this.input.name,
          OfferingId: this.input.offeringId,
          RequestId: this.input.requestId,
          Start: this.input.start,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'PurchaseOffering.Reservation.CurrencyCode', props);
    return resource.getResponseField('Reservation.CurrencyCode') as unknown as string;
  }

  public get duration(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'purchaseOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.PurchaseOffering.Reservation.Duration'),
        outputPath: 'Reservation.Duration',
        parameters: {
          Count: this.input.count,
          Name: this.input.name,
          OfferingId: this.input.offeringId,
          RequestId: this.input.requestId,
          Start: this.input.start,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'PurchaseOffering.Reservation.Duration', props);
    return resource.getResponseField('Reservation.Duration') as unknown as number;
  }

  public get durationUnits(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'purchaseOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.PurchaseOffering.Reservation.DurationUnits'),
        outputPath: 'Reservation.DurationUnits',
        parameters: {
          Count: this.input.count,
          Name: this.input.name,
          OfferingId: this.input.offeringId,
          RequestId: this.input.requestId,
          Start: this.input.start,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'PurchaseOffering.Reservation.DurationUnits', props);
    return resource.getResponseField('Reservation.DurationUnits') as unknown as string;
  }

  public get end(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'purchaseOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.PurchaseOffering.Reservation.End'),
        outputPath: 'Reservation.End',
        parameters: {
          Count: this.input.count,
          Name: this.input.name,
          OfferingId: this.input.offeringId,
          RequestId: this.input.requestId,
          Start: this.input.start,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'PurchaseOffering.Reservation.End', props);
    return resource.getResponseField('Reservation.End') as unknown as string;
  }

  public get fixedPrice(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'purchaseOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.PurchaseOffering.Reservation.FixedPrice'),
        outputPath: 'Reservation.FixedPrice',
        parameters: {
          Count: this.input.count,
          Name: this.input.name,
          OfferingId: this.input.offeringId,
          RequestId: this.input.requestId,
          Start: this.input.start,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'PurchaseOffering.Reservation.FixedPrice', props);
    return resource.getResponseField('Reservation.FixedPrice') as unknown as number;
  }

  public get name(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'purchaseOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.PurchaseOffering.Reservation.Name'),
        outputPath: 'Reservation.Name',
        parameters: {
          Count: this.input.count,
          Name: this.input.name,
          OfferingId: this.input.offeringId,
          RequestId: this.input.requestId,
          Start: this.input.start,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'PurchaseOffering.Reservation.Name', props);
    return resource.getResponseField('Reservation.Name') as unknown as string;
  }

  public get offeringDescription(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'purchaseOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.PurchaseOffering.Reservation.OfferingDescription'),
        outputPath: 'Reservation.OfferingDescription',
        parameters: {
          Count: this.input.count,
          Name: this.input.name,
          OfferingId: this.input.offeringId,
          RequestId: this.input.requestId,
          Start: this.input.start,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'PurchaseOffering.Reservation.OfferingDescription', props);
    return resource.getResponseField('Reservation.OfferingDescription') as unknown as string;
  }

  public get offeringId(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'purchaseOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.PurchaseOffering.Reservation.OfferingId'),
        outputPath: 'Reservation.OfferingId',
        parameters: {
          Count: this.input.count,
          Name: this.input.name,
          OfferingId: this.input.offeringId,
          RequestId: this.input.requestId,
          Start: this.input.start,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'PurchaseOffering.Reservation.OfferingId', props);
    return resource.getResponseField('Reservation.OfferingId') as unknown as string;
  }

  public get offeringType(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'purchaseOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.PurchaseOffering.Reservation.OfferingType'),
        outputPath: 'Reservation.OfferingType',
        parameters: {
          Count: this.input.count,
          Name: this.input.name,
          OfferingId: this.input.offeringId,
          RequestId: this.input.requestId,
          Start: this.input.start,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'PurchaseOffering.Reservation.OfferingType', props);
    return resource.getResponseField('Reservation.OfferingType') as unknown as string;
  }

  public get region(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'purchaseOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.PurchaseOffering.Reservation.Region'),
        outputPath: 'Reservation.Region',
        parameters: {
          Count: this.input.count,
          Name: this.input.name,
          OfferingId: this.input.offeringId,
          RequestId: this.input.requestId,
          Start: this.input.start,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'PurchaseOffering.Reservation.Region', props);
    return resource.getResponseField('Reservation.Region') as unknown as string;
  }

  public get reservationId(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'purchaseOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.PurchaseOffering.Reservation.ReservationId'),
        outputPath: 'Reservation.ReservationId',
        parameters: {
          Count: this.input.count,
          Name: this.input.name,
          OfferingId: this.input.offeringId,
          RequestId: this.input.requestId,
          Start: this.input.start,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'PurchaseOffering.Reservation.ReservationId', props);
    return resource.getResponseField('Reservation.ReservationId') as unknown as string;
  }

  public get resourceSpecification(): MediaLivePurchaseOfferingReservationResourceSpecification {
    return new MediaLivePurchaseOfferingReservationResourceSpecification(this, 'ResourceSpecification', this.__resources, this.input);
  }

  public get start(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'purchaseOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.PurchaseOffering.Reservation.Start'),
        outputPath: 'Reservation.Start',
        parameters: {
          Count: this.input.count,
          Name: this.input.name,
          OfferingId: this.input.offeringId,
          RequestId: this.input.requestId,
          Start: this.input.start,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'PurchaseOffering.Reservation.Start', props);
    return resource.getResponseField('Reservation.Start') as unknown as string;
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'purchaseOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.PurchaseOffering.Reservation.State'),
        outputPath: 'Reservation.State',
        parameters: {
          Count: this.input.count,
          Name: this.input.name,
          OfferingId: this.input.offeringId,
          RequestId: this.input.requestId,
          Start: this.input.start,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'PurchaseOffering.Reservation.State', props);
    return resource.getResponseField('Reservation.State') as unknown as string;
  }

  public get tags(): Record<string, string> {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'purchaseOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.PurchaseOffering.Reservation.Tags'),
        outputPath: 'Reservation.Tags',
        parameters: {
          Count: this.input.count,
          Name: this.input.name,
          OfferingId: this.input.offeringId,
          RequestId: this.input.requestId,
          Start: this.input.start,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'PurchaseOffering.Reservation.Tags', props);
    return resource.getResponseField('Reservation.Tags') as unknown as Record<string, string>;
  }

  public get usagePrice(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'purchaseOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.PurchaseOffering.Reservation.UsagePrice'),
        outputPath: 'Reservation.UsagePrice',
        parameters: {
          Count: this.input.count,
          Name: this.input.name,
          OfferingId: this.input.offeringId,
          RequestId: this.input.requestId,
          Start: this.input.start,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'PurchaseOffering.Reservation.UsagePrice', props);
    return resource.getResponseField('Reservation.UsagePrice') as unknown as number;
  }

}

export class MediaLivePurchaseOfferingReservationResourceSpecification extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLivePurchaseOfferingRequest) {
    super(scope, id);
  }

  public get channelClass(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'purchaseOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.PurchaseOffering.Reservation.ResourceSpecification.ChannelClass'),
        outputPath: 'Reservation.ResourceSpecification.ChannelClass',
        parameters: {
          Count: this.input.count,
          Name: this.input.name,
          OfferingId: this.input.offeringId,
          RequestId: this.input.requestId,
          Start: this.input.start,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'PurchaseOffering.Reservation.ResourceSpecification.ChannelClass', props);
    return resource.getResponseField('Reservation.ResourceSpecification.ChannelClass') as unknown as string;
  }

  public get codec(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'purchaseOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.PurchaseOffering.Reservation.ResourceSpecification.Codec'),
        outputPath: 'Reservation.ResourceSpecification.Codec',
        parameters: {
          Count: this.input.count,
          Name: this.input.name,
          OfferingId: this.input.offeringId,
          RequestId: this.input.requestId,
          Start: this.input.start,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'PurchaseOffering.Reservation.ResourceSpecification.Codec', props);
    return resource.getResponseField('Reservation.ResourceSpecification.Codec') as unknown as string;
  }

  public get maximumBitrate(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'purchaseOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.PurchaseOffering.Reservation.ResourceSpecification.MaximumBitrate'),
        outputPath: 'Reservation.ResourceSpecification.MaximumBitrate',
        parameters: {
          Count: this.input.count,
          Name: this.input.name,
          OfferingId: this.input.offeringId,
          RequestId: this.input.requestId,
          Start: this.input.start,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'PurchaseOffering.Reservation.ResourceSpecification.MaximumBitrate', props);
    return resource.getResponseField('Reservation.ResourceSpecification.MaximumBitrate') as unknown as string;
  }

  public get maximumFramerate(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'purchaseOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.PurchaseOffering.Reservation.ResourceSpecification.MaximumFramerate'),
        outputPath: 'Reservation.ResourceSpecification.MaximumFramerate',
        parameters: {
          Count: this.input.count,
          Name: this.input.name,
          OfferingId: this.input.offeringId,
          RequestId: this.input.requestId,
          Start: this.input.start,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'PurchaseOffering.Reservation.ResourceSpecification.MaximumFramerate', props);
    return resource.getResponseField('Reservation.ResourceSpecification.MaximumFramerate') as unknown as string;
  }

  public get resolution(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'purchaseOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.PurchaseOffering.Reservation.ResourceSpecification.Resolution'),
        outputPath: 'Reservation.ResourceSpecification.Resolution',
        parameters: {
          Count: this.input.count,
          Name: this.input.name,
          OfferingId: this.input.offeringId,
          RequestId: this.input.requestId,
          Start: this.input.start,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'PurchaseOffering.Reservation.ResourceSpecification.Resolution', props);
    return resource.getResponseField('Reservation.ResourceSpecification.Resolution') as unknown as string;
  }

  public get resourceType(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'purchaseOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.PurchaseOffering.Reservation.ResourceSpecification.ResourceType'),
        outputPath: 'Reservation.ResourceSpecification.ResourceType',
        parameters: {
          Count: this.input.count,
          Name: this.input.name,
          OfferingId: this.input.offeringId,
          RequestId: this.input.requestId,
          Start: this.input.start,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'PurchaseOffering.Reservation.ResourceSpecification.ResourceType', props);
    return resource.getResponseField('Reservation.ResourceSpecification.ResourceType') as unknown as string;
  }

  public get specialFeature(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'purchaseOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.PurchaseOffering.Reservation.ResourceSpecification.SpecialFeature'),
        outputPath: 'Reservation.ResourceSpecification.SpecialFeature',
        parameters: {
          Count: this.input.count,
          Name: this.input.name,
          OfferingId: this.input.offeringId,
          RequestId: this.input.requestId,
          Start: this.input.start,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'PurchaseOffering.Reservation.ResourceSpecification.SpecialFeature', props);
    return resource.getResponseField('Reservation.ResourceSpecification.SpecialFeature') as unknown as string;
  }

  public get videoQuality(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'purchaseOffering',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.PurchaseOffering.Reservation.ResourceSpecification.VideoQuality'),
        outputPath: 'Reservation.ResourceSpecification.VideoQuality',
        parameters: {
          Count: this.input.count,
          Name: this.input.name,
          OfferingId: this.input.offeringId,
          RequestId: this.input.requestId,
          Start: this.input.start,
          Tags: this.input.tags,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'PurchaseOffering.Reservation.ResourceSpecification.VideoQuality', props);
    return resource.getResponseField('Reservation.ResourceSpecification.VideoQuality') as unknown as string;
  }

}

export class MediaLiveStartChannel extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStartChannelRequest) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.Arn'),
        outputPath: 'Arn',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.Arn', props);
    return resource.getResponseField('Arn') as unknown as string;
  }

  public get cdiInputSpecification(): MediaLiveStartChannelCdiInputSpecification {
    return new MediaLiveStartChannelCdiInputSpecification(this, 'CdiInputSpecification', this.__resources, this.input);
  }

  public get channelClass(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.ChannelClass'),
        outputPath: 'ChannelClass',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.ChannelClass', props);
    return resource.getResponseField('ChannelClass') as unknown as string;
  }

  public get destinations(): shapes.MediaLiveOutputDestination[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.Destinations'),
        outputPath: 'Destinations',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.Destinations', props);
    return resource.getResponseField('Destinations') as unknown as shapes.MediaLiveOutputDestination[];
  }

  public get egressEndpoints(): shapes.MediaLiveChannelEgressEndpoint[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EgressEndpoints'),
        outputPath: 'EgressEndpoints',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EgressEndpoints', props);
    return resource.getResponseField('EgressEndpoints') as unknown as shapes.MediaLiveChannelEgressEndpoint[];
  }

  public get encoderSettings(): MediaLiveStartChannelEncoderSettings {
    return new MediaLiveStartChannelEncoderSettings(this, 'EncoderSettings', this.__resources, this.input);
  }

  public get id(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.Id'),
        outputPath: 'Id',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.Id', props);
    return resource.getResponseField('Id') as unknown as string;
  }

  public get inputAttachments(): shapes.MediaLiveInputAttachment[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.InputAttachments'),
        outputPath: 'InputAttachments',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.InputAttachments', props);
    return resource.getResponseField('InputAttachments') as unknown as shapes.MediaLiveInputAttachment[];
  }

  public get inputSpecification(): MediaLiveStartChannelInputSpecification {
    return new MediaLiveStartChannelInputSpecification(this, 'InputSpecification', this.__resources, this.input);
  }

  public get logLevel(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.LogLevel'),
        outputPath: 'LogLevel',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.LogLevel', props);
    return resource.getResponseField('LogLevel') as unknown as string;
  }

  public get name(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.Name'),
        outputPath: 'Name',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.Name', props);
    return resource.getResponseField('Name') as unknown as string;
  }

  public get pipelineDetails(): shapes.MediaLivePipelineDetail[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.PipelineDetails'),
        outputPath: 'PipelineDetails',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.PipelineDetails', props);
    return resource.getResponseField('PipelineDetails') as unknown as shapes.MediaLivePipelineDetail[];
  }

  public get pipelinesRunningCount(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.PipelinesRunningCount'),
        outputPath: 'PipelinesRunningCount',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.PipelinesRunningCount', props);
    return resource.getResponseField('PipelinesRunningCount') as unknown as number;
  }

  public get roleArn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.RoleArn'),
        outputPath: 'RoleArn',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.RoleArn', props);
    return resource.getResponseField('RoleArn') as unknown as string;
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.State'),
        outputPath: 'State',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.State', props);
    return resource.getResponseField('State') as unknown as string;
  }

  public get tags(): Record<string, string> {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.Tags'),
        outputPath: 'Tags',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.Tags', props);
    return resource.getResponseField('Tags') as unknown as Record<string, string>;
  }

}

export class MediaLiveStartChannelCdiInputSpecification extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStartChannelRequest) {
    super(scope, id);
  }

  public get resolution(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.CdiInputSpecification.Resolution'),
        outputPath: 'CdiInputSpecification.Resolution',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.CdiInputSpecification.Resolution', props);
    return resource.getResponseField('CdiInputSpecification.Resolution') as unknown as string;
  }

}

export class MediaLiveStartChannelEncoderSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStartChannelRequest) {
    super(scope, id);
  }

  public get audioDescriptions(): shapes.MediaLiveAudioDescription[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.AudioDescriptions'),
        outputPath: 'EncoderSettings.AudioDescriptions',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.AudioDescriptions', props);
    return resource.getResponseField('EncoderSettings.AudioDescriptions') as unknown as shapes.MediaLiveAudioDescription[];
  }

  public get availBlanking(): MediaLiveStartChannelEncoderSettingsAvailBlanking {
    return new MediaLiveStartChannelEncoderSettingsAvailBlanking(this, 'AvailBlanking', this.__resources, this.input);
  }

  public get availConfiguration(): MediaLiveStartChannelEncoderSettingsAvailConfiguration {
    return new MediaLiveStartChannelEncoderSettingsAvailConfiguration(this, 'AvailConfiguration', this.__resources, this.input);
  }

  public get blackoutSlate(): MediaLiveStartChannelEncoderSettingsBlackoutSlate {
    return new MediaLiveStartChannelEncoderSettingsBlackoutSlate(this, 'BlackoutSlate', this.__resources, this.input);
  }

  public get captionDescriptions(): shapes.MediaLiveCaptionDescription[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.CaptionDescriptions'),
        outputPath: 'EncoderSettings.CaptionDescriptions',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.CaptionDescriptions', props);
    return resource.getResponseField('EncoderSettings.CaptionDescriptions') as unknown as shapes.MediaLiveCaptionDescription[];
  }

  public get featureActivations(): MediaLiveStartChannelEncoderSettingsFeatureActivations {
    return new MediaLiveStartChannelEncoderSettingsFeatureActivations(this, 'FeatureActivations', this.__resources, this.input);
  }

  public get globalConfiguration(): MediaLiveStartChannelEncoderSettingsGlobalConfiguration {
    return new MediaLiveStartChannelEncoderSettingsGlobalConfiguration(this, 'GlobalConfiguration', this.__resources, this.input);
  }

  public get nielsenConfiguration(): MediaLiveStartChannelEncoderSettingsNielsenConfiguration {
    return new MediaLiveStartChannelEncoderSettingsNielsenConfiguration(this, 'NielsenConfiguration', this.__resources, this.input);
  }

  public get outputGroups(): shapes.MediaLiveOutputGroup[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.OutputGroups'),
        outputPath: 'EncoderSettings.OutputGroups',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.OutputGroups', props);
    return resource.getResponseField('EncoderSettings.OutputGroups') as unknown as shapes.MediaLiveOutputGroup[];
  }

  public get timecodeConfig(): MediaLiveStartChannelEncoderSettingsTimecodeConfig {
    return new MediaLiveStartChannelEncoderSettingsTimecodeConfig(this, 'TimecodeConfig', this.__resources, this.input);
  }

  public get videoDescriptions(): shapes.MediaLiveVideoDescription[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.VideoDescriptions'),
        outputPath: 'EncoderSettings.VideoDescriptions',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.VideoDescriptions', props);
    return resource.getResponseField('EncoderSettings.VideoDescriptions') as unknown as shapes.MediaLiveVideoDescription[];
  }

}

export class MediaLiveStartChannelEncoderSettingsAvailBlanking extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStartChannelRequest) {
    super(scope, id);
  }

  public get availBlankingImage(): MediaLiveStartChannelEncoderSettingsAvailBlankingAvailBlankingImage {
    return new MediaLiveStartChannelEncoderSettingsAvailBlankingAvailBlankingImage(this, 'AvailBlankingImage', this.__resources, this.input);
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.AvailBlanking.State'),
        outputPath: 'EncoderSettings.AvailBlanking.State',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.AvailBlanking.State', props);
    return resource.getResponseField('EncoderSettings.AvailBlanking.State') as unknown as string;
  }

}

export class MediaLiveStartChannelEncoderSettingsAvailBlankingAvailBlankingImage extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStartChannelRequest) {
    super(scope, id);
  }

  public get passwordParam(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.AvailBlanking.AvailBlankingImage.PasswordParam'),
        outputPath: 'EncoderSettings.AvailBlanking.AvailBlankingImage.PasswordParam',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.AvailBlanking.AvailBlankingImage.PasswordParam', props);
    return resource.getResponseField('EncoderSettings.AvailBlanking.AvailBlankingImage.PasswordParam') as unknown as string;
  }

  public get uri(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.AvailBlanking.AvailBlankingImage.Uri'),
        outputPath: 'EncoderSettings.AvailBlanking.AvailBlankingImage.Uri',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.AvailBlanking.AvailBlankingImage.Uri', props);
    return resource.getResponseField('EncoderSettings.AvailBlanking.AvailBlankingImage.Uri') as unknown as string;
  }

  public get username(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.AvailBlanking.AvailBlankingImage.Username'),
        outputPath: 'EncoderSettings.AvailBlanking.AvailBlankingImage.Username',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.AvailBlanking.AvailBlankingImage.Username', props);
    return resource.getResponseField('EncoderSettings.AvailBlanking.AvailBlankingImage.Username') as unknown as string;
  }

}

export class MediaLiveStartChannelEncoderSettingsAvailConfiguration extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStartChannelRequest) {
    super(scope, id);
  }

  public get availSettings(): MediaLiveStartChannelEncoderSettingsAvailConfigurationAvailSettings {
    return new MediaLiveStartChannelEncoderSettingsAvailConfigurationAvailSettings(this, 'AvailSettings', this.__resources, this.input);
  }

}

export class MediaLiveStartChannelEncoderSettingsAvailConfigurationAvailSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStartChannelRequest) {
    super(scope, id);
  }

  public get scte35SpliceInsert(): MediaLiveStartChannelEncoderSettingsAvailConfigurationAvailSettingsScte35SpliceInsert {
    return new MediaLiveStartChannelEncoderSettingsAvailConfigurationAvailSettingsScte35SpliceInsert(this, 'Scte35SpliceInsert', this.__resources, this.input);
  }

  public get scte35TimeSignalApos(): MediaLiveStartChannelEncoderSettingsAvailConfigurationAvailSettingsScte35TimeSignalApos {
    return new MediaLiveStartChannelEncoderSettingsAvailConfigurationAvailSettingsScte35TimeSignalApos(this, 'Scte35TimeSignalApos', this.__resources, this.input);
  }

}

export class MediaLiveStartChannelEncoderSettingsAvailConfigurationAvailSettingsScte35SpliceInsert extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStartChannelRequest) {
    super(scope, id);
  }

  public get adAvailOffset(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.AdAvailOffset'),
        outputPath: 'EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.AdAvailOffset',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.AdAvailOffset', props);
    return resource.getResponseField('EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.AdAvailOffset') as unknown as number;
  }

  public get noRegionalBlackoutFlag(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.NoRegionalBlackoutFlag'),
        outputPath: 'EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.NoRegionalBlackoutFlag',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.NoRegionalBlackoutFlag', props);
    return resource.getResponseField('EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.NoRegionalBlackoutFlag') as unknown as string;
  }

  public get webDeliveryAllowedFlag(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.WebDeliveryAllowedFlag'),
        outputPath: 'EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.WebDeliveryAllowedFlag',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.WebDeliveryAllowedFlag', props);
    return resource.getResponseField('EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.WebDeliveryAllowedFlag') as unknown as string;
  }

}

export class MediaLiveStartChannelEncoderSettingsAvailConfigurationAvailSettingsScte35TimeSignalApos extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStartChannelRequest) {
    super(scope, id);
  }

  public get adAvailOffset(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.AdAvailOffset'),
        outputPath: 'EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.AdAvailOffset',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.AdAvailOffset', props);
    return resource.getResponseField('EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.AdAvailOffset') as unknown as number;
  }

  public get noRegionalBlackoutFlag(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.NoRegionalBlackoutFlag'),
        outputPath: 'EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.NoRegionalBlackoutFlag',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.NoRegionalBlackoutFlag', props);
    return resource.getResponseField('EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.NoRegionalBlackoutFlag') as unknown as string;
  }

  public get webDeliveryAllowedFlag(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.WebDeliveryAllowedFlag'),
        outputPath: 'EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.WebDeliveryAllowedFlag',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.WebDeliveryAllowedFlag', props);
    return resource.getResponseField('EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.WebDeliveryAllowedFlag') as unknown as string;
  }

}

export class MediaLiveStartChannelEncoderSettingsBlackoutSlate extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStartChannelRequest) {
    super(scope, id);
  }

  public get blackoutSlateImage(): MediaLiveStartChannelEncoderSettingsBlackoutSlateBlackoutSlateImage {
    return new MediaLiveStartChannelEncoderSettingsBlackoutSlateBlackoutSlateImage(this, 'BlackoutSlateImage', this.__resources, this.input);
  }

  public get networkEndBlackout(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackout'),
        outputPath: 'EncoderSettings.BlackoutSlate.NetworkEndBlackout',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackout', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.NetworkEndBlackout') as unknown as string;
  }

  public get networkEndBlackoutImage(): MediaLiveStartChannelEncoderSettingsBlackoutSlateNetworkEndBlackoutImage {
    return new MediaLiveStartChannelEncoderSettingsBlackoutSlateNetworkEndBlackoutImage(this, 'NetworkEndBlackoutImage', this.__resources, this.input);
  }

  public get networkId(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.BlackoutSlate.NetworkId'),
        outputPath: 'EncoderSettings.BlackoutSlate.NetworkId',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.BlackoutSlate.NetworkId', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.NetworkId') as unknown as string;
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.BlackoutSlate.State'),
        outputPath: 'EncoderSettings.BlackoutSlate.State',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.BlackoutSlate.State', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.State') as unknown as string;
  }

}

export class MediaLiveStartChannelEncoderSettingsBlackoutSlateBlackoutSlateImage extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStartChannelRequest) {
    super(scope, id);
  }

  public get passwordParam(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.PasswordParam'),
        outputPath: 'EncoderSettings.BlackoutSlate.BlackoutSlateImage.PasswordParam',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.PasswordParam', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.BlackoutSlateImage.PasswordParam') as unknown as string;
  }

  public get uri(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Uri'),
        outputPath: 'EncoderSettings.BlackoutSlate.BlackoutSlateImage.Uri',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Uri', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.BlackoutSlateImage.Uri') as unknown as string;
  }

  public get username(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Username'),
        outputPath: 'EncoderSettings.BlackoutSlate.BlackoutSlateImage.Username',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Username', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.BlackoutSlateImage.Username') as unknown as string;
  }

}

export class MediaLiveStartChannelEncoderSettingsBlackoutSlateNetworkEndBlackoutImage extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStartChannelRequest) {
    super(scope, id);
  }

  public get passwordParam(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.PasswordParam'),
        outputPath: 'EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.PasswordParam',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.PasswordParam', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.PasswordParam') as unknown as string;
  }

  public get uri(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Uri'),
        outputPath: 'EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Uri',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Uri', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Uri') as unknown as string;
  }

  public get username(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Username'),
        outputPath: 'EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Username',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Username', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Username') as unknown as string;
  }

}

export class MediaLiveStartChannelEncoderSettingsFeatureActivations extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStartChannelRequest) {
    super(scope, id);
  }

  public get inputPrepareScheduleActions(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.FeatureActivations.InputPrepareScheduleActions'),
        outputPath: 'EncoderSettings.FeatureActivations.InputPrepareScheduleActions',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.FeatureActivations.InputPrepareScheduleActions', props);
    return resource.getResponseField('EncoderSettings.FeatureActivations.InputPrepareScheduleActions') as unknown as string;
  }

}

export class MediaLiveStartChannelEncoderSettingsGlobalConfiguration extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStartChannelRequest) {
    super(scope, id);
  }

  public get initialAudioGain(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.GlobalConfiguration.InitialAudioGain'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InitialAudioGain',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.GlobalConfiguration.InitialAudioGain', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InitialAudioGain') as unknown as number;
  }

  public get inputEndAction(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.GlobalConfiguration.InputEndAction'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputEndAction',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.GlobalConfiguration.InputEndAction', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputEndAction') as unknown as string;
  }

  public get inputLossBehavior(): MediaLiveStartChannelEncoderSettingsGlobalConfigurationInputLossBehavior {
    return new MediaLiveStartChannelEncoderSettingsGlobalConfigurationInputLossBehavior(this, 'InputLossBehavior', this.__resources, this.input);
  }

  public get outputLockingMode(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.GlobalConfiguration.OutputLockingMode'),
        outputPath: 'EncoderSettings.GlobalConfiguration.OutputLockingMode',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.GlobalConfiguration.OutputLockingMode', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.OutputLockingMode') as unknown as string;
  }

  public get outputTimingSource(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.GlobalConfiguration.OutputTimingSource'),
        outputPath: 'EncoderSettings.GlobalConfiguration.OutputTimingSource',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.GlobalConfiguration.OutputTimingSource', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.OutputTimingSource') as unknown as string;
  }

  public get supportLowFramerateInputs(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.GlobalConfiguration.SupportLowFramerateInputs'),
        outputPath: 'EncoderSettings.GlobalConfiguration.SupportLowFramerateInputs',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.GlobalConfiguration.SupportLowFramerateInputs', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.SupportLowFramerateInputs') as unknown as string;
  }

}

export class MediaLiveStartChannelEncoderSettingsGlobalConfigurationInputLossBehavior extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStartChannelRequest) {
    super(scope, id);
  }

  public get blackFrameMsec(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.BlackFrameMsec'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputLossBehavior.BlackFrameMsec',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.BlackFrameMsec', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputLossBehavior.BlackFrameMsec') as unknown as number;
  }

  public get inputLossImageColor(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageColor'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageColor',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageColor', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageColor') as unknown as string;
  }

  public get inputLossImageSlate(): MediaLiveStartChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate {
    return new MediaLiveStartChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate(this, 'InputLossImageSlate', this.__resources, this.input);
  }

  public get inputLossImageType(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageType'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageType',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageType', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageType') as unknown as string;
  }

  public get repeatFrameMsec(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.RepeatFrameMsec'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputLossBehavior.RepeatFrameMsec',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.RepeatFrameMsec', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputLossBehavior.RepeatFrameMsec') as unknown as number;
  }

}

export class MediaLiveStartChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStartChannelRequest) {
    super(scope, id);
  }

  public get passwordParam(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.PasswordParam'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.PasswordParam',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.PasswordParam', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.PasswordParam') as unknown as string;
  }

  public get uri(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Uri'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Uri',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Uri', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Uri') as unknown as string;
  }

  public get username(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Username'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Username',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Username', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Username') as unknown as string;
  }

}

export class MediaLiveStartChannelEncoderSettingsNielsenConfiguration extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStartChannelRequest) {
    super(scope, id);
  }

  public get distributorId(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.NielsenConfiguration.DistributorId'),
        outputPath: 'EncoderSettings.NielsenConfiguration.DistributorId',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.NielsenConfiguration.DistributorId', props);
    return resource.getResponseField('EncoderSettings.NielsenConfiguration.DistributorId') as unknown as string;
  }

  public get nielsenPcmToId3Tagging(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.NielsenConfiguration.NielsenPcmToId3Tagging'),
        outputPath: 'EncoderSettings.NielsenConfiguration.NielsenPcmToId3Tagging',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.NielsenConfiguration.NielsenPcmToId3Tagging', props);
    return resource.getResponseField('EncoderSettings.NielsenConfiguration.NielsenPcmToId3Tagging') as unknown as string;
  }

}

export class MediaLiveStartChannelEncoderSettingsTimecodeConfig extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStartChannelRequest) {
    super(scope, id);
  }

  public get source(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.TimecodeConfig.Source'),
        outputPath: 'EncoderSettings.TimecodeConfig.Source',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.TimecodeConfig.Source', props);
    return resource.getResponseField('EncoderSettings.TimecodeConfig.Source') as unknown as string;
  }

  public get syncThreshold(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.EncoderSettings.TimecodeConfig.SyncThreshold'),
        outputPath: 'EncoderSettings.TimecodeConfig.SyncThreshold',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.EncoderSettings.TimecodeConfig.SyncThreshold', props);
    return resource.getResponseField('EncoderSettings.TimecodeConfig.SyncThreshold') as unknown as number;
  }

}

export class MediaLiveStartChannelInputSpecification extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStartChannelRequest) {
    super(scope, id);
  }

  public get codec(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.InputSpecification.Codec'),
        outputPath: 'InputSpecification.Codec',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.InputSpecification.Codec', props);
    return resource.getResponseField('InputSpecification.Codec') as unknown as string;
  }

  public get maximumBitrate(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.InputSpecification.MaximumBitrate'),
        outputPath: 'InputSpecification.MaximumBitrate',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.InputSpecification.MaximumBitrate', props);
    return resource.getResponseField('InputSpecification.MaximumBitrate') as unknown as string;
  }

  public get resolution(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartChannel.InputSpecification.Resolution'),
        outputPath: 'InputSpecification.Resolution',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartChannel.InputSpecification.Resolution', props);
    return resource.getResponseField('InputSpecification.Resolution') as unknown as string;
  }

}

export class MediaLiveStartMultiplex extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStartMultiplexRequest) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartMultiplex.Arn'),
        outputPath: 'Arn',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartMultiplex.Arn', props);
    return resource.getResponseField('Arn') as unknown as string;
  }

  public get availabilityZones(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartMultiplex.AvailabilityZones'),
        outputPath: 'AvailabilityZones',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartMultiplex.AvailabilityZones', props);
    return resource.getResponseField('AvailabilityZones') as unknown as string[];
  }

  public get destinations(): shapes.MediaLiveMultiplexOutputDestination[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartMultiplex.Destinations'),
        outputPath: 'Destinations',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartMultiplex.Destinations', props);
    return resource.getResponseField('Destinations') as unknown as shapes.MediaLiveMultiplexOutputDestination[];
  }

  public get id(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartMultiplex.Id'),
        outputPath: 'Id',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartMultiplex.Id', props);
    return resource.getResponseField('Id') as unknown as string;
  }

  public get multiplexSettings(): MediaLiveStartMultiplexMultiplexSettings {
    return new MediaLiveStartMultiplexMultiplexSettings(this, 'MultiplexSettings', this.__resources, this.input);
  }

  public get name(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartMultiplex.Name'),
        outputPath: 'Name',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartMultiplex.Name', props);
    return resource.getResponseField('Name') as unknown as string;
  }

  public get pipelinesRunningCount(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartMultiplex.PipelinesRunningCount'),
        outputPath: 'PipelinesRunningCount',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartMultiplex.PipelinesRunningCount', props);
    return resource.getResponseField('PipelinesRunningCount') as unknown as number;
  }

  public get programCount(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartMultiplex.ProgramCount'),
        outputPath: 'ProgramCount',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartMultiplex.ProgramCount', props);
    return resource.getResponseField('ProgramCount') as unknown as number;
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartMultiplex.State'),
        outputPath: 'State',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartMultiplex.State', props);
    return resource.getResponseField('State') as unknown as string;
  }

  public get tags(): Record<string, string> {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartMultiplex.Tags'),
        outputPath: 'Tags',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartMultiplex.Tags', props);
    return resource.getResponseField('Tags') as unknown as Record<string, string>;
  }

}

export class MediaLiveStartMultiplexMultiplexSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStartMultiplexRequest) {
    super(scope, id);
  }

  public get maximumVideoBufferDelayMilliseconds(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartMultiplex.MultiplexSettings.MaximumVideoBufferDelayMilliseconds'),
        outputPath: 'MultiplexSettings.MaximumVideoBufferDelayMilliseconds',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartMultiplex.MultiplexSettings.MaximumVideoBufferDelayMilliseconds', props);
    return resource.getResponseField('MultiplexSettings.MaximumVideoBufferDelayMilliseconds') as unknown as number;
  }

  public get transportStreamBitrate(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartMultiplex.MultiplexSettings.TransportStreamBitrate'),
        outputPath: 'MultiplexSettings.TransportStreamBitrate',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartMultiplex.MultiplexSettings.TransportStreamBitrate', props);
    return resource.getResponseField('MultiplexSettings.TransportStreamBitrate') as unknown as number;
  }

  public get transportStreamId(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartMultiplex.MultiplexSettings.TransportStreamId'),
        outputPath: 'MultiplexSettings.TransportStreamId',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartMultiplex.MultiplexSettings.TransportStreamId', props);
    return resource.getResponseField('MultiplexSettings.TransportStreamId') as unknown as number;
  }

  public get transportStreamReservedBitrate(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'startMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StartMultiplex.MultiplexSettings.TransportStreamReservedBitrate'),
        outputPath: 'MultiplexSettings.TransportStreamReservedBitrate',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StartMultiplex.MultiplexSettings.TransportStreamReservedBitrate', props);
    return resource.getResponseField('MultiplexSettings.TransportStreamReservedBitrate') as unknown as number;
  }

}

export class MediaLiveStopChannel extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStopChannelRequest) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.Arn'),
        outputPath: 'Arn',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.Arn', props);
    return resource.getResponseField('Arn') as unknown as string;
  }

  public get cdiInputSpecification(): MediaLiveStopChannelCdiInputSpecification {
    return new MediaLiveStopChannelCdiInputSpecification(this, 'CdiInputSpecification', this.__resources, this.input);
  }

  public get channelClass(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.ChannelClass'),
        outputPath: 'ChannelClass',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.ChannelClass', props);
    return resource.getResponseField('ChannelClass') as unknown as string;
  }

  public get destinations(): shapes.MediaLiveOutputDestination[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.Destinations'),
        outputPath: 'Destinations',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.Destinations', props);
    return resource.getResponseField('Destinations') as unknown as shapes.MediaLiveOutputDestination[];
  }

  public get egressEndpoints(): shapes.MediaLiveChannelEgressEndpoint[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EgressEndpoints'),
        outputPath: 'EgressEndpoints',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EgressEndpoints', props);
    return resource.getResponseField('EgressEndpoints') as unknown as shapes.MediaLiveChannelEgressEndpoint[];
  }

  public get encoderSettings(): MediaLiveStopChannelEncoderSettings {
    return new MediaLiveStopChannelEncoderSettings(this, 'EncoderSettings', this.__resources, this.input);
  }

  public get id(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.Id'),
        outputPath: 'Id',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.Id', props);
    return resource.getResponseField('Id') as unknown as string;
  }

  public get inputAttachments(): shapes.MediaLiveInputAttachment[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.InputAttachments'),
        outputPath: 'InputAttachments',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.InputAttachments', props);
    return resource.getResponseField('InputAttachments') as unknown as shapes.MediaLiveInputAttachment[];
  }

  public get inputSpecification(): MediaLiveStopChannelInputSpecification {
    return new MediaLiveStopChannelInputSpecification(this, 'InputSpecification', this.__resources, this.input);
  }

  public get logLevel(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.LogLevel'),
        outputPath: 'LogLevel',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.LogLevel', props);
    return resource.getResponseField('LogLevel') as unknown as string;
  }

  public get name(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.Name'),
        outputPath: 'Name',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.Name', props);
    return resource.getResponseField('Name') as unknown as string;
  }

  public get pipelineDetails(): shapes.MediaLivePipelineDetail[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.PipelineDetails'),
        outputPath: 'PipelineDetails',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.PipelineDetails', props);
    return resource.getResponseField('PipelineDetails') as unknown as shapes.MediaLivePipelineDetail[];
  }

  public get pipelinesRunningCount(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.PipelinesRunningCount'),
        outputPath: 'PipelinesRunningCount',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.PipelinesRunningCount', props);
    return resource.getResponseField('PipelinesRunningCount') as unknown as number;
  }

  public get roleArn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.RoleArn'),
        outputPath: 'RoleArn',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.RoleArn', props);
    return resource.getResponseField('RoleArn') as unknown as string;
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.State'),
        outputPath: 'State',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.State', props);
    return resource.getResponseField('State') as unknown as string;
  }

  public get tags(): Record<string, string> {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.Tags'),
        outputPath: 'Tags',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.Tags', props);
    return resource.getResponseField('Tags') as unknown as Record<string, string>;
  }

}

export class MediaLiveStopChannelCdiInputSpecification extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStopChannelRequest) {
    super(scope, id);
  }

  public get resolution(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.CdiInputSpecification.Resolution'),
        outputPath: 'CdiInputSpecification.Resolution',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.CdiInputSpecification.Resolution', props);
    return resource.getResponseField('CdiInputSpecification.Resolution') as unknown as string;
  }

}

export class MediaLiveStopChannelEncoderSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStopChannelRequest) {
    super(scope, id);
  }

  public get audioDescriptions(): shapes.MediaLiveAudioDescription[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.AudioDescriptions'),
        outputPath: 'EncoderSettings.AudioDescriptions',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.AudioDescriptions', props);
    return resource.getResponseField('EncoderSettings.AudioDescriptions') as unknown as shapes.MediaLiveAudioDescription[];
  }

  public get availBlanking(): MediaLiveStopChannelEncoderSettingsAvailBlanking {
    return new MediaLiveStopChannelEncoderSettingsAvailBlanking(this, 'AvailBlanking', this.__resources, this.input);
  }

  public get availConfiguration(): MediaLiveStopChannelEncoderSettingsAvailConfiguration {
    return new MediaLiveStopChannelEncoderSettingsAvailConfiguration(this, 'AvailConfiguration', this.__resources, this.input);
  }

  public get blackoutSlate(): MediaLiveStopChannelEncoderSettingsBlackoutSlate {
    return new MediaLiveStopChannelEncoderSettingsBlackoutSlate(this, 'BlackoutSlate', this.__resources, this.input);
  }

  public get captionDescriptions(): shapes.MediaLiveCaptionDescription[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.CaptionDescriptions'),
        outputPath: 'EncoderSettings.CaptionDescriptions',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.CaptionDescriptions', props);
    return resource.getResponseField('EncoderSettings.CaptionDescriptions') as unknown as shapes.MediaLiveCaptionDescription[];
  }

  public get featureActivations(): MediaLiveStopChannelEncoderSettingsFeatureActivations {
    return new MediaLiveStopChannelEncoderSettingsFeatureActivations(this, 'FeatureActivations', this.__resources, this.input);
  }

  public get globalConfiguration(): MediaLiveStopChannelEncoderSettingsGlobalConfiguration {
    return new MediaLiveStopChannelEncoderSettingsGlobalConfiguration(this, 'GlobalConfiguration', this.__resources, this.input);
  }

  public get nielsenConfiguration(): MediaLiveStopChannelEncoderSettingsNielsenConfiguration {
    return new MediaLiveStopChannelEncoderSettingsNielsenConfiguration(this, 'NielsenConfiguration', this.__resources, this.input);
  }

  public get outputGroups(): shapes.MediaLiveOutputGroup[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.OutputGroups'),
        outputPath: 'EncoderSettings.OutputGroups',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.OutputGroups', props);
    return resource.getResponseField('EncoderSettings.OutputGroups') as unknown as shapes.MediaLiveOutputGroup[];
  }

  public get timecodeConfig(): MediaLiveStopChannelEncoderSettingsTimecodeConfig {
    return new MediaLiveStopChannelEncoderSettingsTimecodeConfig(this, 'TimecodeConfig', this.__resources, this.input);
  }

  public get videoDescriptions(): shapes.MediaLiveVideoDescription[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.VideoDescriptions'),
        outputPath: 'EncoderSettings.VideoDescriptions',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.VideoDescriptions', props);
    return resource.getResponseField('EncoderSettings.VideoDescriptions') as unknown as shapes.MediaLiveVideoDescription[];
  }

}

export class MediaLiveStopChannelEncoderSettingsAvailBlanking extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStopChannelRequest) {
    super(scope, id);
  }

  public get availBlankingImage(): MediaLiveStopChannelEncoderSettingsAvailBlankingAvailBlankingImage {
    return new MediaLiveStopChannelEncoderSettingsAvailBlankingAvailBlankingImage(this, 'AvailBlankingImage', this.__resources, this.input);
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.AvailBlanking.State'),
        outputPath: 'EncoderSettings.AvailBlanking.State',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.AvailBlanking.State', props);
    return resource.getResponseField('EncoderSettings.AvailBlanking.State') as unknown as string;
  }

}

export class MediaLiveStopChannelEncoderSettingsAvailBlankingAvailBlankingImage extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStopChannelRequest) {
    super(scope, id);
  }

  public get passwordParam(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.AvailBlanking.AvailBlankingImage.PasswordParam'),
        outputPath: 'EncoderSettings.AvailBlanking.AvailBlankingImage.PasswordParam',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.AvailBlanking.AvailBlankingImage.PasswordParam', props);
    return resource.getResponseField('EncoderSettings.AvailBlanking.AvailBlankingImage.PasswordParam') as unknown as string;
  }

  public get uri(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.AvailBlanking.AvailBlankingImage.Uri'),
        outputPath: 'EncoderSettings.AvailBlanking.AvailBlankingImage.Uri',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.AvailBlanking.AvailBlankingImage.Uri', props);
    return resource.getResponseField('EncoderSettings.AvailBlanking.AvailBlankingImage.Uri') as unknown as string;
  }

  public get username(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.AvailBlanking.AvailBlankingImage.Username'),
        outputPath: 'EncoderSettings.AvailBlanking.AvailBlankingImage.Username',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.AvailBlanking.AvailBlankingImage.Username', props);
    return resource.getResponseField('EncoderSettings.AvailBlanking.AvailBlankingImage.Username') as unknown as string;
  }

}

export class MediaLiveStopChannelEncoderSettingsAvailConfiguration extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStopChannelRequest) {
    super(scope, id);
  }

  public get availSettings(): MediaLiveStopChannelEncoderSettingsAvailConfigurationAvailSettings {
    return new MediaLiveStopChannelEncoderSettingsAvailConfigurationAvailSettings(this, 'AvailSettings', this.__resources, this.input);
  }

}

export class MediaLiveStopChannelEncoderSettingsAvailConfigurationAvailSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStopChannelRequest) {
    super(scope, id);
  }

  public get scte35SpliceInsert(): MediaLiveStopChannelEncoderSettingsAvailConfigurationAvailSettingsScte35SpliceInsert {
    return new MediaLiveStopChannelEncoderSettingsAvailConfigurationAvailSettingsScte35SpliceInsert(this, 'Scte35SpliceInsert', this.__resources, this.input);
  }

  public get scte35TimeSignalApos(): MediaLiveStopChannelEncoderSettingsAvailConfigurationAvailSettingsScte35TimeSignalApos {
    return new MediaLiveStopChannelEncoderSettingsAvailConfigurationAvailSettingsScte35TimeSignalApos(this, 'Scte35TimeSignalApos', this.__resources, this.input);
  }

}

export class MediaLiveStopChannelEncoderSettingsAvailConfigurationAvailSettingsScte35SpliceInsert extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStopChannelRequest) {
    super(scope, id);
  }

  public get adAvailOffset(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.AdAvailOffset'),
        outputPath: 'EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.AdAvailOffset',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.AdAvailOffset', props);
    return resource.getResponseField('EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.AdAvailOffset') as unknown as number;
  }

  public get noRegionalBlackoutFlag(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.NoRegionalBlackoutFlag'),
        outputPath: 'EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.NoRegionalBlackoutFlag',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.NoRegionalBlackoutFlag', props);
    return resource.getResponseField('EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.NoRegionalBlackoutFlag') as unknown as string;
  }

  public get webDeliveryAllowedFlag(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.WebDeliveryAllowedFlag'),
        outputPath: 'EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.WebDeliveryAllowedFlag',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.WebDeliveryAllowedFlag', props);
    return resource.getResponseField('EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.WebDeliveryAllowedFlag') as unknown as string;
  }

}

export class MediaLiveStopChannelEncoderSettingsAvailConfigurationAvailSettingsScte35TimeSignalApos extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStopChannelRequest) {
    super(scope, id);
  }

  public get adAvailOffset(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.AdAvailOffset'),
        outputPath: 'EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.AdAvailOffset',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.AdAvailOffset', props);
    return resource.getResponseField('EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.AdAvailOffset') as unknown as number;
  }

  public get noRegionalBlackoutFlag(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.NoRegionalBlackoutFlag'),
        outputPath: 'EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.NoRegionalBlackoutFlag',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.NoRegionalBlackoutFlag', props);
    return resource.getResponseField('EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.NoRegionalBlackoutFlag') as unknown as string;
  }

  public get webDeliveryAllowedFlag(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.WebDeliveryAllowedFlag'),
        outputPath: 'EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.WebDeliveryAllowedFlag',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.WebDeliveryAllowedFlag', props);
    return resource.getResponseField('EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.WebDeliveryAllowedFlag') as unknown as string;
  }

}

export class MediaLiveStopChannelEncoderSettingsBlackoutSlate extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStopChannelRequest) {
    super(scope, id);
  }

  public get blackoutSlateImage(): MediaLiveStopChannelEncoderSettingsBlackoutSlateBlackoutSlateImage {
    return new MediaLiveStopChannelEncoderSettingsBlackoutSlateBlackoutSlateImage(this, 'BlackoutSlateImage', this.__resources, this.input);
  }

  public get networkEndBlackout(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackout'),
        outputPath: 'EncoderSettings.BlackoutSlate.NetworkEndBlackout',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackout', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.NetworkEndBlackout') as unknown as string;
  }

  public get networkEndBlackoutImage(): MediaLiveStopChannelEncoderSettingsBlackoutSlateNetworkEndBlackoutImage {
    return new MediaLiveStopChannelEncoderSettingsBlackoutSlateNetworkEndBlackoutImage(this, 'NetworkEndBlackoutImage', this.__resources, this.input);
  }

  public get networkId(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.BlackoutSlate.NetworkId'),
        outputPath: 'EncoderSettings.BlackoutSlate.NetworkId',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.BlackoutSlate.NetworkId', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.NetworkId') as unknown as string;
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.BlackoutSlate.State'),
        outputPath: 'EncoderSettings.BlackoutSlate.State',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.BlackoutSlate.State', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.State') as unknown as string;
  }

}

export class MediaLiveStopChannelEncoderSettingsBlackoutSlateBlackoutSlateImage extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStopChannelRequest) {
    super(scope, id);
  }

  public get passwordParam(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.PasswordParam'),
        outputPath: 'EncoderSettings.BlackoutSlate.BlackoutSlateImage.PasswordParam',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.PasswordParam', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.BlackoutSlateImage.PasswordParam') as unknown as string;
  }

  public get uri(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Uri'),
        outputPath: 'EncoderSettings.BlackoutSlate.BlackoutSlateImage.Uri',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Uri', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.BlackoutSlateImage.Uri') as unknown as string;
  }

  public get username(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Username'),
        outputPath: 'EncoderSettings.BlackoutSlate.BlackoutSlateImage.Username',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Username', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.BlackoutSlateImage.Username') as unknown as string;
  }

}

export class MediaLiveStopChannelEncoderSettingsBlackoutSlateNetworkEndBlackoutImage extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStopChannelRequest) {
    super(scope, id);
  }

  public get passwordParam(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.PasswordParam'),
        outputPath: 'EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.PasswordParam',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.PasswordParam', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.PasswordParam') as unknown as string;
  }

  public get uri(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Uri'),
        outputPath: 'EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Uri',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Uri', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Uri') as unknown as string;
  }

  public get username(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Username'),
        outputPath: 'EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Username',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Username', props);
    return resource.getResponseField('EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Username') as unknown as string;
  }

}

export class MediaLiveStopChannelEncoderSettingsFeatureActivations extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStopChannelRequest) {
    super(scope, id);
  }

  public get inputPrepareScheduleActions(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.FeatureActivations.InputPrepareScheduleActions'),
        outputPath: 'EncoderSettings.FeatureActivations.InputPrepareScheduleActions',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.FeatureActivations.InputPrepareScheduleActions', props);
    return resource.getResponseField('EncoderSettings.FeatureActivations.InputPrepareScheduleActions') as unknown as string;
  }

}

export class MediaLiveStopChannelEncoderSettingsGlobalConfiguration extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStopChannelRequest) {
    super(scope, id);
  }

  public get initialAudioGain(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.GlobalConfiguration.InitialAudioGain'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InitialAudioGain',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.GlobalConfiguration.InitialAudioGain', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InitialAudioGain') as unknown as number;
  }

  public get inputEndAction(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.GlobalConfiguration.InputEndAction'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputEndAction',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.GlobalConfiguration.InputEndAction', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputEndAction') as unknown as string;
  }

  public get inputLossBehavior(): MediaLiveStopChannelEncoderSettingsGlobalConfigurationInputLossBehavior {
    return new MediaLiveStopChannelEncoderSettingsGlobalConfigurationInputLossBehavior(this, 'InputLossBehavior', this.__resources, this.input);
  }

  public get outputLockingMode(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.GlobalConfiguration.OutputLockingMode'),
        outputPath: 'EncoderSettings.GlobalConfiguration.OutputLockingMode',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.GlobalConfiguration.OutputLockingMode', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.OutputLockingMode') as unknown as string;
  }

  public get outputTimingSource(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.GlobalConfiguration.OutputTimingSource'),
        outputPath: 'EncoderSettings.GlobalConfiguration.OutputTimingSource',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.GlobalConfiguration.OutputTimingSource', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.OutputTimingSource') as unknown as string;
  }

  public get supportLowFramerateInputs(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.GlobalConfiguration.SupportLowFramerateInputs'),
        outputPath: 'EncoderSettings.GlobalConfiguration.SupportLowFramerateInputs',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.GlobalConfiguration.SupportLowFramerateInputs', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.SupportLowFramerateInputs') as unknown as string;
  }

}

export class MediaLiveStopChannelEncoderSettingsGlobalConfigurationInputLossBehavior extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStopChannelRequest) {
    super(scope, id);
  }

  public get blackFrameMsec(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.BlackFrameMsec'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputLossBehavior.BlackFrameMsec',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.BlackFrameMsec', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputLossBehavior.BlackFrameMsec') as unknown as number;
  }

  public get inputLossImageColor(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageColor'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageColor',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageColor', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageColor') as unknown as string;
  }

  public get inputLossImageSlate(): MediaLiveStopChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate {
    return new MediaLiveStopChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate(this, 'InputLossImageSlate', this.__resources, this.input);
  }

  public get inputLossImageType(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageType'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageType',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageType', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageType') as unknown as string;
  }

  public get repeatFrameMsec(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.RepeatFrameMsec'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputLossBehavior.RepeatFrameMsec',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.RepeatFrameMsec', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputLossBehavior.RepeatFrameMsec') as unknown as number;
  }

}

export class MediaLiveStopChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStopChannelRequest) {
    super(scope, id);
  }

  public get passwordParam(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.PasswordParam'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.PasswordParam',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.PasswordParam', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.PasswordParam') as unknown as string;
  }

  public get uri(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Uri'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Uri',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Uri', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Uri') as unknown as string;
  }

  public get username(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Username'),
        outputPath: 'EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Username',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Username', props);
    return resource.getResponseField('EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Username') as unknown as string;
  }

}

export class MediaLiveStopChannelEncoderSettingsNielsenConfiguration extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStopChannelRequest) {
    super(scope, id);
  }

  public get distributorId(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.NielsenConfiguration.DistributorId'),
        outputPath: 'EncoderSettings.NielsenConfiguration.DistributorId',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.NielsenConfiguration.DistributorId', props);
    return resource.getResponseField('EncoderSettings.NielsenConfiguration.DistributorId') as unknown as string;
  }

  public get nielsenPcmToId3Tagging(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.NielsenConfiguration.NielsenPcmToId3Tagging'),
        outputPath: 'EncoderSettings.NielsenConfiguration.NielsenPcmToId3Tagging',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.NielsenConfiguration.NielsenPcmToId3Tagging', props);
    return resource.getResponseField('EncoderSettings.NielsenConfiguration.NielsenPcmToId3Tagging') as unknown as string;
  }

}

export class MediaLiveStopChannelEncoderSettingsTimecodeConfig extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStopChannelRequest) {
    super(scope, id);
  }

  public get source(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.TimecodeConfig.Source'),
        outputPath: 'EncoderSettings.TimecodeConfig.Source',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.TimecodeConfig.Source', props);
    return resource.getResponseField('EncoderSettings.TimecodeConfig.Source') as unknown as string;
  }

  public get syncThreshold(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.EncoderSettings.TimecodeConfig.SyncThreshold'),
        outputPath: 'EncoderSettings.TimecodeConfig.SyncThreshold',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.EncoderSettings.TimecodeConfig.SyncThreshold', props);
    return resource.getResponseField('EncoderSettings.TimecodeConfig.SyncThreshold') as unknown as number;
  }

}

export class MediaLiveStopChannelInputSpecification extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStopChannelRequest) {
    super(scope, id);
  }

  public get codec(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.InputSpecification.Codec'),
        outputPath: 'InputSpecification.Codec',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.InputSpecification.Codec', props);
    return resource.getResponseField('InputSpecification.Codec') as unknown as string;
  }

  public get maximumBitrate(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.InputSpecification.MaximumBitrate'),
        outputPath: 'InputSpecification.MaximumBitrate',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.InputSpecification.MaximumBitrate', props);
    return resource.getResponseField('InputSpecification.MaximumBitrate') as unknown as string;
  }

  public get resolution(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopChannel.InputSpecification.Resolution'),
        outputPath: 'InputSpecification.Resolution',
        parameters: {
          ChannelId: this.input.channelId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopChannel.InputSpecification.Resolution', props);
    return resource.getResponseField('InputSpecification.Resolution') as unknown as string;
  }

}

export class MediaLiveStopMultiplex extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStopMultiplexRequest) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopMultiplex.Arn'),
        outputPath: 'Arn',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopMultiplex.Arn', props);
    return resource.getResponseField('Arn') as unknown as string;
  }

  public get availabilityZones(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopMultiplex.AvailabilityZones'),
        outputPath: 'AvailabilityZones',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopMultiplex.AvailabilityZones', props);
    return resource.getResponseField('AvailabilityZones') as unknown as string[];
  }

  public get destinations(): shapes.MediaLiveMultiplexOutputDestination[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopMultiplex.Destinations'),
        outputPath: 'Destinations',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopMultiplex.Destinations', props);
    return resource.getResponseField('Destinations') as unknown as shapes.MediaLiveMultiplexOutputDestination[];
  }

  public get id(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopMultiplex.Id'),
        outputPath: 'Id',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopMultiplex.Id', props);
    return resource.getResponseField('Id') as unknown as string;
  }

  public get multiplexSettings(): MediaLiveStopMultiplexMultiplexSettings {
    return new MediaLiveStopMultiplexMultiplexSettings(this, 'MultiplexSettings', this.__resources, this.input);
  }

  public get name(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopMultiplex.Name'),
        outputPath: 'Name',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopMultiplex.Name', props);
    return resource.getResponseField('Name') as unknown as string;
  }

  public get pipelinesRunningCount(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopMultiplex.PipelinesRunningCount'),
        outputPath: 'PipelinesRunningCount',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopMultiplex.PipelinesRunningCount', props);
    return resource.getResponseField('PipelinesRunningCount') as unknown as number;
  }

  public get programCount(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopMultiplex.ProgramCount'),
        outputPath: 'ProgramCount',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopMultiplex.ProgramCount', props);
    return resource.getResponseField('ProgramCount') as unknown as number;
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopMultiplex.State'),
        outputPath: 'State',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopMultiplex.State', props);
    return resource.getResponseField('State') as unknown as string;
  }

  public get tags(): Record<string, string> {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopMultiplex.Tags'),
        outputPath: 'Tags',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopMultiplex.Tags', props);
    return resource.getResponseField('Tags') as unknown as Record<string, string>;
  }

}

export class MediaLiveStopMultiplexMultiplexSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveStopMultiplexRequest) {
    super(scope, id);
  }

  public get maximumVideoBufferDelayMilliseconds(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopMultiplex.MultiplexSettings.MaximumVideoBufferDelayMilliseconds'),
        outputPath: 'MultiplexSettings.MaximumVideoBufferDelayMilliseconds',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopMultiplex.MultiplexSettings.MaximumVideoBufferDelayMilliseconds', props);
    return resource.getResponseField('MultiplexSettings.MaximumVideoBufferDelayMilliseconds') as unknown as number;
  }

  public get transportStreamBitrate(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopMultiplex.MultiplexSettings.TransportStreamBitrate'),
        outputPath: 'MultiplexSettings.TransportStreamBitrate',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopMultiplex.MultiplexSettings.TransportStreamBitrate', props);
    return resource.getResponseField('MultiplexSettings.TransportStreamBitrate') as unknown as number;
  }

  public get transportStreamId(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopMultiplex.MultiplexSettings.TransportStreamId'),
        outputPath: 'MultiplexSettings.TransportStreamId',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopMultiplex.MultiplexSettings.TransportStreamId', props);
    return resource.getResponseField('MultiplexSettings.TransportStreamId') as unknown as number;
  }

  public get transportStreamReservedBitrate(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'stopMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.StopMultiplex.MultiplexSettings.TransportStreamReservedBitrate'),
        outputPath: 'MultiplexSettings.TransportStreamReservedBitrate',
        parameters: {
          MultiplexId: this.input.multiplexId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'StopMultiplex.MultiplexSettings.TransportStreamReservedBitrate', props);
    return resource.getResponseField('MultiplexSettings.TransportStreamReservedBitrate') as unknown as number;
  }

}

export class MediaLiveUpdateChannel extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelRequest) {
    super(scope, id);
  }

  public get channel(): MediaLiveUpdateChannelChannel {
    return new MediaLiveUpdateChannelChannel(this, 'Channel', this.__resources, this.input);
  }

}

export class MediaLiveUpdateChannelChannel extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelRequest) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.Arn'),
        outputPath: 'Channel.Arn',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.Arn', props);
    return resource.getResponseField('Channel.Arn') as unknown as string;
  }

  public get cdiInputSpecification(): MediaLiveUpdateChannelChannelCdiInputSpecification {
    return new MediaLiveUpdateChannelChannelCdiInputSpecification(this, 'CdiInputSpecification', this.__resources, this.input);
  }

  public get channelClass(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.ChannelClass'),
        outputPath: 'Channel.ChannelClass',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.ChannelClass', props);
    return resource.getResponseField('Channel.ChannelClass') as unknown as string;
  }

  public get destinations(): shapes.MediaLiveOutputDestination[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.Destinations'),
        outputPath: 'Channel.Destinations',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.Destinations', props);
    return resource.getResponseField('Channel.Destinations') as unknown as shapes.MediaLiveOutputDestination[];
  }

  public get egressEndpoints(): shapes.MediaLiveChannelEgressEndpoint[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EgressEndpoints'),
        outputPath: 'Channel.EgressEndpoints',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EgressEndpoints', props);
    return resource.getResponseField('Channel.EgressEndpoints') as unknown as shapes.MediaLiveChannelEgressEndpoint[];
  }

  public get encoderSettings(): MediaLiveUpdateChannelChannelEncoderSettings {
    return new MediaLiveUpdateChannelChannelEncoderSettings(this, 'EncoderSettings', this.__resources, this.input);
  }

  public get id(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.Id'),
        outputPath: 'Channel.Id',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.Id', props);
    return resource.getResponseField('Channel.Id') as unknown as string;
  }

  public get inputAttachments(): shapes.MediaLiveInputAttachment[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.InputAttachments'),
        outputPath: 'Channel.InputAttachments',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.InputAttachments', props);
    return resource.getResponseField('Channel.InputAttachments') as unknown as shapes.MediaLiveInputAttachment[];
  }

  public get inputSpecification(): MediaLiveUpdateChannelChannelInputSpecification {
    return new MediaLiveUpdateChannelChannelInputSpecification(this, 'InputSpecification', this.__resources, this.input);
  }

  public get logLevel(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.LogLevel'),
        outputPath: 'Channel.LogLevel',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.LogLevel', props);
    return resource.getResponseField('Channel.LogLevel') as unknown as string;
  }

  public get name(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.Name'),
        outputPath: 'Channel.Name',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.Name', props);
    return resource.getResponseField('Channel.Name') as unknown as string;
  }

  public get pipelineDetails(): shapes.MediaLivePipelineDetail[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.PipelineDetails'),
        outputPath: 'Channel.PipelineDetails',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.PipelineDetails', props);
    return resource.getResponseField('Channel.PipelineDetails') as unknown as shapes.MediaLivePipelineDetail[];
  }

  public get pipelinesRunningCount(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.PipelinesRunningCount'),
        outputPath: 'Channel.PipelinesRunningCount',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.PipelinesRunningCount', props);
    return resource.getResponseField('Channel.PipelinesRunningCount') as unknown as number;
  }

  public get roleArn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.RoleArn'),
        outputPath: 'Channel.RoleArn',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.RoleArn', props);
    return resource.getResponseField('Channel.RoleArn') as unknown as string;
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.State'),
        outputPath: 'Channel.State',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.State', props);
    return resource.getResponseField('Channel.State') as unknown as string;
  }

  public get tags(): Record<string, string> {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.Tags'),
        outputPath: 'Channel.Tags',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.Tags', props);
    return resource.getResponseField('Channel.Tags') as unknown as Record<string, string>;
  }

}

export class MediaLiveUpdateChannelChannelCdiInputSpecification extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelRequest) {
    super(scope, id);
  }

  public get resolution(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.CdiInputSpecification.Resolution'),
        outputPath: 'Channel.CdiInputSpecification.Resolution',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.CdiInputSpecification.Resolution', props);
    return resource.getResponseField('Channel.CdiInputSpecification.Resolution') as unknown as string;
  }

}

export class MediaLiveUpdateChannelChannelEncoderSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelRequest) {
    super(scope, id);
  }

  public get audioDescriptions(): shapes.MediaLiveAudioDescription[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.AudioDescriptions'),
        outputPath: 'Channel.EncoderSettings.AudioDescriptions',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.AudioDescriptions', props);
    return resource.getResponseField('Channel.EncoderSettings.AudioDescriptions') as unknown as shapes.MediaLiveAudioDescription[];
  }

  public get availBlanking(): MediaLiveUpdateChannelChannelEncoderSettingsAvailBlanking {
    return new MediaLiveUpdateChannelChannelEncoderSettingsAvailBlanking(this, 'AvailBlanking', this.__resources, this.input);
  }

  public get availConfiguration(): MediaLiveUpdateChannelChannelEncoderSettingsAvailConfiguration {
    return new MediaLiveUpdateChannelChannelEncoderSettingsAvailConfiguration(this, 'AvailConfiguration', this.__resources, this.input);
  }

  public get blackoutSlate(): MediaLiveUpdateChannelChannelEncoderSettingsBlackoutSlate {
    return new MediaLiveUpdateChannelChannelEncoderSettingsBlackoutSlate(this, 'BlackoutSlate', this.__resources, this.input);
  }

  public get captionDescriptions(): shapes.MediaLiveCaptionDescription[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.CaptionDescriptions'),
        outputPath: 'Channel.EncoderSettings.CaptionDescriptions',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.CaptionDescriptions', props);
    return resource.getResponseField('Channel.EncoderSettings.CaptionDescriptions') as unknown as shapes.MediaLiveCaptionDescription[];
  }

  public get featureActivations(): MediaLiveUpdateChannelChannelEncoderSettingsFeatureActivations {
    return new MediaLiveUpdateChannelChannelEncoderSettingsFeatureActivations(this, 'FeatureActivations', this.__resources, this.input);
  }

  public get globalConfiguration(): MediaLiveUpdateChannelChannelEncoderSettingsGlobalConfiguration {
    return new MediaLiveUpdateChannelChannelEncoderSettingsGlobalConfiguration(this, 'GlobalConfiguration', this.__resources, this.input);
  }

  public get nielsenConfiguration(): MediaLiveUpdateChannelChannelEncoderSettingsNielsenConfiguration {
    return new MediaLiveUpdateChannelChannelEncoderSettingsNielsenConfiguration(this, 'NielsenConfiguration', this.__resources, this.input);
  }

  public get outputGroups(): shapes.MediaLiveOutputGroup[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.OutputGroups'),
        outputPath: 'Channel.EncoderSettings.OutputGroups',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.OutputGroups', props);
    return resource.getResponseField('Channel.EncoderSettings.OutputGroups') as unknown as shapes.MediaLiveOutputGroup[];
  }

  public get timecodeConfig(): MediaLiveUpdateChannelChannelEncoderSettingsTimecodeConfig {
    return new MediaLiveUpdateChannelChannelEncoderSettingsTimecodeConfig(this, 'TimecodeConfig', this.__resources, this.input);
  }

  public get videoDescriptions(): shapes.MediaLiveVideoDescription[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.VideoDescriptions'),
        outputPath: 'Channel.EncoderSettings.VideoDescriptions',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.VideoDescriptions', props);
    return resource.getResponseField('Channel.EncoderSettings.VideoDescriptions') as unknown as shapes.MediaLiveVideoDescription[];
  }

}

export class MediaLiveUpdateChannelChannelEncoderSettingsAvailBlanking extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelRequest) {
    super(scope, id);
  }

  public get availBlankingImage(): MediaLiveUpdateChannelChannelEncoderSettingsAvailBlankingAvailBlankingImage {
    return new MediaLiveUpdateChannelChannelEncoderSettingsAvailBlankingAvailBlankingImage(this, 'AvailBlankingImage', this.__resources, this.input);
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.AvailBlanking.State'),
        outputPath: 'Channel.EncoderSettings.AvailBlanking.State',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.AvailBlanking.State', props);
    return resource.getResponseField('Channel.EncoderSettings.AvailBlanking.State') as unknown as string;
  }

}

export class MediaLiveUpdateChannelChannelEncoderSettingsAvailBlankingAvailBlankingImage extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelRequest) {
    super(scope, id);
  }

  public get passwordParam(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.PasswordParam'),
        outputPath: 'Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.PasswordParam',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.PasswordParam', props);
    return resource.getResponseField('Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.PasswordParam') as unknown as string;
  }

  public get uri(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.Uri'),
        outputPath: 'Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.Uri',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.Uri', props);
    return resource.getResponseField('Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.Uri') as unknown as string;
  }

  public get username(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.Username'),
        outputPath: 'Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.Username',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.Username', props);
    return resource.getResponseField('Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.Username') as unknown as string;
  }

}

export class MediaLiveUpdateChannelChannelEncoderSettingsAvailConfiguration extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelRequest) {
    super(scope, id);
  }

  public get availSettings(): MediaLiveUpdateChannelChannelEncoderSettingsAvailConfigurationAvailSettings {
    return new MediaLiveUpdateChannelChannelEncoderSettingsAvailConfigurationAvailSettings(this, 'AvailSettings', this.__resources, this.input);
  }

}

export class MediaLiveUpdateChannelChannelEncoderSettingsAvailConfigurationAvailSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelRequest) {
    super(scope, id);
  }

  public get scte35SpliceInsert(): MediaLiveUpdateChannelChannelEncoderSettingsAvailConfigurationAvailSettingsScte35SpliceInsert {
    return new MediaLiveUpdateChannelChannelEncoderSettingsAvailConfigurationAvailSettingsScte35SpliceInsert(this, 'Scte35SpliceInsert', this.__resources, this.input);
  }

  public get scte35TimeSignalApos(): MediaLiveUpdateChannelChannelEncoderSettingsAvailConfigurationAvailSettingsScte35TimeSignalApos {
    return new MediaLiveUpdateChannelChannelEncoderSettingsAvailConfigurationAvailSettingsScte35TimeSignalApos(this, 'Scte35TimeSignalApos', this.__resources, this.input);
  }

}

export class MediaLiveUpdateChannelChannelEncoderSettingsAvailConfigurationAvailSettingsScte35SpliceInsert extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelRequest) {
    super(scope, id);
  }

  public get adAvailOffset(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.AdAvailOffset'),
        outputPath: 'Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.AdAvailOffset',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.AdAvailOffset', props);
    return resource.getResponseField('Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.AdAvailOffset') as unknown as number;
  }

  public get noRegionalBlackoutFlag(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.NoRegionalBlackoutFlag'),
        outputPath: 'Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.NoRegionalBlackoutFlag',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.NoRegionalBlackoutFlag', props);
    return resource.getResponseField('Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.NoRegionalBlackoutFlag') as unknown as string;
  }

  public get webDeliveryAllowedFlag(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.WebDeliveryAllowedFlag'),
        outputPath: 'Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.WebDeliveryAllowedFlag',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.WebDeliveryAllowedFlag', props);
    return resource.getResponseField('Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.WebDeliveryAllowedFlag') as unknown as string;
  }

}

export class MediaLiveUpdateChannelChannelEncoderSettingsAvailConfigurationAvailSettingsScte35TimeSignalApos extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelRequest) {
    super(scope, id);
  }

  public get adAvailOffset(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.AdAvailOffset'),
        outputPath: 'Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.AdAvailOffset',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.AdAvailOffset', props);
    return resource.getResponseField('Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.AdAvailOffset') as unknown as number;
  }

  public get noRegionalBlackoutFlag(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.NoRegionalBlackoutFlag'),
        outputPath: 'Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.NoRegionalBlackoutFlag',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.NoRegionalBlackoutFlag', props);
    return resource.getResponseField('Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.NoRegionalBlackoutFlag') as unknown as string;
  }

  public get webDeliveryAllowedFlag(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.WebDeliveryAllowedFlag'),
        outputPath: 'Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.WebDeliveryAllowedFlag',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.WebDeliveryAllowedFlag', props);
    return resource.getResponseField('Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.WebDeliveryAllowedFlag') as unknown as string;
  }

}

export class MediaLiveUpdateChannelChannelEncoderSettingsBlackoutSlate extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelRequest) {
    super(scope, id);
  }

  public get blackoutSlateImage(): MediaLiveUpdateChannelChannelEncoderSettingsBlackoutSlateBlackoutSlateImage {
    return new MediaLiveUpdateChannelChannelEncoderSettingsBlackoutSlateBlackoutSlateImage(this, 'BlackoutSlateImage', this.__resources, this.input);
  }

  public get networkEndBlackout(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackout'),
        outputPath: 'Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackout',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackout', props);
    return resource.getResponseField('Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackout') as unknown as string;
  }

  public get networkEndBlackoutImage(): MediaLiveUpdateChannelChannelEncoderSettingsBlackoutSlateNetworkEndBlackoutImage {
    return new MediaLiveUpdateChannelChannelEncoderSettingsBlackoutSlateNetworkEndBlackoutImage(this, 'NetworkEndBlackoutImage', this.__resources, this.input);
  }

  public get networkId(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.BlackoutSlate.NetworkId'),
        outputPath: 'Channel.EncoderSettings.BlackoutSlate.NetworkId',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.BlackoutSlate.NetworkId', props);
    return resource.getResponseField('Channel.EncoderSettings.BlackoutSlate.NetworkId') as unknown as string;
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.BlackoutSlate.State'),
        outputPath: 'Channel.EncoderSettings.BlackoutSlate.State',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.BlackoutSlate.State', props);
    return resource.getResponseField('Channel.EncoderSettings.BlackoutSlate.State') as unknown as string;
  }

}

export class MediaLiveUpdateChannelChannelEncoderSettingsBlackoutSlateBlackoutSlateImage extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelRequest) {
    super(scope, id);
  }

  public get passwordParam(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.PasswordParam'),
        outputPath: 'Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.PasswordParam',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.PasswordParam', props);
    return resource.getResponseField('Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.PasswordParam') as unknown as string;
  }

  public get uri(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Uri'),
        outputPath: 'Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Uri',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Uri', props);
    return resource.getResponseField('Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Uri') as unknown as string;
  }

  public get username(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Username'),
        outputPath: 'Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Username',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Username', props);
    return resource.getResponseField('Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Username') as unknown as string;
  }

}

export class MediaLiveUpdateChannelChannelEncoderSettingsBlackoutSlateNetworkEndBlackoutImage extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelRequest) {
    super(scope, id);
  }

  public get passwordParam(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.PasswordParam'),
        outputPath: 'Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.PasswordParam',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.PasswordParam', props);
    return resource.getResponseField('Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.PasswordParam') as unknown as string;
  }

  public get uri(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Uri'),
        outputPath: 'Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Uri',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Uri', props);
    return resource.getResponseField('Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Uri') as unknown as string;
  }

  public get username(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Username'),
        outputPath: 'Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Username',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Username', props);
    return resource.getResponseField('Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Username') as unknown as string;
  }

}

export class MediaLiveUpdateChannelChannelEncoderSettingsFeatureActivations extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelRequest) {
    super(scope, id);
  }

  public get inputPrepareScheduleActions(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.FeatureActivations.InputPrepareScheduleActions'),
        outputPath: 'Channel.EncoderSettings.FeatureActivations.InputPrepareScheduleActions',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.FeatureActivations.InputPrepareScheduleActions', props);
    return resource.getResponseField('Channel.EncoderSettings.FeatureActivations.InputPrepareScheduleActions') as unknown as string;
  }

}

export class MediaLiveUpdateChannelChannelEncoderSettingsGlobalConfiguration extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelRequest) {
    super(scope, id);
  }

  public get initialAudioGain(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.GlobalConfiguration.InitialAudioGain'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.InitialAudioGain',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.GlobalConfiguration.InitialAudioGain', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.InitialAudioGain') as unknown as number;
  }

  public get inputEndAction(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.GlobalConfiguration.InputEndAction'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.InputEndAction',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.GlobalConfiguration.InputEndAction', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.InputEndAction') as unknown as string;
  }

  public get inputLossBehavior(): MediaLiveUpdateChannelChannelEncoderSettingsGlobalConfigurationInputLossBehavior {
    return new MediaLiveUpdateChannelChannelEncoderSettingsGlobalConfigurationInputLossBehavior(this, 'InputLossBehavior', this.__resources, this.input);
  }

  public get outputLockingMode(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.GlobalConfiguration.OutputLockingMode'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.OutputLockingMode',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.GlobalConfiguration.OutputLockingMode', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.OutputLockingMode') as unknown as string;
  }

  public get outputTimingSource(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.GlobalConfiguration.OutputTimingSource'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.OutputTimingSource',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.GlobalConfiguration.OutputTimingSource', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.OutputTimingSource') as unknown as string;
  }

  public get supportLowFramerateInputs(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.GlobalConfiguration.SupportLowFramerateInputs'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.SupportLowFramerateInputs',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.GlobalConfiguration.SupportLowFramerateInputs', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.SupportLowFramerateInputs') as unknown as string;
  }

}

export class MediaLiveUpdateChannelChannelEncoderSettingsGlobalConfigurationInputLossBehavior extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelRequest) {
    super(scope, id);
  }

  public get blackFrameMsec(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.BlackFrameMsec'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.BlackFrameMsec',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.BlackFrameMsec', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.BlackFrameMsec') as unknown as number;
  }

  public get inputLossImageColor(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageColor'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageColor',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageColor', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageColor') as unknown as string;
  }

  public get inputLossImageSlate(): MediaLiveUpdateChannelChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate {
    return new MediaLiveUpdateChannelChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate(this, 'InputLossImageSlate', this.__resources, this.input);
  }

  public get inputLossImageType(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageType'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageType',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageType', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageType') as unknown as string;
  }

  public get repeatFrameMsec(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.RepeatFrameMsec'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.RepeatFrameMsec',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.RepeatFrameMsec', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.RepeatFrameMsec') as unknown as number;
  }

}

export class MediaLiveUpdateChannelChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelRequest) {
    super(scope, id);
  }

  public get passwordParam(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.PasswordParam'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.PasswordParam',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.PasswordParam', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.PasswordParam') as unknown as string;
  }

  public get uri(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Uri'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Uri',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Uri', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Uri') as unknown as string;
  }

  public get username(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Username'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Username',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Username', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Username') as unknown as string;
  }

}

export class MediaLiveUpdateChannelChannelEncoderSettingsNielsenConfiguration extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelRequest) {
    super(scope, id);
  }

  public get distributorId(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.NielsenConfiguration.DistributorId'),
        outputPath: 'Channel.EncoderSettings.NielsenConfiguration.DistributorId',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.NielsenConfiguration.DistributorId', props);
    return resource.getResponseField('Channel.EncoderSettings.NielsenConfiguration.DistributorId') as unknown as string;
  }

  public get nielsenPcmToId3Tagging(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.NielsenConfiguration.NielsenPcmToId3Tagging'),
        outputPath: 'Channel.EncoderSettings.NielsenConfiguration.NielsenPcmToId3Tagging',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.NielsenConfiguration.NielsenPcmToId3Tagging', props);
    return resource.getResponseField('Channel.EncoderSettings.NielsenConfiguration.NielsenPcmToId3Tagging') as unknown as string;
  }

}

export class MediaLiveUpdateChannelChannelEncoderSettingsTimecodeConfig extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelRequest) {
    super(scope, id);
  }

  public get source(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.TimecodeConfig.Source'),
        outputPath: 'Channel.EncoderSettings.TimecodeConfig.Source',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.TimecodeConfig.Source', props);
    return resource.getResponseField('Channel.EncoderSettings.TimecodeConfig.Source') as unknown as string;
  }

  public get syncThreshold(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.EncoderSettings.TimecodeConfig.SyncThreshold'),
        outputPath: 'Channel.EncoderSettings.TimecodeConfig.SyncThreshold',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.EncoderSettings.TimecodeConfig.SyncThreshold', props);
    return resource.getResponseField('Channel.EncoderSettings.TimecodeConfig.SyncThreshold') as unknown as number;
  }

}

export class MediaLiveUpdateChannelChannelInputSpecification extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelRequest) {
    super(scope, id);
  }

  public get codec(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.InputSpecification.Codec'),
        outputPath: 'Channel.InputSpecification.Codec',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.InputSpecification.Codec', props);
    return resource.getResponseField('Channel.InputSpecification.Codec') as unknown as string;
  }

  public get maximumBitrate(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.InputSpecification.MaximumBitrate'),
        outputPath: 'Channel.InputSpecification.MaximumBitrate',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.InputSpecification.MaximumBitrate', props);
    return resource.getResponseField('Channel.InputSpecification.MaximumBitrate') as unknown as string;
  }

  public get resolution(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannel',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannel.Channel.InputSpecification.Resolution'),
        outputPath: 'Channel.InputSpecification.Resolution',
        parameters: {
          CdiInputSpecification: {
            Resolution: this.input.cdiInputSpecification?.resolution,
          },
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
          EncoderSettings: {
            AudioDescriptions: this.input.encoderSettings?.audioDescriptions,
            AvailBlanking: {
              AvailBlankingImage: {
                PasswordParam: this.input.encoderSettings?.availBlanking?.availBlankingImage?.passwordParam,
                Uri: this.input.encoderSettings?.availBlanking?.availBlankingImage?.uri,
                Username: this.input.encoderSettings?.availBlanking?.availBlankingImage?.username,
              },
              State: this.input.encoderSettings?.availBlanking?.state,
            },
            AvailConfiguration: {
              AvailSettings: {
                Scte35SpliceInsert: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35SpliceInsert?.webDeliveryAllowedFlag,
                },
                Scte35TimeSignalApos: {
                  AdAvailOffset: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.adAvailOffset,
                  NoRegionalBlackoutFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.noRegionalBlackoutFlag,
                  WebDeliveryAllowedFlag: this.input.encoderSettings?.availConfiguration?.availSettings?.scte35TimeSignalApos?.webDeliveryAllowedFlag,
                },
              },
            },
            BlackoutSlate: {
              BlackoutSlateImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.blackoutSlateImage?.username,
              },
              NetworkEndBlackout: this.input.encoderSettings?.blackoutSlate?.networkEndBlackout,
              NetworkEndBlackoutImage: {
                PasswordParam: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.passwordParam,
                Uri: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.uri,
                Username: this.input.encoderSettings?.blackoutSlate?.networkEndBlackoutImage?.username,
              },
              NetworkId: this.input.encoderSettings?.blackoutSlate?.networkId,
              State: this.input.encoderSettings?.blackoutSlate?.state,
            },
            CaptionDescriptions: this.input.encoderSettings?.captionDescriptions,
            FeatureActivations: {
              InputPrepareScheduleActions: this.input.encoderSettings?.featureActivations?.inputPrepareScheduleActions,
            },
            GlobalConfiguration: {
              InitialAudioGain: this.input.encoderSettings?.globalConfiguration?.initialAudioGain,
              InputEndAction: this.input.encoderSettings?.globalConfiguration?.inputEndAction,
              InputLossBehavior: {
                BlackFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.blackFrameMsec,
                InputLossImageColor: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageColor,
                InputLossImageSlate: {
                  PasswordParam: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.passwordParam,
                  Uri: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.uri,
                  Username: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageSlate?.username,
                },
                InputLossImageType: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.inputLossImageType,
                RepeatFrameMsec: this.input.encoderSettings?.globalConfiguration?.inputLossBehavior?.repeatFrameMsec,
              },
              OutputLockingMode: this.input.encoderSettings?.globalConfiguration?.outputLockingMode,
              OutputTimingSource: this.input.encoderSettings?.globalConfiguration?.outputTimingSource,
              SupportLowFramerateInputs: this.input.encoderSettings?.globalConfiguration?.supportLowFramerateInputs,
            },
            NielsenConfiguration: {
              DistributorId: this.input.encoderSettings?.nielsenConfiguration?.distributorId,
              NielsenPcmToId3Tagging: this.input.encoderSettings?.nielsenConfiguration?.nielsenPcmToId3Tagging,
            },
            OutputGroups: this.input.encoderSettings?.outputGroups,
            TimecodeConfig: {
              Source: this.input.encoderSettings?.timecodeConfig.source,
              SyncThreshold: this.input.encoderSettings?.timecodeConfig.syncThreshold,
            },
            VideoDescriptions: this.input.encoderSettings?.videoDescriptions,
          },
          InputAttachments: this.input.inputAttachments,
          InputSpecification: {
            Codec: this.input.inputSpecification?.codec,
            MaximumBitrate: this.input.inputSpecification?.maximumBitrate,
            Resolution: this.input.inputSpecification?.resolution,
          },
          LogLevel: this.input.logLevel,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannel.Channel.InputSpecification.Resolution', props);
    return resource.getResponseField('Channel.InputSpecification.Resolution') as unknown as string;
  }

}

export class MediaLiveUpdateChannelClass extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelClassRequest) {
    super(scope, id);
  }

  public get channel(): MediaLiveUpdateChannelClassChannel {
    return new MediaLiveUpdateChannelClassChannel(this, 'Channel', this.__resources, this.input);
  }

}

export class MediaLiveUpdateChannelClassChannel extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelClassRequest) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.Arn'),
        outputPath: 'Channel.Arn',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.Arn', props);
    return resource.getResponseField('Channel.Arn') as unknown as string;
  }

  public get cdiInputSpecification(): MediaLiveUpdateChannelClassChannelCdiInputSpecification {
    return new MediaLiveUpdateChannelClassChannelCdiInputSpecification(this, 'CdiInputSpecification', this.__resources, this.input);
  }

  public get channelClass(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.ChannelClass'),
        outputPath: 'Channel.ChannelClass',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.ChannelClass', props);
    return resource.getResponseField('Channel.ChannelClass') as unknown as string;
  }

  public get destinations(): shapes.MediaLiveOutputDestination[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.Destinations'),
        outputPath: 'Channel.Destinations',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.Destinations', props);
    return resource.getResponseField('Channel.Destinations') as unknown as shapes.MediaLiveOutputDestination[];
  }

  public get egressEndpoints(): shapes.MediaLiveChannelEgressEndpoint[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EgressEndpoints'),
        outputPath: 'Channel.EgressEndpoints',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EgressEndpoints', props);
    return resource.getResponseField('Channel.EgressEndpoints') as unknown as shapes.MediaLiveChannelEgressEndpoint[];
  }

  public get encoderSettings(): MediaLiveUpdateChannelClassChannelEncoderSettings {
    return new MediaLiveUpdateChannelClassChannelEncoderSettings(this, 'EncoderSettings', this.__resources, this.input);
  }

  public get id(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.Id'),
        outputPath: 'Channel.Id',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.Id', props);
    return resource.getResponseField('Channel.Id') as unknown as string;
  }

  public get inputAttachments(): shapes.MediaLiveInputAttachment[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.InputAttachments'),
        outputPath: 'Channel.InputAttachments',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.InputAttachments', props);
    return resource.getResponseField('Channel.InputAttachments') as unknown as shapes.MediaLiveInputAttachment[];
  }

  public get inputSpecification(): MediaLiveUpdateChannelClassChannelInputSpecification {
    return new MediaLiveUpdateChannelClassChannelInputSpecification(this, 'InputSpecification', this.__resources, this.input);
  }

  public get logLevel(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.LogLevel'),
        outputPath: 'Channel.LogLevel',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.LogLevel', props);
    return resource.getResponseField('Channel.LogLevel') as unknown as string;
  }

  public get name(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.Name'),
        outputPath: 'Channel.Name',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.Name', props);
    return resource.getResponseField('Channel.Name') as unknown as string;
  }

  public get pipelineDetails(): shapes.MediaLivePipelineDetail[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.PipelineDetails'),
        outputPath: 'Channel.PipelineDetails',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.PipelineDetails', props);
    return resource.getResponseField('Channel.PipelineDetails') as unknown as shapes.MediaLivePipelineDetail[];
  }

  public get pipelinesRunningCount(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.PipelinesRunningCount'),
        outputPath: 'Channel.PipelinesRunningCount',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.PipelinesRunningCount', props);
    return resource.getResponseField('Channel.PipelinesRunningCount') as unknown as number;
  }

  public get roleArn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.RoleArn'),
        outputPath: 'Channel.RoleArn',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.RoleArn', props);
    return resource.getResponseField('Channel.RoleArn') as unknown as string;
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.State'),
        outputPath: 'Channel.State',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.State', props);
    return resource.getResponseField('Channel.State') as unknown as string;
  }

  public get tags(): Record<string, string> {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.Tags'),
        outputPath: 'Channel.Tags',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.Tags', props);
    return resource.getResponseField('Channel.Tags') as unknown as Record<string, string>;
  }

}

export class MediaLiveUpdateChannelClassChannelCdiInputSpecification extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelClassRequest) {
    super(scope, id);
  }

  public get resolution(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.CdiInputSpecification.Resolution'),
        outputPath: 'Channel.CdiInputSpecification.Resolution',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.CdiInputSpecification.Resolution', props);
    return resource.getResponseField('Channel.CdiInputSpecification.Resolution') as unknown as string;
  }

}

export class MediaLiveUpdateChannelClassChannelEncoderSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelClassRequest) {
    super(scope, id);
  }

  public get audioDescriptions(): shapes.MediaLiveAudioDescription[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.AudioDescriptions'),
        outputPath: 'Channel.EncoderSettings.AudioDescriptions',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.AudioDescriptions', props);
    return resource.getResponseField('Channel.EncoderSettings.AudioDescriptions') as unknown as shapes.MediaLiveAudioDescription[];
  }

  public get availBlanking(): MediaLiveUpdateChannelClassChannelEncoderSettingsAvailBlanking {
    return new MediaLiveUpdateChannelClassChannelEncoderSettingsAvailBlanking(this, 'AvailBlanking', this.__resources, this.input);
  }

  public get availConfiguration(): MediaLiveUpdateChannelClassChannelEncoderSettingsAvailConfiguration {
    return new MediaLiveUpdateChannelClassChannelEncoderSettingsAvailConfiguration(this, 'AvailConfiguration', this.__resources, this.input);
  }

  public get blackoutSlate(): MediaLiveUpdateChannelClassChannelEncoderSettingsBlackoutSlate {
    return new MediaLiveUpdateChannelClassChannelEncoderSettingsBlackoutSlate(this, 'BlackoutSlate', this.__resources, this.input);
  }

  public get captionDescriptions(): shapes.MediaLiveCaptionDescription[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.CaptionDescriptions'),
        outputPath: 'Channel.EncoderSettings.CaptionDescriptions',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.CaptionDescriptions', props);
    return resource.getResponseField('Channel.EncoderSettings.CaptionDescriptions') as unknown as shapes.MediaLiveCaptionDescription[];
  }

  public get featureActivations(): MediaLiveUpdateChannelClassChannelEncoderSettingsFeatureActivations {
    return new MediaLiveUpdateChannelClassChannelEncoderSettingsFeatureActivations(this, 'FeatureActivations', this.__resources, this.input);
  }

  public get globalConfiguration(): MediaLiveUpdateChannelClassChannelEncoderSettingsGlobalConfiguration {
    return new MediaLiveUpdateChannelClassChannelEncoderSettingsGlobalConfiguration(this, 'GlobalConfiguration', this.__resources, this.input);
  }

  public get nielsenConfiguration(): MediaLiveUpdateChannelClassChannelEncoderSettingsNielsenConfiguration {
    return new MediaLiveUpdateChannelClassChannelEncoderSettingsNielsenConfiguration(this, 'NielsenConfiguration', this.__resources, this.input);
  }

  public get outputGroups(): shapes.MediaLiveOutputGroup[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.OutputGroups'),
        outputPath: 'Channel.EncoderSettings.OutputGroups',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.OutputGroups', props);
    return resource.getResponseField('Channel.EncoderSettings.OutputGroups') as unknown as shapes.MediaLiveOutputGroup[];
  }

  public get timecodeConfig(): MediaLiveUpdateChannelClassChannelEncoderSettingsTimecodeConfig {
    return new MediaLiveUpdateChannelClassChannelEncoderSettingsTimecodeConfig(this, 'TimecodeConfig', this.__resources, this.input);
  }

  public get videoDescriptions(): shapes.MediaLiveVideoDescription[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.VideoDescriptions'),
        outputPath: 'Channel.EncoderSettings.VideoDescriptions',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.VideoDescriptions', props);
    return resource.getResponseField('Channel.EncoderSettings.VideoDescriptions') as unknown as shapes.MediaLiveVideoDescription[];
  }

}

export class MediaLiveUpdateChannelClassChannelEncoderSettingsAvailBlanking extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelClassRequest) {
    super(scope, id);
  }

  public get availBlankingImage(): MediaLiveUpdateChannelClassChannelEncoderSettingsAvailBlankingAvailBlankingImage {
    return new MediaLiveUpdateChannelClassChannelEncoderSettingsAvailBlankingAvailBlankingImage(this, 'AvailBlankingImage', this.__resources, this.input);
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.AvailBlanking.State'),
        outputPath: 'Channel.EncoderSettings.AvailBlanking.State',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.AvailBlanking.State', props);
    return resource.getResponseField('Channel.EncoderSettings.AvailBlanking.State') as unknown as string;
  }

}

export class MediaLiveUpdateChannelClassChannelEncoderSettingsAvailBlankingAvailBlankingImage extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelClassRequest) {
    super(scope, id);
  }

  public get passwordParam(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.PasswordParam'),
        outputPath: 'Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.PasswordParam',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.PasswordParam', props);
    return resource.getResponseField('Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.PasswordParam') as unknown as string;
  }

  public get uri(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.Uri'),
        outputPath: 'Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.Uri',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.Uri', props);
    return resource.getResponseField('Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.Uri') as unknown as string;
  }

  public get username(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.Username'),
        outputPath: 'Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.Username',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.Username', props);
    return resource.getResponseField('Channel.EncoderSettings.AvailBlanking.AvailBlankingImage.Username') as unknown as string;
  }

}

export class MediaLiveUpdateChannelClassChannelEncoderSettingsAvailConfiguration extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelClassRequest) {
    super(scope, id);
  }

  public get availSettings(): MediaLiveUpdateChannelClassChannelEncoderSettingsAvailConfigurationAvailSettings {
    return new MediaLiveUpdateChannelClassChannelEncoderSettingsAvailConfigurationAvailSettings(this, 'AvailSettings', this.__resources, this.input);
  }

}

export class MediaLiveUpdateChannelClassChannelEncoderSettingsAvailConfigurationAvailSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelClassRequest) {
    super(scope, id);
  }

  public get scte35SpliceInsert(): MediaLiveUpdateChannelClassChannelEncoderSettingsAvailConfigurationAvailSettingsScte35SpliceInsert {
    return new MediaLiveUpdateChannelClassChannelEncoderSettingsAvailConfigurationAvailSettingsScte35SpliceInsert(this, 'Scte35SpliceInsert', this.__resources, this.input);
  }

  public get scte35TimeSignalApos(): MediaLiveUpdateChannelClassChannelEncoderSettingsAvailConfigurationAvailSettingsScte35TimeSignalApos {
    return new MediaLiveUpdateChannelClassChannelEncoderSettingsAvailConfigurationAvailSettingsScte35TimeSignalApos(this, 'Scte35TimeSignalApos', this.__resources, this.input);
  }

}

export class MediaLiveUpdateChannelClassChannelEncoderSettingsAvailConfigurationAvailSettingsScte35SpliceInsert extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelClassRequest) {
    super(scope, id);
  }

  public get adAvailOffset(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.AdAvailOffset'),
        outputPath: 'Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.AdAvailOffset',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.AdAvailOffset', props);
    return resource.getResponseField('Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.AdAvailOffset') as unknown as number;
  }

  public get noRegionalBlackoutFlag(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.NoRegionalBlackoutFlag'),
        outputPath: 'Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.NoRegionalBlackoutFlag',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.NoRegionalBlackoutFlag', props);
    return resource.getResponseField('Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.NoRegionalBlackoutFlag') as unknown as string;
  }

  public get webDeliveryAllowedFlag(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.WebDeliveryAllowedFlag'),
        outputPath: 'Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.WebDeliveryAllowedFlag',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.WebDeliveryAllowedFlag', props);
    return resource.getResponseField('Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35SpliceInsert.WebDeliveryAllowedFlag') as unknown as string;
  }

}

export class MediaLiveUpdateChannelClassChannelEncoderSettingsAvailConfigurationAvailSettingsScte35TimeSignalApos extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelClassRequest) {
    super(scope, id);
  }

  public get adAvailOffset(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.AdAvailOffset'),
        outputPath: 'Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.AdAvailOffset',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.AdAvailOffset', props);
    return resource.getResponseField('Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.AdAvailOffset') as unknown as number;
  }

  public get noRegionalBlackoutFlag(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.NoRegionalBlackoutFlag'),
        outputPath: 'Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.NoRegionalBlackoutFlag',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.NoRegionalBlackoutFlag', props);
    return resource.getResponseField('Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.NoRegionalBlackoutFlag') as unknown as string;
  }

  public get webDeliveryAllowedFlag(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.WebDeliveryAllowedFlag'),
        outputPath: 'Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.WebDeliveryAllowedFlag',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.WebDeliveryAllowedFlag', props);
    return resource.getResponseField('Channel.EncoderSettings.AvailConfiguration.AvailSettings.Scte35TimeSignalApos.WebDeliveryAllowedFlag') as unknown as string;
  }

}

export class MediaLiveUpdateChannelClassChannelEncoderSettingsBlackoutSlate extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelClassRequest) {
    super(scope, id);
  }

  public get blackoutSlateImage(): MediaLiveUpdateChannelClassChannelEncoderSettingsBlackoutSlateBlackoutSlateImage {
    return new MediaLiveUpdateChannelClassChannelEncoderSettingsBlackoutSlateBlackoutSlateImage(this, 'BlackoutSlateImage', this.__resources, this.input);
  }

  public get networkEndBlackout(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackout'),
        outputPath: 'Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackout',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackout', props);
    return resource.getResponseField('Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackout') as unknown as string;
  }

  public get networkEndBlackoutImage(): MediaLiveUpdateChannelClassChannelEncoderSettingsBlackoutSlateNetworkEndBlackoutImage {
    return new MediaLiveUpdateChannelClassChannelEncoderSettingsBlackoutSlateNetworkEndBlackoutImage(this, 'NetworkEndBlackoutImage', this.__resources, this.input);
  }

  public get networkId(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.BlackoutSlate.NetworkId'),
        outputPath: 'Channel.EncoderSettings.BlackoutSlate.NetworkId',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.BlackoutSlate.NetworkId', props);
    return resource.getResponseField('Channel.EncoderSettings.BlackoutSlate.NetworkId') as unknown as string;
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.BlackoutSlate.State'),
        outputPath: 'Channel.EncoderSettings.BlackoutSlate.State',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.BlackoutSlate.State', props);
    return resource.getResponseField('Channel.EncoderSettings.BlackoutSlate.State') as unknown as string;
  }

}

export class MediaLiveUpdateChannelClassChannelEncoderSettingsBlackoutSlateBlackoutSlateImage extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelClassRequest) {
    super(scope, id);
  }

  public get passwordParam(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.PasswordParam'),
        outputPath: 'Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.PasswordParam',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.PasswordParam', props);
    return resource.getResponseField('Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.PasswordParam') as unknown as string;
  }

  public get uri(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Uri'),
        outputPath: 'Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Uri',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Uri', props);
    return resource.getResponseField('Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Uri') as unknown as string;
  }

  public get username(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Username'),
        outputPath: 'Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Username',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Username', props);
    return resource.getResponseField('Channel.EncoderSettings.BlackoutSlate.BlackoutSlateImage.Username') as unknown as string;
  }

}

export class MediaLiveUpdateChannelClassChannelEncoderSettingsBlackoutSlateNetworkEndBlackoutImage extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelClassRequest) {
    super(scope, id);
  }

  public get passwordParam(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.PasswordParam'),
        outputPath: 'Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.PasswordParam',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.PasswordParam', props);
    return resource.getResponseField('Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.PasswordParam') as unknown as string;
  }

  public get uri(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Uri'),
        outputPath: 'Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Uri',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Uri', props);
    return resource.getResponseField('Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Uri') as unknown as string;
  }

  public get username(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Username'),
        outputPath: 'Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Username',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Username', props);
    return resource.getResponseField('Channel.EncoderSettings.BlackoutSlate.NetworkEndBlackoutImage.Username') as unknown as string;
  }

}

export class MediaLiveUpdateChannelClassChannelEncoderSettingsFeatureActivations extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelClassRequest) {
    super(scope, id);
  }

  public get inputPrepareScheduleActions(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.FeatureActivations.InputPrepareScheduleActions'),
        outputPath: 'Channel.EncoderSettings.FeatureActivations.InputPrepareScheduleActions',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.FeatureActivations.InputPrepareScheduleActions', props);
    return resource.getResponseField('Channel.EncoderSettings.FeatureActivations.InputPrepareScheduleActions') as unknown as string;
  }

}

export class MediaLiveUpdateChannelClassChannelEncoderSettingsGlobalConfiguration extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelClassRequest) {
    super(scope, id);
  }

  public get initialAudioGain(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.GlobalConfiguration.InitialAudioGain'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.InitialAudioGain',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.GlobalConfiguration.InitialAudioGain', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.InitialAudioGain') as unknown as number;
  }

  public get inputEndAction(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.GlobalConfiguration.InputEndAction'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.InputEndAction',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.GlobalConfiguration.InputEndAction', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.InputEndAction') as unknown as string;
  }

  public get inputLossBehavior(): MediaLiveUpdateChannelClassChannelEncoderSettingsGlobalConfigurationInputLossBehavior {
    return new MediaLiveUpdateChannelClassChannelEncoderSettingsGlobalConfigurationInputLossBehavior(this, 'InputLossBehavior', this.__resources, this.input);
  }

  public get outputLockingMode(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.GlobalConfiguration.OutputLockingMode'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.OutputLockingMode',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.GlobalConfiguration.OutputLockingMode', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.OutputLockingMode') as unknown as string;
  }

  public get outputTimingSource(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.GlobalConfiguration.OutputTimingSource'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.OutputTimingSource',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.GlobalConfiguration.OutputTimingSource', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.OutputTimingSource') as unknown as string;
  }

  public get supportLowFramerateInputs(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.GlobalConfiguration.SupportLowFramerateInputs'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.SupportLowFramerateInputs',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.GlobalConfiguration.SupportLowFramerateInputs', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.SupportLowFramerateInputs') as unknown as string;
  }

}

export class MediaLiveUpdateChannelClassChannelEncoderSettingsGlobalConfigurationInputLossBehavior extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelClassRequest) {
    super(scope, id);
  }

  public get blackFrameMsec(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.BlackFrameMsec'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.BlackFrameMsec',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.BlackFrameMsec', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.BlackFrameMsec') as unknown as number;
  }

  public get inputLossImageColor(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageColor'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageColor',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageColor', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageColor') as unknown as string;
  }

  public get inputLossImageSlate(): MediaLiveUpdateChannelClassChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate {
    return new MediaLiveUpdateChannelClassChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate(this, 'InputLossImageSlate', this.__resources, this.input);
  }

  public get inputLossImageType(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageType'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageType',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageType', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageType') as unknown as string;
  }

  public get repeatFrameMsec(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.RepeatFrameMsec'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.RepeatFrameMsec',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.RepeatFrameMsec', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.RepeatFrameMsec') as unknown as number;
  }

}

export class MediaLiveUpdateChannelClassChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelClassRequest) {
    super(scope, id);
  }

  public get passwordParam(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.PasswordParam'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.PasswordParam',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.PasswordParam', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.PasswordParam') as unknown as string;
  }

  public get uri(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Uri'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Uri',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Uri', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Uri') as unknown as string;
  }

  public get username(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Username'),
        outputPath: 'Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Username',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Username', props);
    return resource.getResponseField('Channel.EncoderSettings.GlobalConfiguration.InputLossBehavior.InputLossImageSlate.Username') as unknown as string;
  }

}

export class MediaLiveUpdateChannelClassChannelEncoderSettingsNielsenConfiguration extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelClassRequest) {
    super(scope, id);
  }

  public get distributorId(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.NielsenConfiguration.DistributorId'),
        outputPath: 'Channel.EncoderSettings.NielsenConfiguration.DistributorId',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.NielsenConfiguration.DistributorId', props);
    return resource.getResponseField('Channel.EncoderSettings.NielsenConfiguration.DistributorId') as unknown as string;
  }

  public get nielsenPcmToId3Tagging(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.NielsenConfiguration.NielsenPcmToId3Tagging'),
        outputPath: 'Channel.EncoderSettings.NielsenConfiguration.NielsenPcmToId3Tagging',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.NielsenConfiguration.NielsenPcmToId3Tagging', props);
    return resource.getResponseField('Channel.EncoderSettings.NielsenConfiguration.NielsenPcmToId3Tagging') as unknown as string;
  }

}

export class MediaLiveUpdateChannelClassChannelEncoderSettingsTimecodeConfig extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelClassRequest) {
    super(scope, id);
  }

  public get source(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.TimecodeConfig.Source'),
        outputPath: 'Channel.EncoderSettings.TimecodeConfig.Source',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.TimecodeConfig.Source', props);
    return resource.getResponseField('Channel.EncoderSettings.TimecodeConfig.Source') as unknown as string;
  }

  public get syncThreshold(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.EncoderSettings.TimecodeConfig.SyncThreshold'),
        outputPath: 'Channel.EncoderSettings.TimecodeConfig.SyncThreshold',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.EncoderSettings.TimecodeConfig.SyncThreshold', props);
    return resource.getResponseField('Channel.EncoderSettings.TimecodeConfig.SyncThreshold') as unknown as number;
  }

}

export class MediaLiveUpdateChannelClassChannelInputSpecification extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateChannelClassRequest) {
    super(scope, id);
  }

  public get codec(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.InputSpecification.Codec'),
        outputPath: 'Channel.InputSpecification.Codec',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.InputSpecification.Codec', props);
    return resource.getResponseField('Channel.InputSpecification.Codec') as unknown as string;
  }

  public get maximumBitrate(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.InputSpecification.MaximumBitrate'),
        outputPath: 'Channel.InputSpecification.MaximumBitrate',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.InputSpecification.MaximumBitrate', props);
    return resource.getResponseField('Channel.InputSpecification.MaximumBitrate') as unknown as string;
  }

  public get resolution(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateChannelClass',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateChannelClass.Channel.InputSpecification.Resolution'),
        outputPath: 'Channel.InputSpecification.Resolution',
        parameters: {
          ChannelClass: this.input.channelClass,
          ChannelId: this.input.channelId,
          Destinations: this.input.destinations,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateChannelClass.Channel.InputSpecification.Resolution', props);
    return resource.getResponseField('Channel.InputSpecification.Resolution') as unknown as string;
  }

}

export class MediaLiveUpdateInput extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateInputRequest) {
    super(scope, id);
  }

  public get input(): MediaLiveUpdateInputInput {
    return new MediaLiveUpdateInputInput(this, 'Input', this.__resources, this.input);
  }

}

export class MediaLiveUpdateInputInput extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateInputRequest) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInput.Input.Arn'),
        outputPath: 'Input.Arn',
        parameters: {
          Destinations: this.input.destinations,
          InputDevices: this.input.inputDevices,
          InputId: this.input.inputId,
          InputSecurityGroups: this.input.inputSecurityGroups,
          MediaConnectFlows: this.input.mediaConnectFlows,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
          Sources: this.input.sources,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInput.Input.Arn', props);
    return resource.getResponseField('Input.Arn') as unknown as string;
  }

  public get attachedChannels(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInput.Input.AttachedChannels'),
        outputPath: 'Input.AttachedChannels',
        parameters: {
          Destinations: this.input.destinations,
          InputDevices: this.input.inputDevices,
          InputId: this.input.inputId,
          InputSecurityGroups: this.input.inputSecurityGroups,
          MediaConnectFlows: this.input.mediaConnectFlows,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
          Sources: this.input.sources,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInput.Input.AttachedChannels', props);
    return resource.getResponseField('Input.AttachedChannels') as unknown as string[];
  }

  public get destinations(): shapes.MediaLiveInputDestination[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInput.Input.Destinations'),
        outputPath: 'Input.Destinations',
        parameters: {
          Destinations: this.input.destinations,
          InputDevices: this.input.inputDevices,
          InputId: this.input.inputId,
          InputSecurityGroups: this.input.inputSecurityGroups,
          MediaConnectFlows: this.input.mediaConnectFlows,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
          Sources: this.input.sources,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInput.Input.Destinations', props);
    return resource.getResponseField('Input.Destinations') as unknown as shapes.MediaLiveInputDestination[];
  }

  public get id(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInput.Input.Id'),
        outputPath: 'Input.Id',
        parameters: {
          Destinations: this.input.destinations,
          InputDevices: this.input.inputDevices,
          InputId: this.input.inputId,
          InputSecurityGroups: this.input.inputSecurityGroups,
          MediaConnectFlows: this.input.mediaConnectFlows,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
          Sources: this.input.sources,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInput.Input.Id', props);
    return resource.getResponseField('Input.Id') as unknown as string;
  }

  public get inputClass(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInput.Input.InputClass'),
        outputPath: 'Input.InputClass',
        parameters: {
          Destinations: this.input.destinations,
          InputDevices: this.input.inputDevices,
          InputId: this.input.inputId,
          InputSecurityGroups: this.input.inputSecurityGroups,
          MediaConnectFlows: this.input.mediaConnectFlows,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
          Sources: this.input.sources,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInput.Input.InputClass', props);
    return resource.getResponseField('Input.InputClass') as unknown as string;
  }

  public get inputDevices(): shapes.MediaLiveInputDeviceSettings[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInput.Input.InputDevices'),
        outputPath: 'Input.InputDevices',
        parameters: {
          Destinations: this.input.destinations,
          InputDevices: this.input.inputDevices,
          InputId: this.input.inputId,
          InputSecurityGroups: this.input.inputSecurityGroups,
          MediaConnectFlows: this.input.mediaConnectFlows,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
          Sources: this.input.sources,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInput.Input.InputDevices', props);
    return resource.getResponseField('Input.InputDevices') as unknown as shapes.MediaLiveInputDeviceSettings[];
  }

  public get inputSourceType(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInput.Input.InputSourceType'),
        outputPath: 'Input.InputSourceType',
        parameters: {
          Destinations: this.input.destinations,
          InputDevices: this.input.inputDevices,
          InputId: this.input.inputId,
          InputSecurityGroups: this.input.inputSecurityGroups,
          MediaConnectFlows: this.input.mediaConnectFlows,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
          Sources: this.input.sources,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInput.Input.InputSourceType', props);
    return resource.getResponseField('Input.InputSourceType') as unknown as string;
  }

  public get mediaConnectFlows(): shapes.MediaLiveMediaConnectFlow[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInput.Input.MediaConnectFlows'),
        outputPath: 'Input.MediaConnectFlows',
        parameters: {
          Destinations: this.input.destinations,
          InputDevices: this.input.inputDevices,
          InputId: this.input.inputId,
          InputSecurityGroups: this.input.inputSecurityGroups,
          MediaConnectFlows: this.input.mediaConnectFlows,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
          Sources: this.input.sources,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInput.Input.MediaConnectFlows', props);
    return resource.getResponseField('Input.MediaConnectFlows') as unknown as shapes.MediaLiveMediaConnectFlow[];
  }

  public get name(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInput.Input.Name'),
        outputPath: 'Input.Name',
        parameters: {
          Destinations: this.input.destinations,
          InputDevices: this.input.inputDevices,
          InputId: this.input.inputId,
          InputSecurityGroups: this.input.inputSecurityGroups,
          MediaConnectFlows: this.input.mediaConnectFlows,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
          Sources: this.input.sources,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInput.Input.Name', props);
    return resource.getResponseField('Input.Name') as unknown as string;
  }

  public get roleArn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInput.Input.RoleArn'),
        outputPath: 'Input.RoleArn',
        parameters: {
          Destinations: this.input.destinations,
          InputDevices: this.input.inputDevices,
          InputId: this.input.inputId,
          InputSecurityGroups: this.input.inputSecurityGroups,
          MediaConnectFlows: this.input.mediaConnectFlows,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
          Sources: this.input.sources,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInput.Input.RoleArn', props);
    return resource.getResponseField('Input.RoleArn') as unknown as string;
  }

  public get securityGroups(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInput.Input.SecurityGroups'),
        outputPath: 'Input.SecurityGroups',
        parameters: {
          Destinations: this.input.destinations,
          InputDevices: this.input.inputDevices,
          InputId: this.input.inputId,
          InputSecurityGroups: this.input.inputSecurityGroups,
          MediaConnectFlows: this.input.mediaConnectFlows,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
          Sources: this.input.sources,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInput.Input.SecurityGroups', props);
    return resource.getResponseField('Input.SecurityGroups') as unknown as string[];
  }

  public get sources(): shapes.MediaLiveInputSource[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInput.Input.Sources'),
        outputPath: 'Input.Sources',
        parameters: {
          Destinations: this.input.destinations,
          InputDevices: this.input.inputDevices,
          InputId: this.input.inputId,
          InputSecurityGroups: this.input.inputSecurityGroups,
          MediaConnectFlows: this.input.mediaConnectFlows,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
          Sources: this.input.sources,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInput.Input.Sources', props);
    return resource.getResponseField('Input.Sources') as unknown as shapes.MediaLiveInputSource[];
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInput.Input.State'),
        outputPath: 'Input.State',
        parameters: {
          Destinations: this.input.destinations,
          InputDevices: this.input.inputDevices,
          InputId: this.input.inputId,
          InputSecurityGroups: this.input.inputSecurityGroups,
          MediaConnectFlows: this.input.mediaConnectFlows,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
          Sources: this.input.sources,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInput.Input.State', props);
    return resource.getResponseField('Input.State') as unknown as string;
  }

  public get tags(): Record<string, string> {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInput.Input.Tags'),
        outputPath: 'Input.Tags',
        parameters: {
          Destinations: this.input.destinations,
          InputDevices: this.input.inputDevices,
          InputId: this.input.inputId,
          InputSecurityGroups: this.input.inputSecurityGroups,
          MediaConnectFlows: this.input.mediaConnectFlows,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
          Sources: this.input.sources,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInput.Input.Tags', props);
    return resource.getResponseField('Input.Tags') as unknown as Record<string, string>;
  }

  public get type(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInput',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInput.Input.Type'),
        outputPath: 'Input.Type',
        parameters: {
          Destinations: this.input.destinations,
          InputDevices: this.input.inputDevices,
          InputId: this.input.inputId,
          InputSecurityGroups: this.input.inputSecurityGroups,
          MediaConnectFlows: this.input.mediaConnectFlows,
          Name: this.input.name,
          RoleArn: this.input.roleArn,
          Sources: this.input.sources,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInput.Input.Type', props);
    return resource.getResponseField('Input.Type') as unknown as string;
  }

}

export class MediaLiveUpdateInputDevice extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateInputDeviceRequest) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInputDevice.Arn'),
        outputPath: 'Arn',
        parameters: {
          HdDeviceSettings: {
            ConfiguredInput: this.input.hdDeviceSettings?.configuredInput,
            MaxBitrate: this.input.hdDeviceSettings?.maxBitrate,
          },
          InputDeviceId: this.input.inputDeviceId,
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInputDevice.Arn', props);
    return resource.getResponseField('Arn') as unknown as string;
  }

  public get connectionState(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInputDevice.ConnectionState'),
        outputPath: 'ConnectionState',
        parameters: {
          HdDeviceSettings: {
            ConfiguredInput: this.input.hdDeviceSettings?.configuredInput,
            MaxBitrate: this.input.hdDeviceSettings?.maxBitrate,
          },
          InputDeviceId: this.input.inputDeviceId,
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInputDevice.ConnectionState', props);
    return resource.getResponseField('ConnectionState') as unknown as string;
  }

  public get deviceSettingsSyncState(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInputDevice.DeviceSettingsSyncState'),
        outputPath: 'DeviceSettingsSyncState',
        parameters: {
          HdDeviceSettings: {
            ConfiguredInput: this.input.hdDeviceSettings?.configuredInput,
            MaxBitrate: this.input.hdDeviceSettings?.maxBitrate,
          },
          InputDeviceId: this.input.inputDeviceId,
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInputDevice.DeviceSettingsSyncState', props);
    return resource.getResponseField('DeviceSettingsSyncState') as unknown as string;
  }

  public get deviceUpdateStatus(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInputDevice.DeviceUpdateStatus'),
        outputPath: 'DeviceUpdateStatus',
        parameters: {
          HdDeviceSettings: {
            ConfiguredInput: this.input.hdDeviceSettings?.configuredInput,
            MaxBitrate: this.input.hdDeviceSettings?.maxBitrate,
          },
          InputDeviceId: this.input.inputDeviceId,
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInputDevice.DeviceUpdateStatus', props);
    return resource.getResponseField('DeviceUpdateStatus') as unknown as string;
  }

  public get hdDeviceSettings(): MediaLiveUpdateInputDeviceHdDeviceSettings {
    return new MediaLiveUpdateInputDeviceHdDeviceSettings(this, 'HdDeviceSettings', this.__resources, this.input);
  }

  public get id(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInputDevice.Id'),
        outputPath: 'Id',
        parameters: {
          HdDeviceSettings: {
            ConfiguredInput: this.input.hdDeviceSettings?.configuredInput,
            MaxBitrate: this.input.hdDeviceSettings?.maxBitrate,
          },
          InputDeviceId: this.input.inputDeviceId,
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInputDevice.Id', props);
    return resource.getResponseField('Id') as unknown as string;
  }

  public get macAddress(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInputDevice.MacAddress'),
        outputPath: 'MacAddress',
        parameters: {
          HdDeviceSettings: {
            ConfiguredInput: this.input.hdDeviceSettings?.configuredInput,
            MaxBitrate: this.input.hdDeviceSettings?.maxBitrate,
          },
          InputDeviceId: this.input.inputDeviceId,
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInputDevice.MacAddress', props);
    return resource.getResponseField('MacAddress') as unknown as string;
  }

  public get name(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInputDevice.Name'),
        outputPath: 'Name',
        parameters: {
          HdDeviceSettings: {
            ConfiguredInput: this.input.hdDeviceSettings?.configuredInput,
            MaxBitrate: this.input.hdDeviceSettings?.maxBitrate,
          },
          InputDeviceId: this.input.inputDeviceId,
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInputDevice.Name', props);
    return resource.getResponseField('Name') as unknown as string;
  }

  public get networkSettings(): MediaLiveUpdateInputDeviceNetworkSettings {
    return new MediaLiveUpdateInputDeviceNetworkSettings(this, 'NetworkSettings', this.__resources, this.input);
  }

  public get serialNumber(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInputDevice.SerialNumber'),
        outputPath: 'SerialNumber',
        parameters: {
          HdDeviceSettings: {
            ConfiguredInput: this.input.hdDeviceSettings?.configuredInput,
            MaxBitrate: this.input.hdDeviceSettings?.maxBitrate,
          },
          InputDeviceId: this.input.inputDeviceId,
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInputDevice.SerialNumber', props);
    return resource.getResponseField('SerialNumber') as unknown as string;
  }

  public get type(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInputDevice.Type'),
        outputPath: 'Type',
        parameters: {
          HdDeviceSettings: {
            ConfiguredInput: this.input.hdDeviceSettings?.configuredInput,
            MaxBitrate: this.input.hdDeviceSettings?.maxBitrate,
          },
          InputDeviceId: this.input.inputDeviceId,
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInputDevice.Type', props);
    return resource.getResponseField('Type') as unknown as string;
  }

}

export class MediaLiveUpdateInputDeviceHdDeviceSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateInputDeviceRequest) {
    super(scope, id);
  }

  public get activeInput(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInputDevice.HdDeviceSettings.ActiveInput'),
        outputPath: 'HdDeviceSettings.ActiveInput',
        parameters: {
          HdDeviceSettings: {
            ConfiguredInput: this.input.hdDeviceSettings?.configuredInput,
            MaxBitrate: this.input.hdDeviceSettings?.maxBitrate,
          },
          InputDeviceId: this.input.inputDeviceId,
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInputDevice.HdDeviceSettings.ActiveInput', props);
    return resource.getResponseField('HdDeviceSettings.ActiveInput') as unknown as string;
  }

  public get configuredInput(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInputDevice.HdDeviceSettings.ConfiguredInput'),
        outputPath: 'HdDeviceSettings.ConfiguredInput',
        parameters: {
          HdDeviceSettings: {
            ConfiguredInput: this.input.hdDeviceSettings?.configuredInput,
            MaxBitrate: this.input.hdDeviceSettings?.maxBitrate,
          },
          InputDeviceId: this.input.inputDeviceId,
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInputDevice.HdDeviceSettings.ConfiguredInput', props);
    return resource.getResponseField('HdDeviceSettings.ConfiguredInput') as unknown as string;
  }

  public get deviceState(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInputDevice.HdDeviceSettings.DeviceState'),
        outputPath: 'HdDeviceSettings.DeviceState',
        parameters: {
          HdDeviceSettings: {
            ConfiguredInput: this.input.hdDeviceSettings?.configuredInput,
            MaxBitrate: this.input.hdDeviceSettings?.maxBitrate,
          },
          InputDeviceId: this.input.inputDeviceId,
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInputDevice.HdDeviceSettings.DeviceState', props);
    return resource.getResponseField('HdDeviceSettings.DeviceState') as unknown as string;
  }

  public get framerate(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInputDevice.HdDeviceSettings.Framerate'),
        outputPath: 'HdDeviceSettings.Framerate',
        parameters: {
          HdDeviceSettings: {
            ConfiguredInput: this.input.hdDeviceSettings?.configuredInput,
            MaxBitrate: this.input.hdDeviceSettings?.maxBitrate,
          },
          InputDeviceId: this.input.inputDeviceId,
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInputDevice.HdDeviceSettings.Framerate', props);
    return resource.getResponseField('HdDeviceSettings.Framerate') as unknown as number;
  }

  public get height(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInputDevice.HdDeviceSettings.Height'),
        outputPath: 'HdDeviceSettings.Height',
        parameters: {
          HdDeviceSettings: {
            ConfiguredInput: this.input.hdDeviceSettings?.configuredInput,
            MaxBitrate: this.input.hdDeviceSettings?.maxBitrate,
          },
          InputDeviceId: this.input.inputDeviceId,
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInputDevice.HdDeviceSettings.Height', props);
    return resource.getResponseField('HdDeviceSettings.Height') as unknown as number;
  }

  public get maxBitrate(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInputDevice.HdDeviceSettings.MaxBitrate'),
        outputPath: 'HdDeviceSettings.MaxBitrate',
        parameters: {
          HdDeviceSettings: {
            ConfiguredInput: this.input.hdDeviceSettings?.configuredInput,
            MaxBitrate: this.input.hdDeviceSettings?.maxBitrate,
          },
          InputDeviceId: this.input.inputDeviceId,
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInputDevice.HdDeviceSettings.MaxBitrate', props);
    return resource.getResponseField('HdDeviceSettings.MaxBitrate') as unknown as number;
  }

  public get scanType(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInputDevice.HdDeviceSettings.ScanType'),
        outputPath: 'HdDeviceSettings.ScanType',
        parameters: {
          HdDeviceSettings: {
            ConfiguredInput: this.input.hdDeviceSettings?.configuredInput,
            MaxBitrate: this.input.hdDeviceSettings?.maxBitrate,
          },
          InputDeviceId: this.input.inputDeviceId,
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInputDevice.HdDeviceSettings.ScanType', props);
    return resource.getResponseField('HdDeviceSettings.ScanType') as unknown as string;
  }

  public get width(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInputDevice.HdDeviceSettings.Width'),
        outputPath: 'HdDeviceSettings.Width',
        parameters: {
          HdDeviceSettings: {
            ConfiguredInput: this.input.hdDeviceSettings?.configuredInput,
            MaxBitrate: this.input.hdDeviceSettings?.maxBitrate,
          },
          InputDeviceId: this.input.inputDeviceId,
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInputDevice.HdDeviceSettings.Width', props);
    return resource.getResponseField('HdDeviceSettings.Width') as unknown as number;
  }

}

export class MediaLiveUpdateInputDeviceNetworkSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateInputDeviceRequest) {
    super(scope, id);
  }

  public get dnsAddresses(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInputDevice.NetworkSettings.DnsAddresses'),
        outputPath: 'NetworkSettings.DnsAddresses',
        parameters: {
          HdDeviceSettings: {
            ConfiguredInput: this.input.hdDeviceSettings?.configuredInput,
            MaxBitrate: this.input.hdDeviceSettings?.maxBitrate,
          },
          InputDeviceId: this.input.inputDeviceId,
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInputDevice.NetworkSettings.DnsAddresses', props);
    return resource.getResponseField('NetworkSettings.DnsAddresses') as unknown as string[];
  }

  public get gateway(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInputDevice.NetworkSettings.Gateway'),
        outputPath: 'NetworkSettings.Gateway',
        parameters: {
          HdDeviceSettings: {
            ConfiguredInput: this.input.hdDeviceSettings?.configuredInput,
            MaxBitrate: this.input.hdDeviceSettings?.maxBitrate,
          },
          InputDeviceId: this.input.inputDeviceId,
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInputDevice.NetworkSettings.Gateway', props);
    return resource.getResponseField('NetworkSettings.Gateway') as unknown as string;
  }

  public get ipAddress(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInputDevice.NetworkSettings.IpAddress'),
        outputPath: 'NetworkSettings.IpAddress',
        parameters: {
          HdDeviceSettings: {
            ConfiguredInput: this.input.hdDeviceSettings?.configuredInput,
            MaxBitrate: this.input.hdDeviceSettings?.maxBitrate,
          },
          InputDeviceId: this.input.inputDeviceId,
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInputDevice.NetworkSettings.IpAddress', props);
    return resource.getResponseField('NetworkSettings.IpAddress') as unknown as string;
  }

  public get ipScheme(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInputDevice.NetworkSettings.IpScheme'),
        outputPath: 'NetworkSettings.IpScheme',
        parameters: {
          HdDeviceSettings: {
            ConfiguredInput: this.input.hdDeviceSettings?.configuredInput,
            MaxBitrate: this.input.hdDeviceSettings?.maxBitrate,
          },
          InputDeviceId: this.input.inputDeviceId,
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInputDevice.NetworkSettings.IpScheme', props);
    return resource.getResponseField('NetworkSettings.IpScheme') as unknown as string;
  }

  public get subnetMask(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInputDevice',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInputDevice.NetworkSettings.SubnetMask'),
        outputPath: 'NetworkSettings.SubnetMask',
        parameters: {
          HdDeviceSettings: {
            ConfiguredInput: this.input.hdDeviceSettings?.configuredInput,
            MaxBitrate: this.input.hdDeviceSettings?.maxBitrate,
          },
          InputDeviceId: this.input.inputDeviceId,
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInputDevice.NetworkSettings.SubnetMask', props);
    return resource.getResponseField('NetworkSettings.SubnetMask') as unknown as string;
  }

}

export class MediaLiveUpdateInputSecurityGroup extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateInputSecurityGroupRequest) {
    super(scope, id);
  }

  public get securityGroup(): MediaLiveUpdateInputSecurityGroupSecurityGroup {
    return new MediaLiveUpdateInputSecurityGroupSecurityGroup(this, 'SecurityGroup', this.__resources, this.input);
  }

}

export class MediaLiveUpdateInputSecurityGroupSecurityGroup extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateInputSecurityGroupRequest) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInputSecurityGroup',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInputSecurityGroup.SecurityGroup.Arn'),
        outputPath: 'SecurityGroup.Arn',
        parameters: {
          InputSecurityGroupId: this.input.inputSecurityGroupId,
          Tags: this.input.tags,
          WhitelistRules: this.input.whitelistRules,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInputSecurityGroup.SecurityGroup.Arn', props);
    return resource.getResponseField('SecurityGroup.Arn') as unknown as string;
  }

  public get id(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInputSecurityGroup',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInputSecurityGroup.SecurityGroup.Id'),
        outputPath: 'SecurityGroup.Id',
        parameters: {
          InputSecurityGroupId: this.input.inputSecurityGroupId,
          Tags: this.input.tags,
          WhitelistRules: this.input.whitelistRules,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInputSecurityGroup.SecurityGroup.Id', props);
    return resource.getResponseField('SecurityGroup.Id') as unknown as string;
  }

  public get inputs(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInputSecurityGroup',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInputSecurityGroup.SecurityGroup.Inputs'),
        outputPath: 'SecurityGroup.Inputs',
        parameters: {
          InputSecurityGroupId: this.input.inputSecurityGroupId,
          Tags: this.input.tags,
          WhitelistRules: this.input.whitelistRules,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInputSecurityGroup.SecurityGroup.Inputs', props);
    return resource.getResponseField('SecurityGroup.Inputs') as unknown as string[];
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInputSecurityGroup',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInputSecurityGroup.SecurityGroup.State'),
        outputPath: 'SecurityGroup.State',
        parameters: {
          InputSecurityGroupId: this.input.inputSecurityGroupId,
          Tags: this.input.tags,
          WhitelistRules: this.input.whitelistRules,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInputSecurityGroup.SecurityGroup.State', props);
    return resource.getResponseField('SecurityGroup.State') as unknown as string;
  }

  public get tags(): Record<string, string> {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInputSecurityGroup',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInputSecurityGroup.SecurityGroup.Tags'),
        outputPath: 'SecurityGroup.Tags',
        parameters: {
          InputSecurityGroupId: this.input.inputSecurityGroupId,
          Tags: this.input.tags,
          WhitelistRules: this.input.whitelistRules,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInputSecurityGroup.SecurityGroup.Tags', props);
    return resource.getResponseField('SecurityGroup.Tags') as unknown as Record<string, string>;
  }

  public get whitelistRules(): shapes.MediaLiveInputWhitelistRule[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateInputSecurityGroup',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateInputSecurityGroup.SecurityGroup.WhitelistRules'),
        outputPath: 'SecurityGroup.WhitelistRules',
        parameters: {
          InputSecurityGroupId: this.input.inputSecurityGroupId,
          Tags: this.input.tags,
          WhitelistRules: this.input.whitelistRules,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateInputSecurityGroup.SecurityGroup.WhitelistRules', props);
    return resource.getResponseField('SecurityGroup.WhitelistRules') as unknown as shapes.MediaLiveInputWhitelistRule[];
  }

}

export class MediaLiveUpdateMultiplex extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateMultiplexRequest) {
    super(scope, id);
  }

  public get multiplex(): MediaLiveUpdateMultiplexMultiplex {
    return new MediaLiveUpdateMultiplexMultiplex(this, 'Multiplex', this.__resources, this.input);
  }

}

export class MediaLiveUpdateMultiplexMultiplex extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateMultiplexRequest) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplex.Multiplex.Arn'),
        outputPath: 'Multiplex.Arn',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexSettings: {
            MaximumVideoBufferDelayMilliseconds: this.input.multiplexSettings?.maximumVideoBufferDelayMilliseconds,
            TransportStreamBitrate: this.input.multiplexSettings?.transportStreamBitrate,
            TransportStreamId: this.input.multiplexSettings?.transportStreamId,
            TransportStreamReservedBitrate: this.input.multiplexSettings?.transportStreamReservedBitrate,
          },
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplex.Multiplex.Arn', props);
    return resource.getResponseField('Multiplex.Arn') as unknown as string;
  }

  public get availabilityZones(): string[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplex.Multiplex.AvailabilityZones'),
        outputPath: 'Multiplex.AvailabilityZones',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexSettings: {
            MaximumVideoBufferDelayMilliseconds: this.input.multiplexSettings?.maximumVideoBufferDelayMilliseconds,
            TransportStreamBitrate: this.input.multiplexSettings?.transportStreamBitrate,
            TransportStreamId: this.input.multiplexSettings?.transportStreamId,
            TransportStreamReservedBitrate: this.input.multiplexSettings?.transportStreamReservedBitrate,
          },
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplex.Multiplex.AvailabilityZones', props);
    return resource.getResponseField('Multiplex.AvailabilityZones') as unknown as string[];
  }

  public get destinations(): shapes.MediaLiveMultiplexOutputDestination[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplex.Multiplex.Destinations'),
        outputPath: 'Multiplex.Destinations',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexSettings: {
            MaximumVideoBufferDelayMilliseconds: this.input.multiplexSettings?.maximumVideoBufferDelayMilliseconds,
            TransportStreamBitrate: this.input.multiplexSettings?.transportStreamBitrate,
            TransportStreamId: this.input.multiplexSettings?.transportStreamId,
            TransportStreamReservedBitrate: this.input.multiplexSettings?.transportStreamReservedBitrate,
          },
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplex.Multiplex.Destinations', props);
    return resource.getResponseField('Multiplex.Destinations') as unknown as shapes.MediaLiveMultiplexOutputDestination[];
  }

  public get id(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplex.Multiplex.Id'),
        outputPath: 'Multiplex.Id',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexSettings: {
            MaximumVideoBufferDelayMilliseconds: this.input.multiplexSettings?.maximumVideoBufferDelayMilliseconds,
            TransportStreamBitrate: this.input.multiplexSettings?.transportStreamBitrate,
            TransportStreamId: this.input.multiplexSettings?.transportStreamId,
            TransportStreamReservedBitrate: this.input.multiplexSettings?.transportStreamReservedBitrate,
          },
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplex.Multiplex.Id', props);
    return resource.getResponseField('Multiplex.Id') as unknown as string;
  }

  public get multiplexSettings(): MediaLiveUpdateMultiplexMultiplexMultiplexSettings {
    return new MediaLiveUpdateMultiplexMultiplexMultiplexSettings(this, 'MultiplexSettings', this.__resources, this.input);
  }

  public get name(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplex.Multiplex.Name'),
        outputPath: 'Multiplex.Name',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexSettings: {
            MaximumVideoBufferDelayMilliseconds: this.input.multiplexSettings?.maximumVideoBufferDelayMilliseconds,
            TransportStreamBitrate: this.input.multiplexSettings?.transportStreamBitrate,
            TransportStreamId: this.input.multiplexSettings?.transportStreamId,
            TransportStreamReservedBitrate: this.input.multiplexSettings?.transportStreamReservedBitrate,
          },
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplex.Multiplex.Name', props);
    return resource.getResponseField('Multiplex.Name') as unknown as string;
  }

  public get pipelinesRunningCount(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplex.Multiplex.PipelinesRunningCount'),
        outputPath: 'Multiplex.PipelinesRunningCount',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexSettings: {
            MaximumVideoBufferDelayMilliseconds: this.input.multiplexSettings?.maximumVideoBufferDelayMilliseconds,
            TransportStreamBitrate: this.input.multiplexSettings?.transportStreamBitrate,
            TransportStreamId: this.input.multiplexSettings?.transportStreamId,
            TransportStreamReservedBitrate: this.input.multiplexSettings?.transportStreamReservedBitrate,
          },
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplex.Multiplex.PipelinesRunningCount', props);
    return resource.getResponseField('Multiplex.PipelinesRunningCount') as unknown as number;
  }

  public get programCount(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplex.Multiplex.ProgramCount'),
        outputPath: 'Multiplex.ProgramCount',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexSettings: {
            MaximumVideoBufferDelayMilliseconds: this.input.multiplexSettings?.maximumVideoBufferDelayMilliseconds,
            TransportStreamBitrate: this.input.multiplexSettings?.transportStreamBitrate,
            TransportStreamId: this.input.multiplexSettings?.transportStreamId,
            TransportStreamReservedBitrate: this.input.multiplexSettings?.transportStreamReservedBitrate,
          },
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplex.Multiplex.ProgramCount', props);
    return resource.getResponseField('Multiplex.ProgramCount') as unknown as number;
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplex.Multiplex.State'),
        outputPath: 'Multiplex.State',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexSettings: {
            MaximumVideoBufferDelayMilliseconds: this.input.multiplexSettings?.maximumVideoBufferDelayMilliseconds,
            TransportStreamBitrate: this.input.multiplexSettings?.transportStreamBitrate,
            TransportStreamId: this.input.multiplexSettings?.transportStreamId,
            TransportStreamReservedBitrate: this.input.multiplexSettings?.transportStreamReservedBitrate,
          },
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplex.Multiplex.State', props);
    return resource.getResponseField('Multiplex.State') as unknown as string;
  }

  public get tags(): Record<string, string> {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplex.Multiplex.Tags'),
        outputPath: 'Multiplex.Tags',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexSettings: {
            MaximumVideoBufferDelayMilliseconds: this.input.multiplexSettings?.maximumVideoBufferDelayMilliseconds,
            TransportStreamBitrate: this.input.multiplexSettings?.transportStreamBitrate,
            TransportStreamId: this.input.multiplexSettings?.transportStreamId,
            TransportStreamReservedBitrate: this.input.multiplexSettings?.transportStreamReservedBitrate,
          },
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplex.Multiplex.Tags', props);
    return resource.getResponseField('Multiplex.Tags') as unknown as Record<string, string>;
  }

}

export class MediaLiveUpdateMultiplexMultiplexMultiplexSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateMultiplexRequest) {
    super(scope, id);
  }

  public get maximumVideoBufferDelayMilliseconds(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplex.Multiplex.MultiplexSettings.MaximumVideoBufferDelayMilliseconds'),
        outputPath: 'Multiplex.MultiplexSettings.MaximumVideoBufferDelayMilliseconds',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexSettings: {
            MaximumVideoBufferDelayMilliseconds: this.input.multiplexSettings?.maximumVideoBufferDelayMilliseconds,
            TransportStreamBitrate: this.input.multiplexSettings?.transportStreamBitrate,
            TransportStreamId: this.input.multiplexSettings?.transportStreamId,
            TransportStreamReservedBitrate: this.input.multiplexSettings?.transportStreamReservedBitrate,
          },
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplex.Multiplex.MultiplexSettings.MaximumVideoBufferDelayMilliseconds', props);
    return resource.getResponseField('Multiplex.MultiplexSettings.MaximumVideoBufferDelayMilliseconds') as unknown as number;
  }

  public get transportStreamBitrate(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplex.Multiplex.MultiplexSettings.TransportStreamBitrate'),
        outputPath: 'Multiplex.MultiplexSettings.TransportStreamBitrate',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexSettings: {
            MaximumVideoBufferDelayMilliseconds: this.input.multiplexSettings?.maximumVideoBufferDelayMilliseconds,
            TransportStreamBitrate: this.input.multiplexSettings?.transportStreamBitrate,
            TransportStreamId: this.input.multiplexSettings?.transportStreamId,
            TransportStreamReservedBitrate: this.input.multiplexSettings?.transportStreamReservedBitrate,
          },
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplex.Multiplex.MultiplexSettings.TransportStreamBitrate', props);
    return resource.getResponseField('Multiplex.MultiplexSettings.TransportStreamBitrate') as unknown as number;
  }

  public get transportStreamId(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplex.Multiplex.MultiplexSettings.TransportStreamId'),
        outputPath: 'Multiplex.MultiplexSettings.TransportStreamId',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexSettings: {
            MaximumVideoBufferDelayMilliseconds: this.input.multiplexSettings?.maximumVideoBufferDelayMilliseconds,
            TransportStreamBitrate: this.input.multiplexSettings?.transportStreamBitrate,
            TransportStreamId: this.input.multiplexSettings?.transportStreamId,
            TransportStreamReservedBitrate: this.input.multiplexSettings?.transportStreamReservedBitrate,
          },
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplex.Multiplex.MultiplexSettings.TransportStreamId', props);
    return resource.getResponseField('Multiplex.MultiplexSettings.TransportStreamId') as unknown as number;
  }

  public get transportStreamReservedBitrate(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplex',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplex.Multiplex.MultiplexSettings.TransportStreamReservedBitrate'),
        outputPath: 'Multiplex.MultiplexSettings.TransportStreamReservedBitrate',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexSettings: {
            MaximumVideoBufferDelayMilliseconds: this.input.multiplexSettings?.maximumVideoBufferDelayMilliseconds,
            TransportStreamBitrate: this.input.multiplexSettings?.transportStreamBitrate,
            TransportStreamId: this.input.multiplexSettings?.transportStreamId,
            TransportStreamReservedBitrate: this.input.multiplexSettings?.transportStreamReservedBitrate,
          },
          Name: this.input.name,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplex.Multiplex.MultiplexSettings.TransportStreamReservedBitrate', props);
    return resource.getResponseField('Multiplex.MultiplexSettings.TransportStreamReservedBitrate') as unknown as number;
  }

}

export class MediaLiveUpdateMultiplexProgram extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateMultiplexProgramRequest) {
    super(scope, id);
  }

  public get multiplexProgram(): MediaLiveUpdateMultiplexProgramMultiplexProgram {
    return new MediaLiveUpdateMultiplexProgramMultiplexProgram(this, 'MultiplexProgram', this.__resources, this.input);
  }

}

export class MediaLiveUpdateMultiplexProgramMultiplexProgram extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateMultiplexProgramRequest) {
    super(scope, id);
  }

  public get channelId(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplexProgram.MultiplexProgram.ChannelId'),
        outputPath: 'MultiplexProgram.ChannelId',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings?.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings?.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings?.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings?.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings?.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplexProgram.MultiplexProgram.ChannelId', props);
    return resource.getResponseField('MultiplexProgram.ChannelId') as unknown as string;
  }

  public get multiplexProgramSettings(): MediaLiveUpdateMultiplexProgramMultiplexProgramMultiplexProgramSettings {
    return new MediaLiveUpdateMultiplexProgramMultiplexProgramMultiplexProgramSettings(this, 'MultiplexProgramSettings', this.__resources, this.input);
  }

  public get packetIdentifiersMap(): MediaLiveUpdateMultiplexProgramMultiplexProgramPacketIdentifiersMap {
    return new MediaLiveUpdateMultiplexProgramMultiplexProgramPacketIdentifiersMap(this, 'PacketIdentifiersMap', this.__resources, this.input);
  }

  public get pipelineDetails(): shapes.MediaLiveMultiplexProgramPipelineDetail[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplexProgram.MultiplexProgram.PipelineDetails'),
        outputPath: 'MultiplexProgram.PipelineDetails',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings?.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings?.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings?.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings?.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings?.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplexProgram.MultiplexProgram.PipelineDetails', props);
    return resource.getResponseField('MultiplexProgram.PipelineDetails') as unknown as shapes.MediaLiveMultiplexProgramPipelineDetail[];
  }

  public get programName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplexProgram.MultiplexProgram.ProgramName'),
        outputPath: 'MultiplexProgram.ProgramName',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings?.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings?.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings?.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings?.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings?.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplexProgram.MultiplexProgram.ProgramName', props);
    return resource.getResponseField('MultiplexProgram.ProgramName') as unknown as string;
  }

}

export class MediaLiveUpdateMultiplexProgramMultiplexProgramMultiplexProgramSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateMultiplexProgramRequest) {
    super(scope, id);
  }

  public get preferredChannelPipeline(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.PreferredChannelPipeline'),
        outputPath: 'MultiplexProgram.MultiplexProgramSettings.PreferredChannelPipeline',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings?.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings?.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings?.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings?.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings?.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.PreferredChannelPipeline', props);
    return resource.getResponseField('MultiplexProgram.MultiplexProgramSettings.PreferredChannelPipeline') as unknown as string;
  }

  public get programNumber(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.ProgramNumber'),
        outputPath: 'MultiplexProgram.MultiplexProgramSettings.ProgramNumber',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings?.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings?.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings?.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings?.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings?.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.ProgramNumber', props);
    return resource.getResponseField('MultiplexProgram.MultiplexProgramSettings.ProgramNumber') as unknown as number;
  }

  public get serviceDescriptor(): MediaLiveUpdateMultiplexProgramMultiplexProgramMultiplexProgramSettingsServiceDescriptor {
    return new MediaLiveUpdateMultiplexProgramMultiplexProgramMultiplexProgramSettingsServiceDescriptor(this, 'ServiceDescriptor', this.__resources, this.input);
  }

  public get videoSettings(): MediaLiveUpdateMultiplexProgramMultiplexProgramMultiplexProgramSettingsVideoSettings {
    return new MediaLiveUpdateMultiplexProgramMultiplexProgramMultiplexProgramSettingsVideoSettings(this, 'VideoSettings', this.__resources, this.input);
  }

}

export class MediaLiveUpdateMultiplexProgramMultiplexProgramMultiplexProgramSettingsServiceDescriptor extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateMultiplexProgramRequest) {
    super(scope, id);
  }

  public get providerName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.ServiceDescriptor.ProviderName'),
        outputPath: 'MultiplexProgram.MultiplexProgramSettings.ServiceDescriptor.ProviderName',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings?.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings?.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings?.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings?.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings?.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.ServiceDescriptor.ProviderName', props);
    return resource.getResponseField('MultiplexProgram.MultiplexProgramSettings.ServiceDescriptor.ProviderName') as unknown as string;
  }

  public get serviceName(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.ServiceDescriptor.ServiceName'),
        outputPath: 'MultiplexProgram.MultiplexProgramSettings.ServiceDescriptor.ServiceName',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings?.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings?.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings?.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings?.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings?.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.ServiceDescriptor.ServiceName', props);
    return resource.getResponseField('MultiplexProgram.MultiplexProgramSettings.ServiceDescriptor.ServiceName') as unknown as string;
  }

}

export class MediaLiveUpdateMultiplexProgramMultiplexProgramMultiplexProgramSettingsVideoSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateMultiplexProgramRequest) {
    super(scope, id);
  }

  public get constantBitrate(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.VideoSettings.ConstantBitrate'),
        outputPath: 'MultiplexProgram.MultiplexProgramSettings.VideoSettings.ConstantBitrate',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings?.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings?.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings?.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings?.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings?.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.VideoSettings.ConstantBitrate', props);
    return resource.getResponseField('MultiplexProgram.MultiplexProgramSettings.VideoSettings.ConstantBitrate') as unknown as number;
  }

  public get statmuxSettings(): MediaLiveUpdateMultiplexProgramMultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettings {
    return new MediaLiveUpdateMultiplexProgramMultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettings(this, 'StatmuxSettings', this.__resources, this.input);
  }

}

export class MediaLiveUpdateMultiplexProgramMultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettings extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateMultiplexProgramRequest) {
    super(scope, id);
  }

  public get maximumBitrate(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.MaximumBitrate'),
        outputPath: 'MultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.MaximumBitrate',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings?.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings?.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings?.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings?.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings?.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.MaximumBitrate', props);
    return resource.getResponseField('MultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.MaximumBitrate') as unknown as number;
  }

  public get minimumBitrate(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.MinimumBitrate'),
        outputPath: 'MultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.MinimumBitrate',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings?.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings?.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings?.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings?.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings?.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.MinimumBitrate', props);
    return resource.getResponseField('MultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.MinimumBitrate') as unknown as number;
  }

  public get priority(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.Priority'),
        outputPath: 'MultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.Priority',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings?.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings?.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings?.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings?.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings?.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplexProgram.MultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.Priority', props);
    return resource.getResponseField('MultiplexProgram.MultiplexProgramSettings.VideoSettings.StatmuxSettings.Priority') as unknown as number;
  }

}

export class MediaLiveUpdateMultiplexProgramMultiplexProgramPacketIdentifiersMap extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateMultiplexProgramRequest) {
    super(scope, id);
  }

  public get audioPids(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.AudioPids'),
        outputPath: 'MultiplexProgram.PacketIdentifiersMap.AudioPids',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings?.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings?.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings?.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings?.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings?.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.AudioPids', props);
    return resource.getResponseField('MultiplexProgram.PacketIdentifiersMap.AudioPids') as unknown as number[];
  }

  public get dvbSubPids(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.DvbSubPids'),
        outputPath: 'MultiplexProgram.PacketIdentifiersMap.DvbSubPids',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings?.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings?.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings?.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings?.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings?.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.DvbSubPids', props);
    return resource.getResponseField('MultiplexProgram.PacketIdentifiersMap.DvbSubPids') as unknown as number[];
  }

  public get dvbTeletextPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.DvbTeletextPid'),
        outputPath: 'MultiplexProgram.PacketIdentifiersMap.DvbTeletextPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings?.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings?.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings?.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings?.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings?.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.DvbTeletextPid', props);
    return resource.getResponseField('MultiplexProgram.PacketIdentifiersMap.DvbTeletextPid') as unknown as number;
  }

  public get etvPlatformPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.EtvPlatformPid'),
        outputPath: 'MultiplexProgram.PacketIdentifiersMap.EtvPlatformPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings?.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings?.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings?.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings?.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings?.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.EtvPlatformPid', props);
    return resource.getResponseField('MultiplexProgram.PacketIdentifiersMap.EtvPlatformPid') as unknown as number;
  }

  public get etvSignalPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.EtvSignalPid'),
        outputPath: 'MultiplexProgram.PacketIdentifiersMap.EtvSignalPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings?.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings?.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings?.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings?.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings?.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.EtvSignalPid', props);
    return resource.getResponseField('MultiplexProgram.PacketIdentifiersMap.EtvSignalPid') as unknown as number;
  }

  public get klvDataPids(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.KlvDataPids'),
        outputPath: 'MultiplexProgram.PacketIdentifiersMap.KlvDataPids',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings?.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings?.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings?.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings?.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings?.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.KlvDataPids', props);
    return resource.getResponseField('MultiplexProgram.PacketIdentifiersMap.KlvDataPids') as unknown as number[];
  }

  public get pcrPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.PcrPid'),
        outputPath: 'MultiplexProgram.PacketIdentifiersMap.PcrPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings?.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings?.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings?.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings?.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings?.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.PcrPid', props);
    return resource.getResponseField('MultiplexProgram.PacketIdentifiersMap.PcrPid') as unknown as number;
  }

  public get pmtPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.PmtPid'),
        outputPath: 'MultiplexProgram.PacketIdentifiersMap.PmtPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings?.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings?.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings?.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings?.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings?.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.PmtPid', props);
    return resource.getResponseField('MultiplexProgram.PacketIdentifiersMap.PmtPid') as unknown as number;
  }

  public get privateMetadataPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.PrivateMetadataPid'),
        outputPath: 'MultiplexProgram.PacketIdentifiersMap.PrivateMetadataPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings?.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings?.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings?.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings?.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings?.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.PrivateMetadataPid', props);
    return resource.getResponseField('MultiplexProgram.PacketIdentifiersMap.PrivateMetadataPid') as unknown as number;
  }

  public get scte27Pids(): number[] {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.Scte27Pids'),
        outputPath: 'MultiplexProgram.PacketIdentifiersMap.Scte27Pids',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings?.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings?.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings?.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings?.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings?.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.Scte27Pids', props);
    return resource.getResponseField('MultiplexProgram.PacketIdentifiersMap.Scte27Pids') as unknown as number[];
  }

  public get scte35Pid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.Scte35Pid'),
        outputPath: 'MultiplexProgram.PacketIdentifiersMap.Scte35Pid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings?.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings?.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings?.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings?.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings?.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.Scte35Pid', props);
    return resource.getResponseField('MultiplexProgram.PacketIdentifiersMap.Scte35Pid') as unknown as number;
  }

  public get timedMetadataPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.TimedMetadataPid'),
        outputPath: 'MultiplexProgram.PacketIdentifiersMap.TimedMetadataPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings?.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings?.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings?.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings?.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings?.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.TimedMetadataPid', props);
    return resource.getResponseField('MultiplexProgram.PacketIdentifiersMap.TimedMetadataPid') as unknown as number;
  }

  public get videoPid(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateMultiplexProgram',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.VideoPid'),
        outputPath: 'MultiplexProgram.PacketIdentifiersMap.VideoPid',
        parameters: {
          MultiplexId: this.input.multiplexId,
          MultiplexProgramSettings: {
            PreferredChannelPipeline: this.input.multiplexProgramSettings?.preferredChannelPipeline,
            ProgramNumber: this.input.multiplexProgramSettings?.programNumber,
            ServiceDescriptor: {
              ProviderName: this.input.multiplexProgramSettings?.serviceDescriptor?.providerName,
              ServiceName: this.input.multiplexProgramSettings?.serviceDescriptor?.serviceName,
            },
            VideoSettings: {
              ConstantBitrate: this.input.multiplexProgramSettings?.videoSettings?.constantBitrate,
              StatmuxSettings: {
                MaximumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.maximumBitrate,
                MinimumBitrate: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.minimumBitrate,
                Priority: this.input.multiplexProgramSettings?.videoSettings?.statmuxSettings?.priority,
              },
            },
          },
          ProgramName: this.input.programName,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateMultiplexProgram.MultiplexProgram.PacketIdentifiersMap.VideoPid', props);
    return resource.getResponseField('MultiplexProgram.PacketIdentifiersMap.VideoPid') as unknown as number;
  }

}

export class MediaLiveUpdateReservation extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateReservationRequest) {
    super(scope, id);
  }

  public get reservation(): MediaLiveUpdateReservationReservation {
    return new MediaLiveUpdateReservationReservation(this, 'Reservation', this.__resources, this.input);
  }

}

export class MediaLiveUpdateReservationReservation extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateReservationRequest) {
    super(scope, id);
  }

  public get arn(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateReservation.Reservation.Arn'),
        outputPath: 'Reservation.Arn',
        parameters: {
          Name: this.input.name,
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateReservation.Reservation.Arn', props);
    return resource.getResponseField('Reservation.Arn') as unknown as string;
  }

  public get count(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateReservation.Reservation.Count'),
        outputPath: 'Reservation.Count',
        parameters: {
          Name: this.input.name,
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateReservation.Reservation.Count', props);
    return resource.getResponseField('Reservation.Count') as unknown as number;
  }

  public get currencyCode(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateReservation.Reservation.CurrencyCode'),
        outputPath: 'Reservation.CurrencyCode',
        parameters: {
          Name: this.input.name,
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateReservation.Reservation.CurrencyCode', props);
    return resource.getResponseField('Reservation.CurrencyCode') as unknown as string;
  }

  public get duration(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateReservation.Reservation.Duration'),
        outputPath: 'Reservation.Duration',
        parameters: {
          Name: this.input.name,
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateReservation.Reservation.Duration', props);
    return resource.getResponseField('Reservation.Duration') as unknown as number;
  }

  public get durationUnits(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateReservation.Reservation.DurationUnits'),
        outputPath: 'Reservation.DurationUnits',
        parameters: {
          Name: this.input.name,
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateReservation.Reservation.DurationUnits', props);
    return resource.getResponseField('Reservation.DurationUnits') as unknown as string;
  }

  public get end(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateReservation.Reservation.End'),
        outputPath: 'Reservation.End',
        parameters: {
          Name: this.input.name,
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateReservation.Reservation.End', props);
    return resource.getResponseField('Reservation.End') as unknown as string;
  }

  public get fixedPrice(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateReservation.Reservation.FixedPrice'),
        outputPath: 'Reservation.FixedPrice',
        parameters: {
          Name: this.input.name,
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateReservation.Reservation.FixedPrice', props);
    return resource.getResponseField('Reservation.FixedPrice') as unknown as number;
  }

  public get name(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateReservation.Reservation.Name'),
        outputPath: 'Reservation.Name',
        parameters: {
          Name: this.input.name,
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateReservation.Reservation.Name', props);
    return resource.getResponseField('Reservation.Name') as unknown as string;
  }

  public get offeringDescription(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateReservation.Reservation.OfferingDescription'),
        outputPath: 'Reservation.OfferingDescription',
        parameters: {
          Name: this.input.name,
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateReservation.Reservation.OfferingDescription', props);
    return resource.getResponseField('Reservation.OfferingDescription') as unknown as string;
  }

  public get offeringId(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateReservation.Reservation.OfferingId'),
        outputPath: 'Reservation.OfferingId',
        parameters: {
          Name: this.input.name,
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateReservation.Reservation.OfferingId', props);
    return resource.getResponseField('Reservation.OfferingId') as unknown as string;
  }

  public get offeringType(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateReservation.Reservation.OfferingType'),
        outputPath: 'Reservation.OfferingType',
        parameters: {
          Name: this.input.name,
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateReservation.Reservation.OfferingType', props);
    return resource.getResponseField('Reservation.OfferingType') as unknown as string;
  }

  public get region(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateReservation.Reservation.Region'),
        outputPath: 'Reservation.Region',
        parameters: {
          Name: this.input.name,
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateReservation.Reservation.Region', props);
    return resource.getResponseField('Reservation.Region') as unknown as string;
  }

  public get reservationId(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateReservation.Reservation.ReservationId'),
        outputPath: 'Reservation.ReservationId',
        parameters: {
          Name: this.input.name,
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateReservation.Reservation.ReservationId', props);
    return resource.getResponseField('Reservation.ReservationId') as unknown as string;
  }

  public get resourceSpecification(): MediaLiveUpdateReservationReservationResourceSpecification {
    return new MediaLiveUpdateReservationReservationResourceSpecification(this, 'ResourceSpecification', this.__resources, this.input);
  }

  public get start(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateReservation.Reservation.Start'),
        outputPath: 'Reservation.Start',
        parameters: {
          Name: this.input.name,
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateReservation.Reservation.Start', props);
    return resource.getResponseField('Reservation.Start') as unknown as string;
  }

  public get state(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateReservation.Reservation.State'),
        outputPath: 'Reservation.State',
        parameters: {
          Name: this.input.name,
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateReservation.Reservation.State', props);
    return resource.getResponseField('Reservation.State') as unknown as string;
  }

  public get tags(): Record<string, string> {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateReservation.Reservation.Tags'),
        outputPath: 'Reservation.Tags',
        parameters: {
          Name: this.input.name,
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateReservation.Reservation.Tags', props);
    return resource.getResponseField('Reservation.Tags') as unknown as Record<string, string>;
  }

  public get usagePrice(): number {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateReservation.Reservation.UsagePrice'),
        outputPath: 'Reservation.UsagePrice',
        parameters: {
          Name: this.input.name,
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateReservation.Reservation.UsagePrice', props);
    return resource.getResponseField('Reservation.UsagePrice') as unknown as number;
  }

}

export class MediaLiveUpdateReservationReservationResourceSpecification extends cdk.Construct {

  constructor(scope: cdk.Construct, id: string, private readonly __resources: string[], private readonly input: shapes.MediaLiveUpdateReservationRequest) {
    super(scope, id);
  }

  public get channelClass(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateReservation.Reservation.ResourceSpecification.ChannelClass'),
        outputPath: 'Reservation.ResourceSpecification.ChannelClass',
        parameters: {
          Name: this.input.name,
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateReservation.Reservation.ResourceSpecification.ChannelClass', props);
    return resource.getResponseField('Reservation.ResourceSpecification.ChannelClass') as unknown as string;
  }

  public get codec(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateReservation.Reservation.ResourceSpecification.Codec'),
        outputPath: 'Reservation.ResourceSpecification.Codec',
        parameters: {
          Name: this.input.name,
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateReservation.Reservation.ResourceSpecification.Codec', props);
    return resource.getResponseField('Reservation.ResourceSpecification.Codec') as unknown as string;
  }

  public get maximumBitrate(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateReservation.Reservation.ResourceSpecification.MaximumBitrate'),
        outputPath: 'Reservation.ResourceSpecification.MaximumBitrate',
        parameters: {
          Name: this.input.name,
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateReservation.Reservation.ResourceSpecification.MaximumBitrate', props);
    return resource.getResponseField('Reservation.ResourceSpecification.MaximumBitrate') as unknown as string;
  }

  public get maximumFramerate(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateReservation.Reservation.ResourceSpecification.MaximumFramerate'),
        outputPath: 'Reservation.ResourceSpecification.MaximumFramerate',
        parameters: {
          Name: this.input.name,
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateReservation.Reservation.ResourceSpecification.MaximumFramerate', props);
    return resource.getResponseField('Reservation.ResourceSpecification.MaximumFramerate') as unknown as string;
  }

  public get resolution(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateReservation.Reservation.ResourceSpecification.Resolution'),
        outputPath: 'Reservation.ResourceSpecification.Resolution',
        parameters: {
          Name: this.input.name,
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateReservation.Reservation.ResourceSpecification.Resolution', props);
    return resource.getResponseField('Reservation.ResourceSpecification.Resolution') as unknown as string;
  }

  public get resourceType(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateReservation.Reservation.ResourceSpecification.ResourceType'),
        outputPath: 'Reservation.ResourceSpecification.ResourceType',
        parameters: {
          Name: this.input.name,
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateReservation.Reservation.ResourceSpecification.ResourceType', props);
    return resource.getResponseField('Reservation.ResourceSpecification.ResourceType') as unknown as string;
  }

  public get specialFeature(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateReservation.Reservation.ResourceSpecification.SpecialFeature'),
        outputPath: 'Reservation.ResourceSpecification.SpecialFeature',
        parameters: {
          Name: this.input.name,
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateReservation.Reservation.ResourceSpecification.SpecialFeature', props);
    return resource.getResponseField('Reservation.ResourceSpecification.SpecialFeature') as unknown as string;
  }

  public get videoQuality(): string {
    const props: cr.AwsCustomResourceProps = {
      policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: this.__resources }),
      onUpdate: {
        action: 'updateReservation',
        service: 'MediaLive',
        physicalResourceId: cr.PhysicalResourceId.of('MediaLive.UpdateReservation.Reservation.ResourceSpecification.VideoQuality'),
        outputPath: 'Reservation.ResourceSpecification.VideoQuality',
        parameters: {
          Name: this.input.name,
          ReservationId: this.input.reservationId,
        },
      },
    };
    const resource = new cr.AwsCustomResource(this, 'UpdateReservation.Reservation.ResourceSpecification.VideoQuality', props);
    return resource.getResponseField('Reservation.ResourceSpecification.VideoQuality') as unknown as string;
  }

}

